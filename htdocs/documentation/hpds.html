<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><HTML>
<HEAD>
<TITLE></TITLE>
</HEAD>
<BODY>
<A name=1></a>HPD Version 1<br>
<b>HPD Version 1 Standard:</b><br>
<b>Command Interface for Parallel Debuggers</b><br>
Revision 2.1<br>Last updated Sept. 22, 1998<br>
List of changes taking effect in Revision 2.1 (file is updated incrementally). <br>
<b>Note: This version is still under the review-and-comment period. In particular, we expect<br>to make some changes in the names of commands and options, in response to user<br>feedback. We do not expect the functionality or semantics to change very significantly at<br>this point.</b> <br>
<b>Contents of HPD Version 1 Standard</b><br>
Introduction <br>Part 1: High-Level Overview <br>
1.1 The Debugger Interface <br>
1.1.1 What Is a Parallel Debugger? <br>1.1.2 How a Debugger Operates <br>1.1.3 The Debugger Interface <br>1.1.4 Command Model <br>1.1.5 Command and Prompt Formats <br>1.1.6 Debugger Output <br>1.1.7 Debugger Initialization and Modes of Operation <br>1.1.8 References Cited in This Chapter <br>
1.2 Effects of Parallelism on Debugger Behavior <br>
1.2.1 Naming Individual Processes and Threads <br>1.2.2 Process/Thread Sets <br>1.2.3 Named Sets <br>1.2.4 Handling Command Output from Multiple Threads <br>1.2.5 References Cited in This Chapter <br>
1.3 Controlling Program Execution <br>
1.3.1 Starting and Stopping Model <br>1.3.2 Advancing Program Execution <br>1.3.3 Actionpoints <br>1.3.4 References Cited in This Chapter <br>
1.4 Machine State, Program State, and Debugger State <br>
1.4.1 State Model: Machine State and Program State <br>1.4.2 Debugger State <br>
1.5 Symbols, Names, and Expressions <br>
1.5.1 Symbol Names and Scope <br>1.5.2 Explicit Qualification of Symbol Names <br>
1<br>
<hr>
<A name=2></a>HPD Version 1<br>
1.5.3 Expressions <br>1.5.4 Language Support <br>
1.6 Terminology and Notational Conventions <br>
1.6.1 Definitions of Key Terms <br>1.6.2 Notational Conventions <br>
Part 2: Command Descriptions <br>
2.1 General Debugger Interface <br>
# - Ignore remainder of this line (&quot;comment command&quot;) <br>alias - Create or view user-defined command(s) <br>unalias - Remove previously defined command <br>history - View the session command history <br>! - Execute a previous command from the command history <br>set - Change or view value(s) of debugger state variable(s) <br>unset - Restore default setting(s) for debugger state variable(s) <br>log - Start or stop the logging of debugger input/output <br>input - Read and execute commands stored in a file <br>proginput - Send command-line input to the target program, rather than the<br>debugger <br>info - Display debugger environment information <br>help - Display help information <br>
2.2 Process/Thread Sets <br>
focus - Change the current process/thread set <br>defset - Assign a set name to a group of processes/threads <br>undefset - Undefine a previously defined process/thread set <br>viewset - List the members of a process/thread set <br>whichsets - List all sets to which a process/thread belongs <br>
2.3 Debugger Initialization/Termination <br>
load - Load debugging information about target program and prepare for<br>execution <br>run - Start or re-start execution of target process(es) <br>attach - Bring currently executing process(es) under control of the debugger <br>detach - Detach debugger from target process(es), leaving it executing <br>kill - Terminate execution of target process(es) <br>core - Load core-file image of process(es) for examination <br>status - Show current status of processes and threads <br>quit, exit - Terminate the debugging session <br>
2.4 Program Information <br>
list - Display source code lines <br>where - Display the current execution location and call stack <br>up - Move up one or more levels in the call stack <br>down - Move down one or more levels in the call stack <br>what - Determine what a target program name refers to <br>
2.5 Data Display and Manipulation <br>
print - Evaluate and display the value of a program variable or expression <br>assign - Change the value of a scalar program variable <br>
2<br>
<hr>
<A name=3></a>HPD Version 1<br>
2.6 Execution Control <br>
step - Execute statement(s) by a specific process/thread <br>go - Resume execution of process(es) <br>halt - Suspend execution of process(es) <br>cont - Resume execution of process(es), blocking further commands <br>wait - Block command input until process(es) stop <br>
2.7 Actionpoints <br>
break - Define a breakpoint <br>barrier - Define a barrier point <br>watch - Define an unconditional watchpoint <br>actions - Display a list of actionpoints <br>delete - Delete actionpoint(s) <br>disable - Temporarily disable actionpoint(s) <br>enable - Re-enable actionpoint(s) that has been disabled <br>export - Store actionpoint settings for future re-use <br>
Part 3: HPD User Guide <br>
Part 4: Reference Summaries <br>
4.1 Command Syntax Summary <br>
4.1.1 Basic (Shared) Syntax <br>4.1.2 Required Commands <br>4.1.3 Language Extensions <br>
4.2 Comprehensive Index <br>
<b>Introduction</b><br>
The High Performance Debugging Forum (HPDF) is a collaborative effort involving both<br>researchers and commercial debugger developers in the area of parallel debugging, as well as<br>representatives of HPC (high-performance computing) user organizations. Established in March<br>of 1997, its goal is to define standards relevant to debugging tools for HPC systems. HPDF is<br>sponsored by the Parallel Tools Consortium. <br>
HPDF is approaching this standards effort by subdividing the relevant issues into different<br>versions, or layers, such that each successive version builds upon previous ones. This document<br>deals with the first version and defines a standard command-based (i.e., non-graphical) interface<br>for parallel debuggers. Future versions will deal with such issues as graphical interfaces and<br>more complex I/O. While much of the standard is equally applicable to serial debuggers,<br>attention has focused on those issues that arise when the program being debugged includes<br>multiple threads and/or processes. <br>
The document is divided into four parts. Part 1 provides a *high-level introduction* to the<br>standard by laying out the conceptual model on which it is based. Definitions of terminology and<br>a description of notational conventions are also included. Part 2 provides *detailed information*<br>
3<br>
<hr>
<A name=4></a>HPD Version 1<br>
on syntax, semantics, implementation, and interpretation of each command in the standard. Part<br>3 is a *user-level view* of the standard, presented in a form suitable for an on-line user guide.<br>Part 4 provides a *syntax summary* and *comprehensive index*. <br>
[<b>Note</b>: For the most part, this document was written for use by debugger implementors and<br>sophisticated debugger users who have an interest in understanding or influencing the details of<br>a debugger standard. Non-developer users are directed to the *user guide* (Part 3), for a<br>straightforward definition of the syntax and semantics of the standard commands.] <br>
<b>Goals of the HPD Standard</b><br>
HPDF is, to our knowledge, the first group that has attempted to establish a debugger standard<br>of any kind. Although some serial debuggers are supported on multiple platforms (e.g., <b>gdb</b> [1]<br>and <b>dbx</b> [2]), there are no published standards or rigorous definitions of semantics for<br>debuggers. Therefore, individual implementations are subject to considerable variation in both<br>the kinds of commands that are available and what specific actions are performed in conjunction<br>with any particular command. <br>
Within the parallel programming community, a lack of standards has resulted in the same kinds<br>of debugger variations. In addition, few debuggers are supported across more than one platform<br>and debuggers are generally criticized for poor usability. The HPDF standard is expected to<br>make a major contribution in solving these problems. Therefore, debuggers which meet the<br>HPDF standard should: <br>
satisfy the basic debugging requirements of HPC application developers; <br>be usable - in the sense of easy to learn and easy to use - by HPC application developers;<br>and <br>be consistent across platforms, so that users of one HPD-conforming debugger can switch<br>to another HPD-conforming debugger with little or no effort. <br>
Specifically, the goals of the HPD Version 1 standard are as follows: <br>
1. Capture the best-practice knowledge and experience of parallel debugger implementors<br>
across the industry. <br>
2. Establish a well-defined, testable, and minimal core set of features that can be implemented<br>
on all HPC systems. <br>
3. Ensure that parallel debugger implementors provide this set of features in a consistent way. <br>4. Limit the core set in size so that initial commercial implementations can be available within<br>
a year of the standard's release. <br>
To meet these goals, the HPD Version 1 standard defines the syntax and semantics of<br>commands for the most needed debugging functions. Individual implementations are free to add<br>other commands - indeed, this may be necessary in order to support debugging of<br>machine-specific features. Conforming debuggers, however, support all features defined as<br>
4<br>
<hr>
<A name=5></a>HPD Version 1<br>
requirements (see below). <br>
<b>Applicability of the Standard</b><br>
Because HPDF addresses the needs of HPC debugging, this standard is targeted at debuggers<br>for programs that are: <br>
&quot;high-performance&quot; in nature (i.e., performance is an important consideration) and typically<br>parallel <br>written in one or more high-level languages <br>intended to run on possibly many different computer systems <br>
Explicit parallelism was assumed as the basic programming model. The HPD Version 1 standard<br>is applicable to both shared-memory programming (multiple threads of execution in an address<br>space) and distributed-memory programming (multiple processes co-operating via<br>message-passing libraries, such as PVM or MPI). Standard-conforming debuggers may also be<br>useful for implicitly parallel programs (e.g., auto-parallelized DO loops or array operations), but<br>the issues of how to map from runtime or intermediate-level information to original user source<br>code are not being addressed in HPD Version 1. <br>
The standard has been defined to distinguish the functionality needed for <i>threads-only</i>,<br><i>processes-only</i>, and <i>multilevel</i> (multi-process and multi-thread) models of parallelism. Where<br>the constraints of these models differ, the standard specifies how a debugger supporting each<br>model will behave. Since it is assumed that each debugger implementation will elect to support<br>one of the three models, we refer generally to &quot;threads-only debuggers,&quot; &quot;processes-only<br>debuggers,&quot; and &quot;multilevel debuggers.&quot; <br>
The overall objective is to make it possible for debuggers of all three types to provide support<br>that is as consistent as possible, given the constraints imposed by the underlying model. Thus, if<br>a user's application is multi-process, the behavior of the debugger should be consistent,<br>regardless of whether it is a processes-only or a multilevel debugger. (In this example, a<br>threads-only debugger, which cannot support multiple processes, would likely require that the<br>user employ multiple instantiations of the debugger, one per process.) A multilevel debugger<br>may elect to support alternative modes of operation for user applications that involve a single<br>process or processes with single threads (modal support is described in this document), making<br>it possible to simplify somewhat the ways in which the user interacts with the debugger. <br>
The major languages considered by the authors of the standard were Fortran (F77 and F90), C,<br>and C++. In principle, the standard could apply to other languages, but debugger syntax was not<br>explicitly checked for conflicts with expression syntax in other languages. Moreover, the<br>standard does not address interpreted languages, which typically are packaged with a built-in<br>debugger. <br>
Though we expect standard-conforming debuggers to offer some machine-level debugging<br>
5<br>
<hr>
<A name=6></a>HPD Version 1<br>
features, such support will be in the nature of extensions, since HPD Version 1 does not<br>explicitly address assembly-level debugging. Rather, it is assumed that the target program is<br>written in a high-level language and that the debugger users wish to interact with their programs<br>at the high-level language level. <br>
The standard attempts to be operating-system neutral, in the sense that it should be possible to<br>build a standard-conforming debugger on a variety of different operating systems. Similarly, this<br>standard attempts to be computer-architecture neutral. Cases where features are known to be<br>system-dependent have been explicitly called out, with suggestions of how the variation should<br>be accommodated. <br>
<b>Conformance to the Standard</b><br>
<b>Requirements</b>: A debugger conforms to the HPD Version 1 standard if it implements all<br>required commands according to this document, preserving the syntax and semantics defined<br>here. In some cases, the requirements vary according to whether the debugger supports target<br>programs with multiple threads, multiple processes, or both. While such variations are permitted,<br>each implementation must conform to exactly one of the models presented in this document<br>(threads-only debugger, processes-only debugger, or multilevel debugger) and must inform the<br>user which model is in effect. A debugger that mixes behavior from two or more models is not<br>standard conforming. <br>
<b>Implementation-specific Variations</b>: It is expected that implementations will provide<br>additional functionality and commands, but conformance will hold only if neither the syntax nor<br>semantics of such additions conflict with the HPD definitions. Where specific elements - such as<br>the content of command output - may be implementation-specific in form or detail, this is<br>specified clearly in the document using words such as &quot;implementors may elect to....&quot; In some<br>cases, the variation imposes additional requirements for user documentation; these, too, are<br>identified clearly. <br>
<b>Advisory Elements:</b> In addition to defining the HPD Version 1 standard, this document<br>presents a number of <i>recommendations</i> about how features might be implemented effectively, as<br>well as <i>extensions</i>. The extensions provide preliminary information about anticipated future<br>versions of the standards or features that are considered important by users but cannot be<br>required at this point (e.g., because of dependencies on hardware or operating system support).<br>These advisories are based on our discussions about particular debugger functions and reflect<br>the direction a future standard is likely to take. They are meant to give guidance to developers<br>who are currently working on these functions. While there is no guarantee that future additions<br>to the standard will be defined in the same way, efforts will be made to maintain their general<br>organization and semantics. <br>
<b>Formulation of the Standard</b><br>
6<br>
<hr>
<A name=7></a>HPD Version 1<br>
The HPD Version 1 standard was formulated by the HPDF group through a series of meetings<br>and electronic communications throughout 1997. User input into the discussions came from<br>users attending the meetings as well as feedback from members of the Parallel Tools<br>Consortium. <br>
HPDF is co-chaired by: <br>
Cherri Pancake, <i>Oregon State University</i> <br>Joan Francioni, <i>University of Southwestern Louisiana</i> <br>Jeff Brown, <i>Los Alamos National Laboratory</i> <br>
Active members of HPDF working groups include the following: <br>
Gail Alverson, <i>Tera Computer Company</i> <br>Shirley Browne, <i>University of Tennessee</i> <br>Suresh Damodaran-Kamal, <i>Hewlett-Packard / Convex Division</i> <br>John Del Signore, <i>Dolphin Interconnect Solutions, Inc.</i> <br>Erica Dorenkamp, <i>Sun Microsystems</i> <br>Howard Gordon, <i>National Security Agency</i> <br>Robert Hood, <i>MRJ - NASA Ames Research Center</i> <br>Janis Johnson, <i>Sequent Computer Systems</i> <br>Chuck Koelbel, <i>CRPC, Rice University</i> <br>David La France-Linden, <i>Digital Equipment Corporation</i> <br>John May, <i>Lawrence Livermore National Laboratory</i> <br>Juliana Rew, <i>NCAR/Scientific Computing Division</i> <br>John Robb, <i>IBM</i> <br>Stan Shebs, <i>Cygnus Solutions</i> <br>Lauren Smith, <i>National Security Agency</i> <br>Michael Snyder, <i>Cygnus Solutions</i> <br>Richard Title, <i>Hewlett-Packard</i> <br>Roland Wismueller, <i>LRR-TUM, University of Technology, Munich, Germany</i> <br>
Others who contributed to relevant discussions include: <br>
Richard Barrett, <i>Los Alamos National Laboratory</i> <br>Bevin Brett, <i>Digital Equipment Corporation</i> <br>Jim Cownie, <i>Dolphin Interconnect Solutions, Inc.</i> <br>Mike Frese, <i>Numerex</i> <br>Pete Johnson, <i>SGI/Cray Research</i> <br>Tim Kane, <i>IBM</i> <br>Mike McKay, <i>Los Alamos National Laboratory</i> <br>Geoffrey Tennille, <i>NASA Langley Research Center</i> <br>Chris Warber, <i>Pacific-Sierra Research</i> <br>Joel Williamson, <i>Hewlett Packard</i> <br>Michael Wolfe, <i>The Portland Group</i> <br>
7<br>
<hr>
<A name=8></a>HPD Version 1<br>
Brian Wylie, <i>Swiss Center for Scientific Computing</i> <br>John Zollweg, <i>Cornell Theory Center</i> <br>Mary Zosel, <i>Lawrence Livermore National Laboratory</i> <br>Richard Zwakenberg, <i>Lawrence Livermore National Laboratory</i> <br>
Special thanks goes to the following people for help in logistics, organization of Web pages, and<br>Web survey forms: <br>
Ken Ferschweiler, <i>Oregon State University</i> <br>Mark Newsome, <i>Oregon State University</i> <br>Joan Winter, <i>Oregon State University</i> <br>David Haney, <i>Oregon State University</i> <br>Denise Hirata, <i>Oregon State University</i> <br>
In addition, a large number of users participated in the user surveys and requests for user<br>feedback issued by the working groups and HPDF as a whole. We gratefully acknowledge their<br>participation in the effort. <br>
<b>Name and Ownership Issues</b><br>
According to the objectives of the High Performance Debugging Forum and its sponsoring<br>organization, the Parallel Tools Consortium (Ptools), the HPD Version 1 standard is made<br>available for royalty-free adoption and use by any public or private organization. Copyright is<br>retained by the High Performance Debugging Forum and Oregon State University. (Queries<br>concerning its use should be directed to pancake@ptools.org.) <br>
The name &quot;High Performance Debugger&quot; and its abbreviation &quot;HPD&quot; are used as a convenience.<br>Proprietary implementations are not required to use those names, but an alias should be<br>provided to associate the name <b>hpd</b> with the proprietary debugger, for the benefit of users<br>familiar with the generic HPDF name. <br>
Implementors are asked to refer explicitly to the HPDF and this document in their support<br>documentation. They are also requested to notify HPDF of their plans to release debuggers<br>conforming to, or derived from, the standard by sending email to pancake@ptools.org. (This<br>will add them to the distribution list for any updates.) <br>
<b>References Cited in This Chapter</b><br>
[1] Richard Stallman and Cygnus Support, <i>Debugging with GDB</i>, Cygnus Solutions, Inc., 1994.<br>
[2] SunSoft, Inc., <i>Solaris Application Developer's Guide</i>, 1997, 013-205097-8. <br>
8<br>
<hr>
<A name=9></a>HPD Version 1<br>
<b>Part 1:</b><br>
<b>Conceptual Model for HPD Version 1</b><br>
<b>Standard</b><br>
Working Version 2.1 - last revised Sept. 10, 1998 <br>
<i>Comments and requests for clarification are welcome. They should be submitted to<br>hpd-comments@ptools.org.</i> Part 1 of this document provides an overview of the HPD Version 1<br>standard by describing the conceptual model on which it is based. Terms and concepts used<br>throughout the standard document are introduced here; concise definitions will be found in the<br>terminology chapter. <br>
The first chapter describes the role of a debugger and its relationship to the user's program. This<br>is followed by a discussion of how parallelism affects the behavior of a debugger. A third<br>chapter outlines our model for controlling program execution. The state model employed for<br>describing the effects of HPD commands occupies a separate chapter, followed by a brief<br>treatment of how symbols, names, and expressions are handled. <br>
The part concludes with a chapter presenting a comprehensive list of terms employed in the<br>document and a description of notational conventions. <br>
<b>High-Level Overview</b><br>
<b>1.1 Debugger Interface</b><br>
Working Version 2.1 - last revised Sept. 11, 1998 <br>
<i>Comments and requests for clarification are welcome. They should be submitted to<br>hpd-comments@ptools.org.</i> <br>
<b>1.1.1 What Is a Parallel Debugger? </b><br>
A debugger is a tool that gives a user visibility into, and control over, an executing program -<br>the <b><i>target program</b></i>. A parallel debugger performs that function for a <b><i>parallel program</b></i>. As<br>described in the introduction, the HPD Version 1 standard is intended to support debugging of<br>programs that implement parallelism through explicit statements or compiler directives in a<br>high-level language. <br>
An executing program has three basic components: <br>
1. the <b><i>source file(s)</b></i> for the program: the user's program files, written in one or more<br>
9<br>
<hr>
<A name=10></a>HPD Version 1<br>
high-level languages <br>
2. the <b><i>executable(s)</b></i>: a compiled and linked version of the source files, containing a &quot;main&quot;<br>
entry point <br>
3. any <b><i>shared library(ies)</b></i>: a compiled and linked set of sources that are dynamically loaded<br>
by other executables (and have no &quot;main&quot; entry point) <br>
The target program of the debugger is related to all three of these, but we use the term to refer<br>specifically to the <i>executing</i> user program (rather than source or object files), or a user program<br>that has been loaded into memory. <br>
In the world of parallel computing, an executing user program consists of one or more<br><b><i>processes</b></i>, each associated with a particular executable (and perhaps one or more shared<br>libraries) and each occupying a memory address space. Every process, in turn, has one or more<br><b><i>threads</b></i>, each with its own register set and its own stack. <br>
The target program is the complete set of threads and/or communicating processes that make up<br>a given execution of the user's application. The exact number depends on many factors,<br>including how the user wrote the program, the transformations performed by the compiler, the<br>way the program was invoked, and the sequence of events that occur during execution. Thus,<br>the number of processes/threads can change over the course of program execution. <br>
Some operating systems, compilers, or run-time systems impose restrictions on the relationship<br>between processes/threads and executables. <b><i>SPMD (Single Program Multiple Data) programs<br></b></i>are parallel programs involving just one executable, executed by multiple threads and/or<br>processes. <b><i>MPMD (Multiple Program Multiple Data) programs</b></i> involve multiple executables,<br>each executed by one or more threads and/or processes. For the most part, no distinction is<br>made in this document between the two models. Some HPD-conforming debuggers, however,<br>may require that the target program be SPMD. <br>
Debuggers also may constrain the number of threads or processes in the target program. A<br><b><i>threads-only debugger</b></i> is one that is only capable of debugging a single process, although it may<br>contain many threads. Similarly, a <b><i>processes-only debugger</b></i> cannot recognize threads within a<br>process; its operations can be applied to a program with many processes, but each may contain<br>only a single thread. We refer to debuggers that are capable of managing multiple processes,<br>each containing multiple threads, as a <b><i>multilevel debugger</b></i>. Throughout this document, any<br>operations that behave differently under these three categories are called out explicitly. <br>
Note that any parallel debugger could also be used to debug a serial program (one consisting of<br>a single process with a single thread). The focus of attention in this document, however, is<br>support for debugging parallel programs. <br>
<i>Special note: For the remainder of this document, we employ the word &quot;threads&quot; to refer to<br>&quot;processes and/or threads.&quot; In cases where a distinction needs to be drawn between the<br>circumstances associated with processes or with threads, this will be called out explicitly.</i> <br>
10<br>
<hr>
<A name=11></a>HPD Version 1<br>
<b>1.1.2 How a Debugger Operates</b><br>
The debugger affects the target program but is not part of its target program's execution. That<br>is, we think of it as running in separate process(es), and we define debugger semantics separately<br>from the semantics of the target program language. (For an alternate way of defining debugger<br>semantics, see [1].) The debugger communicates with the target program according to an<br>execution-time interface that is usually operating system-specific (e.g., ptrace or /proc). <br>
A debugger takes as input the executable(s) that constitute the target program. Because<br>debugging is to be supported at the level of the source code language, each executable must be<br>associated with <b><i>debugging information</b></i>. On most target systems, this requires that the<br>executable be prepared with special compiler options, such as &quot;-g&quot;, in effect. Debugging<br>information serves two main functions: <br>
1. It provides a means for the debugger to give high-level output to the user, expressed in<br>
terms of the variables and procedures used in the source code. <br>
2. It provides access for the debugger to the smaller components of the program (such as<br>
source files), eliminating the need for some assistance from the user. <br>
This standard does not specify what debugger features are accessible when files have not been<br>compiled to produce full debugging information. <br>
<b>Recommended Practices:</b> It is hoped that most implementors will be capable of operating<br>on a target program whose executables do not have full debugging information. It is likely<br>that debugger operations will be restricted or constrained in this case. <br>
There are three general ways that the debugger may be used. First, the target program may be<br>executed from within the debugger environment; that is, after invoking the debugger. With some<br>operating systems, the user must &quot;acquire&quot; nodes in a separate step; if so, that step must be<br>performed before the debugger is invoked. <br>
Second, the debugger may be associated with (or in operating system terms, <i>attached to</i>) a<br>program that is already executing in the normal run-time environment. In either case, if the<br>target program consists of many processes, the debugger may need to interact with the run-time<br>system or the library that is responsible for managing those processes (e.g., PVM [2] or MPI<br>[3]). <br>
Third, the debugger may be associated with a parallel program that terminated abnormally, as<br>long as an &quot;image&quot; of the running program was captured and stored as a <b><i>core file</b></i>. (When a<br>system generates multiple core-files from a single program, the debugger will provide a<br>mechanism to piece them together so that the entire target program can be accessed.) Since<br>there are no running process(es) associated with the target program, however, only certain<br>debugging operations are available for <b><i>core-file debugging</b></i>. In particular, while it is possible to<br>
11<br>
<hr>
<A name=12></a>HPD Version 1<br>
examine the location of the program and the values of its variables, it is not possible to modify<br>anything about the program image preserved in the core-file. The command description chapters<br>clearly indicate which operations are permitted or not permitted during core-file debugging. <br>
The HPD Version 1 standard defines three different commands for initiating the three types of<br>debugging. <br>
To execute the target program from within the debugger, two commands are needed: <br>
load command, followed by <br>run command. <br>
Splitting this into two commands makes it possible for the user to set initial actionpoints in<br>the target program before execution begins. This also makes it possible to execute a<br>program more than once, keeping debugger state settings (such as the location of<br>actionpoints) in effect. Issuing a subsequent run command tells the debugger to re-start<br>program execution, perhaps sending it new command-line arguments. Issuing a subsequent<br>load command causes the debugger to load a fresh copy of the program from the file<br>system into memory (e.g., after editing and re-compiling the program). This has the side<br>effect of creating a new process(es); a run command is then needed to start it executing. <br>
<b>Recommended Practices:</b> It is hoped that most implementors will extend the syntax<br>of the run command so that its argument structure mimics the command-line interface<br>for starting programs. For example, if the user can specify which processors should be<br>used in executing a program, this option should also be supported from within the<br>debugger. <br>
The kill command forcibly terminates one or more processes of a program that was<br>started using load and run. <br>
To associate the debugger with a currently executing target program, the attach command<br>is used instead. <br>
This action can be reversed with the detach command, which releases a process from<br>debugger control, leaving it executing in the normal run-time environment. <br>
The core command is employed when the debugger is to be associated with a core-file<br>image. <br>
<b>1.1.3 The Debugger Interface</b><br>
A debugger also has a user interface, whereby it receives user input on what actions should be<br>taken to control the target program's execution or to reveal information about it. For purposes<br>of HPD Version 1, this is a command-language (non-graphical) interface. Note that the target<br>program may also have a command-line interface; if so, it is often directed to the &quot;terminal<br>device&quot; from which the program was invoked. When a program is executing under the control of<br>
12<br>
<hr>
<A name=13></a><IMG src="hpd-13_1.jpg"><br>
HPD Version 1<br>
the debugger, the relationship between these interfaces can be problematical (see the figure).<br>Both the debugger and the user's application may be reading input or writing output to the same<br>terminal - perhaps at the same time. <br>
<i>Relationship between debugger interface and program interface</i><br>
The HPD Version 1 standard does not require that the debugger's I/O be kept separate from that<br>of the target program's I/O. <br>
<b>Recommended Practices:</b> If possible on the target system, implementors are encouraged<br>to provide a mechanism whereby debugger I/O can be kept visually distinct from target<br>program I/O. For example, where the debugger is running in a windowing environment, the<br>implementor is encouraged to redirect target program I/O to a separate window from that<br>of the debugger I/O. This is not mandated by the HPD Version 1 standard, however,<br>because there are target systems or occasions (such as interactions through a single telnet<br>connection) when this is not feasible. <br>
It does require, however, a uniform mechanism by which the user can indicate whether typed<br>input is intended for the program or for the debugger. This is accomplished by means of toggling<br>
13<br>
<hr>
<A name=14></a>HPD Version 1<br>
the <b><i>input mode</b></i> between &quot;program&quot; and &quot;debugger.&quot; Initially, <i>debugger input mode</i> is in effect;<br>that is, all input is directed through the debugger interface (see diagram). A proginput<br>command must be issued to change to <i>program input mode</i>, so that input is passed directly to<br>the program interface, as if the program were running by itself (without the debugger). The<br>absence of a debugger prompt is a visual reminder to the user that all typing effectively bypasses<br>the debugger. <br>
To change from program input mode back to debugger input mode, it is necessary to &quot;interrupt&quot;<br>the proginput command by using the user interrupt key. This automatically restores debugger<br>input mode. The debugger responds by issuing a command line prompt. The following sequence<br>demonstrates how this would work if the target program needed two user-supplied values (user<br>typing appears in boldface). <br>
[all]&gt; <b>run</b> <br>
<i> </i> <br>
[all]&gt; <br>
<i>Debugger prompts for next command</i> <br>
Enter degrees of freedom: <br>
<i>Program prompts for first value</i> <br>
<b>proginput</b> <br>
<i>User switches to program input mode</i> <br>
<b>4</b> <br>
<i>User interacts with program, </i><br>
File for results: <b>temp.dat  </b><i>... <br></i><b>^C</b> <br>
<i>then exits back to debugger input mode    </i> <br>
[all] <br>
<i>Debugger prompts for next command</i> <br>
<b>1.1.4 Command Model</b><br>
The user interacts with the debugger through commands. Execution of any command by the<br>debugger has one or more of the following effects: <br>
Information about the target program is displayed to the user. <br>A change takes place in the current state of the target program (described in detail in<br>Chapter 1.3). <br>A change takes place in the information that the debugger maintains about the target<br>program. <br>
The debugger indicates completion of a command, and readiness to accept another one, by<br>issuing a prompt. <br>
This command model is sequential in the sense that only one command is being processed at any<br>given time. For instance, if the user issues a command to print out an array, the debugger does<br>not prompt again until all elements of the array have been displayed. The HPD Version 1<br>standard does not define any kind of &quot;background command execution&quot; capability analogous to<br>the use of an ampersand within a UNIX shell. (It is, of course, fine if an implementation includes<br>this feature.) <br>
14<br>
<hr>
<A name=15></a>HPD Version 1<br>
Because the command model is sequential, it is important that the description of each command<br>in the standard define explicitly when that command is considered &quot;complete.&quot; For some<br>commands, this is obvious - in the previous example, the command is done when it finishes<br>printing the requested values. For others, such as single-stepping execution through a procedure,<br>the moment of completion is not as intuitively obvious. Still other commands, like the setting of<br>a breakpoint, may cause deferred reactions at some later time. <br>
Note that this sequential nature applies to debugger commands, not to their relationship with<br>program execution. The HPD command model does not require that the target program be<br>&quot;stopped&quot; when the debugger prompts for and performs commands. It dictates only that one<br>command be complete before another can be issued. Some processes may continue to execute<br>while the debugger is performing commands. <br>
Some commands cannot be performed by the debugger if the target program is still active. For<br>example, it may not be possible to print the values of an array if one or more processes is still<br>executing (and hence, might change those values). Each command description explicitly states<br>when the command can be issued and what type of error ensues if the command is attempted at<br>other times. <br>
The <b><i>user interrupt key</b></i> is a keystroke that is used to interrupt commands. The most common<br>user interrupt key is <b>^C</b> (Control-C); however, the actual keystroke varies from one run-time<br>environment to another. Therefore, the value of the user interrupt key will be inherited by the<br>debugger from the specific environment where the debugger was invoked. (This value may also<br>be affected by the remote communications software being used.) The effects of interrupting a<br>command depend on the operation being performed, and are discussed in the individual<br>command descriptions of Part 2. <br>
<b>1.1.5 Command and Prompt Formats</b><br>
The appearance of the <b><i>debugger prompt</b></i> is a visual cue that the debugger is ready to accept<br>another user command. The form of the prompt may be changed by the user (via the debugger<br>state variable PROMPT, which is modified by the set command). By default, the prompt lists the<br>threads to which the next command will apply, using the set notation described under Effects of<br>Parallelism on Debugger Behavior. This is followed by the greater-than sign and a blank space.<br>Because the list can be lengthy for a program involving many threads, it will be truncated when<br>it exceeds the length indicated by the debugger environment variable MAX_PROMPT; an ellipsis is<br>appended to indicate that only part of the list is shown. Examples of prompts are: <br>
[all]&gt; <br>
<i>all threads involved in the target program</i> <br>
[1.0,1.1]&gt; <br>
<i>just the first two threads in process 1</i> <br>
[1.*,2.*]&gt;       <i>all threads in processes 1 and 2</i> <br>
Each command in the HPD Version 1 standard is of the following general form: <br>
15<br>
<hr>
<A name=16></a>HPD Version 1<br>
[<i>p/t-set/prefix</i>] <i>verb object</i> [<i>option</i> ...] [-<i>option</i> [<i>value</i>] ...] <br>
An optional prefix specifies the process/thread set to which the command will apply. This<br>concept is described in the next chapter. <br>
All elements of the command language are case-sensitive. The command verb indicates what<br>operation should be performed by the debugger. HPD verbs are reserved words. They need not<br>be typed out completely; any <b><i>unambiguous prefix</b></i> will be accepted in place of the full verb. For<br>example, al, ali, alia, and alias all refer to the same command. A simple a does not,<br>however, as it is ambiguous (could refer to alias or assign). When a prefix is ambiguous, the<br>debugger issues an error message that includes the names of all commands to which the prefix<br>might refer. <br>
Most commands defined in this document accept a single object, followed by zero or more<br>options. Some commands, such as assign and alias require two objects, and some do not take<br>any arguments at all. The syntax summary presents a listing of all command formats. <br>
Each command option is preceded by a hyphen, and consists of an option keyword and perhaps<br>a value. As the name implies, options are not required. <br>
In general, a command is terminated by a newline character. This format is referred to as a<br><b><i>simple command</b></i>, as it includes only one verb and directs the debugger to perform just one<br>action. When it is necessary to continue a command onto the next line, the backslash character<br>(\) is used at the end of the line as a continuation character. <br>
The HPD Version 1 standard includes a mechanism for creating <b><i>user-defined commands</b></i>. In its<br>simplest form, a user-selected name can be defined to be a synonym for a debugger verb, making<br>it possible to customize the verbs so that they are more easily remembered. The names of<br>user-defined commands are case-sensitive. They must be spelled out in full; that is, unambiguous<br>prefixes will not be recognized by the debugger. <br>
User-defined commands can also be used to create shortcuts for commonly used commands. In<br>this case, the user might wish to define a <b><i>compound command</b></i>, or one that takes several<br>actions. In this case, simple commands are strung together, separated by semicolons. For HPD<br>Version 1, this is the only context within which the semicolon can be used as a command<br>delimiter. <br>
More general macro capabilities (e.g., parameter substitution) are not available in HPD Version<br>1. <br>
<b>1.1.6 Debugger Output</b><br>
The debugger issues a variety of messages in response to user input. Some of these confirm that<br>an operation completed successfully or indicate that some problem occurred. Others provide<br>
16<br>
<hr>
<A name=17></a>HPD Version 1<br>
in-depth detail about what the debugger - or the target program - is doing. <br>
Generally speaking, the amount and type of output differs from one command to the next, and is<br>discussed in the individual command descriptions of Part 2. The HPD Version 1 standard does<br>provide three coarse levels for controlling the amount of diagnostic output: <br>
ERR: Debugger generates a small amount of output concerning the target program, and<br>restricts debugger messages to error conditions. <br>WARN: (default) Normal output, error messages, plus warning messages when user actions<br>appear to be unintentional or problematic. <br>ALL: Debugger generates full output concerning the target program, and adds diagnostic<br>information on its own operations. <br>
The output control setting is stored in the debugger state variable VERBOSE. When its value is<br>ALL, <b><i>verbose output</b></i> is said to be in effect. <br>
Another debugger state variable, ERROR_CHECKS, permits the user to control how often the<br>debugger tests for the possibility that the user mis-applied a debugger command. Examples of a<br>potentially unintended command might be assigning a new value to <b>x</b> on multiple threads, where<br>the name refers to different variables for some threads, or asking the debugger to delete all<br>user-defined p/t sets. Again, there are three settings for the state variable: <br>
MIN: User is never asked to confirm a possible unintended operation, nor are warnings<br>issued after the operation has occurred. (Fastest but most &quot;dangerous&quot; mode; can be useful<br>when executing scripts of debugger commands.) <br>NORMAL: (default) User is prompted to confirm before the debugger takes an action that<br>might have fatal consequences. For operations that were possibly unintended, a warning<br>message is issued to let the user know what was done. <br>MAX: User is prompted to confirm whenever an operation appears to have been unintended.<br>(Slowest but &quot;safest&quot; mode.) <br>
A third debugger state variable, MAX_LIST, can be used to control the number of source code<br>lines displayed in response to list commands. <br>
It is possible to suppress all command output to the screen by directing the debugger to route its<br>output to a file (using a log -quiet command). The same command can be used to capture the<br>stream of commands typed by the user, the stream of responses from the debugger, or both, to a<br>file for storage. Output from the target program may not appear in the log, however, depending<br>on how I/O is being performed by the underlying operating system. <br>
Debuggers differ from other interactive tools in that some output may appear on the screen not<br>at the time a command is issued, but at some later time. This is particularly the case for<br>commands related to actionpoints, such as the command for defining breakpoints. Typically, the<br>debugger generates no immediate output when the breakpoint is set, but produces <b><i>deferred<br>output</b></i> in the form of an informatory message that appears each time a process or thread arrives<br>at the breakpoint. Immediate and deferred output are discussed in the &quot;Command Output&quot;<br>
17<br>
<hr>
<A name=18></a>HPD Version 1<br>
portion of each command description. <br>
A related question is when deferred output should be generated - and when the debugger should<br>detect the program event responsible for the deferred output. If the debugger detects and reports<br>events as soon as it is aware of them, the user might not be able to type a command without<br>interruption (or many interruptions if there are many processes arriving at the breakpoint). On<br>the other hand, the fact that the event occurred may make the user want to change the command<br>so that it does something else; if the debugger defers event detection until after the user has<br>finished typing a command, this would not be possible. Both models are useful for specific sets<br>of circumstances. <br>
The debugger's <b><i>event handling mode</b></i> controls when events are detected and reported. By<br>default, the debugger allows the occurrence of an event to interrupt any user input. It handles<br>the event immediately, reports it to the user (if appropriate), then re-types any characters that<br>the user had already entered prior to the interruption. Any keystrokes entered while this was<br>going on would also be echoed at that point. <br>
To prevent the debugger from detecting events while a command is being typed, the debugger<br>state variable EVENT_INTERRUPT may be set to OFF. <br>
<b>1.1.7 Debugger Initialization and Modes of Operation</b><br>
A <b><i>debugger initialization file</b></i> provides a mechanism for beginning each debugging session by<br>establishing a customized debugging environment. This file must be named <b>.hpdinit</b>, and must<br>be located in the user's home directory or the directory where the debugger was invoked; if<br>present in both locations, the copy in the current directory takes precedence. <br>
Typically, the file contains user-defined command specifications and any other commands that<br>should be executed automatically whenever a new debugging session is started. Each HPD<br>implementation provides a sample <b>.hpdinit</b> showing the names and default values for all<br>debugger state variables. Comments can be inserted using the comment command. <br>
The debugger also maintains a <b><i>command history list</b></i>, which stores copies of the most recent<br>commands issued by the user. This can be accessed to echo previous commands, or to<br>re-execute some command in the history list. The user can control the length of the command<br>list through the debugger state variable MAX_HISTORY. <br>
As described previously, some debuggers restrict the target program to just one process<br>(threads-only debuggers), while others (multilevel debuggers) permit any combination. One<br>consequence is that for processes-only or threads-only debugging, dual process/thread identifiers<br>are not required. Other syntactic shortcuts are possible, and for some commands the semantics<br>of operations differ as well; details are provided in the command description chapters. <br>
This situation gives rise to the concept of <b><i>debugging mode</b></i>, which is tracked in the debugger<br>
18<br>
<hr>
<A name=19></a>HPD Version 1<br>
state variable MODE. For processes-only or threads-only debuggers, the value (PROCESSES or<br>THREADS, respectively) remains constant throughout the debugging session and serves an<br>informational role only. <br>
For multilevel debuggers, the variable is initially set to MULTILEVEL but the user may change it<br>using the set command, thereby indicating to the debugger that the target program will employ<br>only a single process with multiple threads (if the value is changed to THREADS), or multiple<br>processes with a single thread each (if PROCESSES). Once the mode has been changed, any<br>appropriate command shortcuts may be used. It is the responsibility of the user, however, to<br>ensure that the mode correctly reflects the nature of the target program. If the THREADS mode is<br>in effect, for example, any new processes spawned by the target program will be ignored by the<br>debugger. <br>
Note that if the user attempts to debug a program with multiple threads using a processes-only<br>debugger, it will not be capable of recognizing the existence of the multiple threads, so no error<br>can be reported. <br>
<b>1.1.8 References Cited in This Chapter</b><br>
[1] Richard H. Crawford, Ronald A. Olsson, W. Wilson Ho, Christopher E. Wee, &quot;Semantic<br>Issues in the Design of Languages for Debugging,&quot; <i>Computer Languages</i>, Vol. 21, Num. 1<br>(April 1995), pp.17-37 <br>
[2] Al Geist, Adam Beguelin, Jack Dongarra, Weicheng Jiang, Robert Manchek, and Vaidy<br>Sunderam, <i>PVM3 User's Guide and Reference Manual</i>, Oak Ridge National Laboratory, Oak<br>Ridge, TN, September 1994, ORNL/TM-12187. <br>
[3] Message Passing Interface Forum, &quot;MPI: A Message Passing Interface Standard,&quot;<br><i>International Journal of Supercomputing Applications,</i> Vol. 8, Num. 3/4, 1994. <br>
<b>High-Level Overview</b><br>
<b>1.2 Effects of Parallelism on Debugger</b><br>
<b>Behavior</b><br>
Working Version 2.1 - last revised Sept. 11, 1998 <br>
<i>Comments and requests for clarification are welcome. They should be submitted to<br>hpd-comments@ptools.org.</i> <br>
<b>1.2.1 Naming Individual Processes and Threads Sets</b><br>
19<br>
<hr>
<A name=20></a>HPD Version 1<br>
As discussed in the last chapter, a parallel program consists of some number of processes, each<br>involving some number of threads. Processes fall into two categories, depending on when they<br>are created: <br>
<i><b>initial process</b></i>: a pre-existing process from the normal run-time environment (i.e., created<br>outside the debugger), or one that was created as the debugger loaded the target program <br><b><i>spawned process</b></i>: created by a process executing under the control of the debugger <br>
The debugger assigns a non-negative integer to each individual process or thread under its<br>control. This <b><i>process/thread identifier</b></i> may be created by the debugger, or the debugger may<br>use the system identifier already given to the process/thread if it is an integer that falls within the<br>proper range. (If the debugger assigns its own numbers, it must show the mapping of those<br>numbers to the operating system or run-time environment identifiers through the status<br>command.) <br>
Process numbers are unique over the lifetime of a debugging session, and thread numbers are<br>unique over the lifetime of a process. Although some implementations may attempt to assign<br>numbers sequentially to threads and processes, this behavior is not required, and users should<br>not rely on it. <br>
When the program is multilevel - that is, both multithreaded and multiprocess - an identifier<br>consists of two components. For example, if the target program has two processes, each with<br>two threads, this gives rise to a universe of four threads: <br>
thread 0 of process 0 <br>thread 1 of process 0 <br>thread 0 of process 1 <br>thread 1 of process 1 <br>
The HPD Version 1 standard uses <b><i>process/thread notation</b></i> to identify each thread uniquely.<br>Square brackets enclose the identifiers for the process and the thread, which are separated by a<br>period: <br>
<b>[</b><i>process-identifier</i><b>.</b><i>thread-identifier</i><b>]</b> <br>
For the example described above, the four threads would be denoted as follows: <br>
[0.0] - thread 0 of process 0 <br>[0.1] - thread 1 of process 0 <br>[1.0] - thread 0 of process 1 <br>[1.1] - thread 1 of process 1 <br>
To facilitate the specification of process/thread identifiers, two forms of wildcard characters are<br>provided: <br>
20<br>
<hr>
<A name=21></a>HPD Version 1<br>
<b>*</b> - indicating all identifiers in a particular position <br><b>:</b> - indicating all identifiers falling within a particular range of numbers <br>
A &quot;range&quot; is interpreted as including all identifiers greater than or equal to the lower bound, and<br>less than or equal to the upper bound. The range may or may not be fully populated. Examples<br>include: <br>
0.*      - all threads currently existing in process 0 <br>
0.*:4.*  - all threads currently existing in processes 0 through 4 <br>
1.2:1.5  - all threads from process 1 in the range 2 through 5<br>
(i.e., any of {1.2, 1.3, 1.4, 1.5} that exist) <br>
1.2:2.3  - all threads falling in the range 1.3 through 2.5 <br>
(i.e., all threads of process 1 except 1.0 and 1.1,<br>plus any of {2.0.,2.1, 2.3} that exist) <br>
As a typing convenience, HPD implementations will also accept an <b><i>alternate form of notation</b></i>,<br>where a thread (or process) position is omitted in the presence of a wildcard falling within a<br>process (thread) range, as follows: <br>
0:4.* - all threads in processes 0 through 4 (alternate notation) <br>1.3:5 - threads 3 through 5 in process 1 (alternate notation) <br>
The fully specified process+thread notation is not strictly required unless the debugger is a<br>multilevel debugger and the target program is both multithreaded and multiprocess. A<br>processes-only debugger may denote process identifiers using either the dual notation with a<br>wildcard or a single number. Thus, process 2 would be referred to as either [2] or [2.*].<br>Similarly, a threads-only debugger could denote thread 2 as [2] or [*.2]. <br>
To facilitate the porting of debugger scripts across platforms, all implementations are required to<br>accept the dual notation, at least as an optional format for user input. Processes-only debuggers<br>or threads-only debuggers will simply ignore the extraneous component (rather than flagging it<br>as an error or warning condition). For example, [1.4] will be interpreted as &quot;process 1&quot; by<br>processes-only debuggers, and &quot;thread 4&quot; by threads-only debuggers. All examples in this<br>document employ the dual notation. <br>
Similarly, multilevel debuggers conforming to the HPD Version 1 standard must support the<br>alternate notation whenever the target program itself is threads-only or processes-only. Since it<br>is not possible for the debugger to know this ahead of time, it is up to the user to indicate it by<br>setting the debugger state variable controlling debugging mode, MODE. Its default value is<br>THREADS, PROCESSES, or MULTILEVEL (depending on the type of debugger); the dual notation is<br>strictly required only for MULTILEVEL mode. When using a multilevel debugger, the user may set<br>MODE to THREADS (or PROCESSES) if his/her code is threads- (processes-) only, thereby<br>eliminating the need to use pairs of numbers in specifying threads (processes). <br>
It should be noted that some command options are meaningless when the debugger is<br>threads-only (or operating in threads-only mode). A warning message is issued if the option is<br>specified anyway. Instances of this are called out explicitly in the command descriptions. <br>
21<br>
<hr>
<A name=22></a>HPD Version 1<br>
<i>Special note: For the remainder of this document, we employ the word &quot;threads&quot; to refer to<br>&quot;processes and/or threads.&quot; In cases where a distinction needs to be drawn between the<br>circumstances associated with processes or with threads, this will be called out explicitly.</i> <br>
<b>1.2.2 Process/Thread Sets</b><br>
The concept of sets of processes/threads provides the foundation for extending the semantics of<br>serial debugger operations to a form suitable for parallel debuggers. This allows a debugger<br>command to be applied to a whole collection of processes/threads, rather than to just one<br>process or thread at a time. Process sets are the standard practice of existing parallel debuggers<br>that accommodate multiple processes (cf. Cdbx [2], codeview [11], CXdb [1], HP/DDE [5], ipd<br>[8], Ladebug [3], MPPE [9], ndb [10], P2D2 [7], pdbx [6], Prism[12], TotalView [4]). <br>
We define a <b><i>p/t (process/thread) set</b></i> to be a set of threads drawn from all threads in all processes<br>of the target program. A p/t set is denoted using <b><i>p/t set notation</b></i> that simply extends<br>process/thread notation by permitting a list of threads within the brackets. For example: <br>
[0.0,0.1,0.2]  - the first 3 threads in process 0 <br>
[0.*]          - all threads in process 0 <br>
[1.1, 2.1]     - thread 1 in processes 1 and 2 <br>
[1:2.1]        - thread 1 in processes 1 and 2 <br>
The specification of set members that are not unique will result in a warning message, but will<br>not otherwise affect debugger operations. <br>
Unlike a serial debugger, where each command clearly applies to the single thread of execution<br>control, parallel debuggers can have potentially many distinct threads of control and potentially<br>many different locations corresponding to a program symbol name (e.g., a variable). The<br>concept of the <b><i>target p/t set</b></i> is used to restrict a debugger command so that it applies to one,<br>many, or all threads of control. <br>
The target p/t set affects most debugger commands, the main exception being commands that<br>control the debugger interface itself. (The description of each command clearly indicates to what<br>extent it is affected by the target set.) Consequently, it is important that the debugger have strict<br>rules for identifying the target set. <br>
The user can explicitly specify what threads are in the target set by including a <b><i>p/t set prefix</b></i> at<br>the beginning of the command; see &quot;Command and Prompt Formats.&quot; The prefix uses standard<br>p/t set notation, just as the debugger prompt does. <br>
In the absence of an explicit p/t set prefix, the target set is implicitly defined. At any time in the<br>debugging session, there is a <b><i>current p/t set</b></i> in effect. This is shown to the user as the (default)<br>debugger prompt. By default, the current p/t set is defined to include all processes and all<br>threads that are involved in executing the target program. The user can control membership in<br>
22<br>
<hr>
<A name=23></a>HPD Version 1<br>
the current p/t set by using the focus command. <br>
As an example, the following sequence of commands shows how the default target p/t set is<br>overridden by the user (actual typing is shown in boldface): <br>
[all]&gt; <b>print x</b> <br>
command applies to all threads (target set defaults to current p/t<br>set) <br>
[all]&gt; <b>[1.*] print x</b>  command applies only to the threads in process 1 (target set<br>
specified as p/t set prefix) <br>
[all]&gt; <b>print y</b> <br>
command applies to all threads (target set defaults to current set) <br>
[all]&gt; <b>focus [0.*]</b> <br>
command changes current set to just process 0 <br>
[0.*]&gt; <b>print y</b> <br>
command applies to threads in process 0 (target set defaults to new<br>setting of current set) <br>
[0.*]&gt; <b>[1.*] print y</b>  command applies to threads in process 1 (target set specified as p/t<br>
set prefix) <br>
(A text string containing the members of the current p/t set is available for use in customizing<br>the debugger prompt; this string is stored in a debugger state variable and can be referenced<br>using the name $PTSET.) <br>
Some commands can be applied only at the process level - i.e., cannot apply to just a single<br>thread (or group of threads) in the process, but must apply to &quot;all or none.&quot; The descriptions for<br>those commands explicitly state that they make use of a <b><i>target process set</b></i>, rather than a target<br>p/t set. The target set may still be specified, explicitly or implicitly, in terms of a collection of<br>individual threads, but the command will be applied to each process represented in the set - even<br>if some of the process' threads are not included. For example, specifying a p/t set prefix of<br>[2.1] on such a command means that the command will be applied to process 2 as a whole. <br>
For other commands, a distinction is made between the target p/t set, which is the set specified<br>explicitly or implicitly as the target of the operation, and the <b><i>affected p/t set</b></i>. In these cases,<br>command-specific criteria are applied to determine whether it is or is not reasonable to apply the<br>command to an individual member of the target p/t set. The affected set consists of all processes<br>or threads from the target set for which the operation is valid. For example, the go command<br>cannot really be applied to processes that are already running, so the affected set for this<br>command consists of all processes in the target set that are not running. <br>
Note that when the target p/t set includes more than one thread, it is possible for &quot;location&quot; to<br>be ambiguous. Consider the case where the target set contains two threads that have stopped at<br>distinct locations in the code. For some commands, such as print x, it is reasonable to display<br>the current values of x in each thread, for purposes of comparison. A command to display<br>source code, however, would quickly generate large amounts of output that could not easily be<br>compared. In this case, it is more reasonable for the debugger to choose among the candidate<br>threads by applying a <b><i>thread arbitration</b></i> algorithm and display the code for just the selected<br>thread. (The algorithm is implementation-dependent; it may be as simple as choosing the<br>
23<br>
<hr>
<A name=24></a>HPD Version 1<br>
lowest-numbered thread, or may attempt to apply information from the history of recent<br>commands in order to &quot;guess&quot; which thread the user is most interested in seeing.) A warning<br>message will let the user know what has happened so that he/she can repeat the command with a<br>different target thread in order to see the other source code locations. <br>
For any command that is applied to multiple threads, there is the possibility that it will result in<br>an error for some, but not all, of the threads. Each command description specifies what the<br>debugger's response will be; typically, the command succeeds wherever it can, failing only for a<br>minimal number of threads. <br>
<b>1.2.3 Named Sets</b><br>
The debugger creates and maintains <b><i>debugger-defined sets</b></i> of threads that can be referred to by<br>name. Five such sets are required by the HPD Version 1 standard: <br>
<b>all</b>: the set of all threads currently associated with the target program (equivalent to *.*) <br><b>running</b>: all threads in the <b>running</b> state <br><b>stopped</b>: all threads in the <b>stopped</b> state (includes both <b>stopped/runnable</b> and<br><b>stopped/held</b>) <br><b>runnable</b>: all threads in the <b>stopped/runnable</b> state <br><b>held</b>: all threads in the <b>stopped/held</b> state <br><b>exec(</b><i>executable</i><b>)</b>: set of all threads associated with the named executable <br>
(See &quot;Controlling Program Execution&quot; for definitions of thread states.) <br>
The membership of debugger-defined sets changes over the course of the program. That is, the<br>members to which one of these set names refers will depend on when the command is issued.<br>The set <b>all</b> is distinguished as being the default setting for the current p/t set. <br>
Membership in the next four sets is determined on the basis of thread execution state, described<br>in the next chapter. The <b>exec</b> set is always specified in terms of a specific executable, and<br>includes all threads involved in executing it: <br>
[exec (meso3)] - all threads associated with the executable named <b>meso3</b> <br>
<b>Design Rationale</b>: exec (<i>executable</i>) describes all current and future threads executing<br>a particular executable. This feature is particularly useful with commands such as where,<br>and break, where it is often convenient to be able to view or change state information for<br>threads that are related logically because they share the same executable. It is also<br>convenient to have some debugger state controls, such as breakpoints, inherited if new<br>threads are created that use the same executable. Finally, it is often desirable to have<br>breakpoints remain in effect when an executable is re-started. If a breakpoint were defined<br>in terms of an explicit set of thread identifiers, those identifiers may have changed when the<br>program is re-started, so the breakpoint might not be in effect. On the other hand, if the<br>
24<br>
<hr>
<A name=25></a>HPD Version 1<br>
breakpoint is defined in terms of an <b>exec</b> set, it will remain in effect for any threads that run<br>the executable, regardless of the identifier number. <br>
<b>Extensions</b>: The debugger may elect to provide additional debugger-defined sets. For<br>thread-based systems, for instance, <b>running</b> might be subclassed in terms of all <b>executing</b>,<br><b>blocked</b>, and <b>ready</b> threads. As a general rule-of-thumb, there should be a<br>debugger-defined set corresponding to each process or thread state the debugger is capable<br>of recognizing. <br>
It is also possible for the user to create <b><i>user-defined sets</b></i>, through the defset command. <br>
The membership of any named set is determined at the time it is evaluated for use in a particular<br>operation. There are two distinct times for evaluation: the <i>point of definition</i> and the <i>point of<br>use</i>. The first occurs when the name of the p/t set is first defined. The point of use occurs<br>whenever the set name is referenced in an expression or as a p/t set prefix, or when the debugger<br>applies some membership test (e.g., determining what thread modified the value being monitored<br>by a watchpoint). <br>
For example, consider the situation where a user defines the p/t set <b>firstTen</b> to include all<br>processes in the range <b>[0:9.*]</b>. At the point of definition, <b>firstTen</b> would include any processes<br>between 0 and 9 that happen to exist at that time, say {0, 1, 2, 3, 4, 5}. By the time <b>firstTen</b> is<br>used as a p/t set prefix, however, some of those processes may no longer exist and new ones<br>may have come into existence. Suppose 2 and 5 have terminated and processes 6, 7, and 8 have<br>been created by the time the point of use occurs. In that case, <b>firstTen</b> would refer to the set {0,<br>1, 3, 4, 6, 7, 8}. <br>
It must be possible to distinguish between these two points of evaluation. <b><i>Dynamic sets</b></i> are<br>those that are evaluated at the point of use. By default, any named set - whether debugger- or<br>user-defined - is a dynamic set. <br>
<i><b>Static sets</b></i> differ in that they are evaluated at the point of definition. To indicate a static set, the<br>set name is preceded by an exclamation point (<b>!</b>). Following the lines of the previous example,<br>defining <b>firstTen</b> as <b>[!0:9.*]</b> would indicate that this was a static set. Any further use of<br><b>firstTen</b> would always refer to exactly the set {0, 1, 2, 3, 4, 5} - that is, the processes that<br>existed at the time the set was initially defined. <br>
The name of a debugger-defined or user-defined set always appears within brackets, and can be<br>used anywhere that normal set notation can appear: <br>
[all]&gt; <b>defset wrkrs [!2.*:25.*]</b>  - new user-defined static set is created <br>
[all]&gt; <b>[stopped] print x</b> <br>
- command applies to all threads that are currently<br>stopped <br>
[all]&gt; <b>[wrkrs] print x</b> <br>
- command applies to all threads currently in the<br>user-defined set <b>wrkrs</b> <br>
25<br>
<hr>
<A name=26></a>HPD Version 1<br>
<b>1.2.4 Handling Command Output from Multiple Threads</b><br>
If the target p/t set for a command includes very many members, there could be a potentially<br>large amount of command output. As a convenience to the user, the debugger will <b><i>aggregate<br>output</b></i> that is identical across multiple processes and/or threads. <br>
Consider, for example, the case where a user wishes to <b>print</b> the contents of an array that has<br>just been initialized and copied to all threads. Even a small number of threads would result in a<br>lengthy listing that would make it difficult to detect whether all arrays do or don't have the same<br>contents. Aggregated output provides a means of summarizing the contents of all threads which<br>have the same values. <br>
For example, if all threads have the same values for an array <b>x</b>, the output would take the form: <br>
     [all]&gt; <b>print x</b><br>
        [*.*]<br>
               0.1206  9.2542  0.0000  0.0000  0.0000<br>
               0.0000  3.6850  0.0000  2.1798  0.0000<br>
               ...<br>
If the array differed only for thread 2.2, the output will make this clear using a form such as: <br>
     [all]&gt; print x<br>
        [1.*, 2.1]<br>
               0.1206  9.2542  0.0000  0.0000  0.0000<br>
               0.0000  3.6850  0.0000  2.1798  0.0000<br>
               ...<br>
        [2.2]<br>
               0.0000  0.0000  0.0000  0.0000  0.0000<br>
               0.0000  0.0000  0.0000  0.0000  0.0000<br>
               ...<br>
The description of each command includes information about when such aggregation is required.<br>As a minimum, the aggregation algorithm must be as follows: If a command generates<br>(textually) identical output for multiple consecutive threads (apart from the process/thread<br>identification itself), the debugger must combine the output, preceding it by a line indicating the<br>range of threads to which the output applies. <br>
Threads within a process are considered consecutive when they are numbered <i>p.i</i> and <i>p.i+1</i> (or<br>when they are <i>p.i</i> and <i>p.i+n</i> and no threads in the intervening range are part of the target<br>program execution). The same rule applies to processes. In addition, the last thread in one<br>process is considered to be followed consecutively by the first thread in the &quot;next&quot; process. <br>
<b>Recommended Practice</b>: Implementors are encouraged to provide more intelligent or<br>aggressive aggregation algorithms, such as the ability to aggregate all identical output, even<br>when it spans non-consecutive threads. <br>
26<br>
<hr>
<A name=27></a>HPD Version 1<br>
<b>1.2.5 References Cited in This Chapter</b><br>
[1] Convex Computer Corporation, <i>Convex CXdb User's Guide</i>, Second Edition, October 1993,<br>DSW-473. <br>
[2] Cray Research, Inc., <i>UNICOS Symbolic Debugger Reference Manual</i>, June 1991, SR-2091<br>6.1. <br>
[3] Digital Equipment Corporation, <i>Ladebug Debugger Manual</i>, Version 4.0, March 1996,<br>AA-11 yPZ7EE-TE. <br>
[4] Dolphin Interconnect Solutions, Inc., <i>TotalView Multiprocess Debugger User's Guide</i>,<br>Version 3.7.7, September 1997. <br>
[5] Hewlett Packard Company, <i>HP/DDE Debugger User's Guide</i>, First Edition, July 1996,<br>B3476-90015. <br>
[6] IBM Corporation, <i>IBM AIX Parallel Parallel Environment: Programming Primer</i>, Version<br>2.0, June 1994, SH26-7223. <br>
[7] R. Hood, &quot;The P2D2 Project: Building a Portable Distributed Debugger,&quot; in <i>Proceedings of<br>the SIGMETRICS Symposium on Parallel and Distributed Tools</i>, Philadelphia, May 1996. <br>
[8] Intel Corporation, <i>Paragon Interactive Parallel Debugger Reference Manual</i>, October<br>1993, 312547-002. <br>
[9] MasPar Inc., <i>MasPar Programming Environment (MPPE) User Guide</i>, Version 2.1, July<br>1991, 9305-0000. <br>
[10] Parasoft Corporation, <i>nCUBE 2 Programmer's Guide</i>, Rev. 2.0, December 1990, 102294. <br>
[11] Silicon Graphics, Inc. <i>CASEVision/Workshop User's Guide</i>, Volumes I and II, April 1992,<br>007-1523-020 and 007-1524-020. <br>
[12] Thinking Machines Corporation, <i>Prism User's Guide</i>, Version 1.2, March 1993. <br>
<b>High-Level Overview</b><br>
<b>1.3 Controlling Program Execution</b><br>
Working Version 2.1 - last revised Sept. 11, 1998 <br>
<i>Comments and requests for clarification are welcome. They should be submitted to<br>hpd-comments@ptools.org.</i> <br>
27<br>
<hr>
<A name=28></a><IMG src="hpd-28_1.jpg"><br>
HPD Version 1<br>
<b>1.3.1 Starting and Stopping Model</b><br>
Execution control is relatively simple in a serial debugging environment. The target program is<br>either stopped or running. A <b><i>program event</b></i> is an occurrence that is being monitored by the<br>debugger, such as a breakpoint. When the program is running and its operations cause an event<br>to occur (e.g., arriving at a breakpoint), this is said to <b><i>trigger</b></i> the program event and the<br>program is stopped. The user can later continue execution, effectively undoing the effect of<br>triggering the breakpoint and causing the program to run once again. Parallel program execution<br>is more complex, however, since each thread has an individual execution state. When a thread<br>(or set of threads) triggers a breakpoint, a question arises as to what, if anything, should be done<br>about the other threads and processes. <br>
The model employed by many familiar debuggers that support <i>multithreaded</i> target programs<br>(e.g., gdb [1] or dbx [2]) is referred to as &quot;stop-the-world&quot;. That is, the debugger automatically<br>stops all threads of execution whenever <i>any</i> thread triggers a breakpoint. This has the advantage<br>of providing a target program that is &quot;quiescent&quot; while the user examines program state.<br>However, it has the disadvantage of being intrusive. <br>
It is also possible to simply leave other threads of execution unaffected when one (or more)<br>triggers the breakpoint. This is the model adopted by most <i>multiprocess</i> parallel debuggers. For<br>example, in a client-server application, it is more natural when a client triggers breakpoint that<br>the server <i>not</i> be stopped as well. <br>
HPDF has adopted a split model: stop-the-world for threads and leave-others-alone for<br>processes. That is, any processes that have not triggered a breakpoint will be unaffected, but all<br>threads in each process that has done so will be stopped together. This approach provides a<br>common denominator that can be implemented on all HPC systems. The alternative - to stop<br>only the individual threads that triggered a breakpoint - is specified as an extension to the HPD<br>Version 1.0 standard; syntax and semantics are defined for any implementations that wish to<br>implement the extension. The figure summarizes this concept. <br>
28<br>
<hr>
<A name=29></a><IMG src="hpd-29_1.jpg"><br>
HPD Version 1<br>
There is also a starting model, which applies to the so-called <b><i>resume commands</b></i> (i.e. go, step,<br>cont, wait), which re-start execution after one or more threads have stopped. The default<br>(required) model is the mirror image of the stopping model; a resume command un-does the<br>effect of triggering a breakpoint. Thus, the default target set of an execution command is all<br>threads associated with any processes in the current process/thread set (which by default will be<br>equal to those which just triggered). The ability to start just individual threads within a process is<br>defined as an extension. This starting model is reflected in the figure below. <br>
29<br>
<hr>
<A name=30></a><IMG src="hpd-30_1.jpg"><br>
HPD Version 1<br>
<b>1.3.2 Advancing Program Execution</b><br>
As described in Chapter 1.1.2, debugging must begin with one or more load or attach<br>operations, or with a core operation. If load is used, it must be followed by a run operation<br>before execution will actually begin. These four commands can be applied only at the level of<br>entire processes, not to individual threads. (The same restriction is true of the detach and kill<br>commands.) If core-file debugging is in effect, no commands that affect program state can be<br>issued, so the remainder of this section does not apply. <br>
To advance program execution, the user issues a command that will cause one or more threads<br>to execute instructions. As noted in the last section, such commands are referred to generically<br>as resume operations. <br>
Like other commands, resume operations are applied to a target p/t set, making it possible to<br>advance certain processes (and if the extensions are implemented, individual threads) while<br>others are held back. It is also possible to advance program execution by increments, <b><i>stepping<br></b></i>the target program forward. The user can define the size of the increment and whether<br>embedded procedure invocations (function and subroutine calls) should be counted in<br>determining how far to proceed. <br>
As it executes, the target program goes through a series of program states. We can think of<br>execution control as a way for the user to request that the debugger allow the target program to<br>advance, stopping at some future program state(s). Although the term &quot;stop&quot; is intuitive, what<br>we really mean is &quot;hold one or more threads at a fixed execution location until the user instructs<br>the debugger to resume their execution.&quot; <br>
In fact, the state of the target program is a composite state, reflecting the <b><i>execution states</b></i> of all<br>the individual threads involved in its execution. The diagrams below show the various states<br>recognized by HPD Version 1, and the commands permitted for threads in each state. Note that<br>some operations have different effects, depending on whether the thread corresponds to an<br>initial process or a spawned process. <br>
30<br>
<hr>
<A name=31></a><IMG src="hpd-31_1.jpg"><br>
HPD Version 1<br>
<i>HPD process states -- initial processes</i><br>
<i>HPD process states -- spawned processes</i><br>
The following table summarizes the effects of thread state on the availability (i.e., legality) of<br>HPD commands. Entries marked &quot;perhaps&quot; indicate that the command is sometimes, but not<br>always, permitted for threads in that state. If &quot;no&quot; appears, the command cannot be applied to<br>threads in that state. For details, see the description of each command. <br>
<i>Operations that may be applied only to threads in particular states</i> <br>
<i>Command </i><br>
<i>Process State </i><br>
<i>Core-file </i><br>
  <br>
<i>Ready  Running Stopped/Runnable  Stopped/Held  Debugging </i><br>
go/cont/wait/step <br>
no <br>
no <br>
  <br>
  <br>
no <br>
run <br>
  <br>
no <br>
  <br>
  <br>
no <br>
halt <br>
no <br>
  <br>
no <br>
no <br>
no <br>
up/down/where <br>
no <br>
no <br>
  <br>
  <br>
  <br>
assign <br>
perhaps no <br>
  <br>
  <br>
no <br>
print <br>
perhaps no <br>
  <br>
  <br>
  <br>
break/barrier/watch <br>
  <br>
no <br>
  <br>
  <br>
no <br>
enable/disable/delete    <br>
no <br>
  <br>
  <br>
no <br>
actions/save <br>
  <br>
  <br>
  <br>
  <br>
no <br>
all other commands <br>
  <br>
  <br>
  <br>
  <br>
  <br>
Once a program has been loaded, each thread that is actively executing it moves among three<br>execution states: &quot;running,&quot; &quot;stopped/runnable&quot;, or &quot;stopped/held.&quot; <br>
The <b><i>running state</b></i> is defined from the perspective of the debugger; that is, an execution<br>command such as go has been issued, the debugger has passed the appropriate request to the<br>underlying run-time system, and no subsequent program event has triggered. From the<br>debugger's point of view, such a thread is &quot;running,&quot; and debugger commands that attempt to<br>examine that thread's variables, etc., will not be possible. (From the perspective of the<br>
31<br>
<hr>
<A name=32></a>HPD Version 1<br>
underlying run-time environment, such a thread may make many transitions between being ready<br>to run and actually running, but typically these lower-level transitions are invisible to the<br>debugger and the debugger user.) <br>
A thread enters the <b><i>stopped/runnable state</b></i> under several circumstances: <br>
when the executable is first loaded or the debugger first attaches to an existing process <br>when the user explicitly asks the debugger to stop the thread <br>when the thread's execution triggers a program event <br>when some other thread's execution triggers a program event that affects this thread <br>
Once the thread has stopped, debugger commands to examine or change the state of the thread<br>become available. In addition, the thread becomes eligible as a target for a resume command,<br>which causes it to resume execution. Note that in threads-only debuggers and multilevel<br>debuggers that do not choose to implement the extensions for controlling threads individually,<br>all threads within a given process will be stopped when any one of them triggers an event, and<br>all will be returned to the <b>running</b> state when execution is resumed. <br>
The <b><i>stopped/held state</b></i> is similar, except that a thread in this state will not respond to resume<br>commands. A thread typically enters this state as a result of triggering a barrier. The thread's<br>state must first be changed to stopped/runnable (when the barrier has been satisfied or by<br>explicit user command) before it is eligible for resuming. <br>
Since almost all the commands that may be applied to a <b>stopped/runnable</b> thread may also be<br>applied to a <b>stopped/held</b> thread, we simplify the remaining sections of this document by<br>defining a super-state, the <b><i>stopped state</b></i>, that encompasses both those states. <br>
<i>Note that the precise name (&quot;stopped/held&quot; or &quot;stopped/runnable&quot;) appears only where it is<br>important to distinguish between the two.</i> <br>
<b>1.3.3 Actionpoints</b><br>
By defining <b><i>actionpoints</b></i>, the user may request in advance that target program execution stop<br>under certain conditions. Three types of actionpoints are supported in HPD Version 1. Each<br>allows the user to indicate that execution should pause when some specific type of program<br>event occurs. <br>
A <b><i>breakpoint</b></i> specifies that execution should stop whenever it reaches a given location relative<br>to the source code. A <b><i>watchpoint</b></i> provides analogous control on the basis of data storage,<br>stopping whenever the value of a variable is updated. A <b><i>barrier</b></i>, as its name suggests, effectively<br>prevents processes from proceeding forward beyond a certain point in the source code until<br>other processes have also arrived, providing a mechanism for synchronizing the activities of<br>processes. (Note that barriers can only be applied to entire processes, not to individual threads.) <br>
32<br>
<hr>
<A name=33></a>HPD Version 1<br>
Some actionpoints distinguish between two types of affected set. The <b><i>trigger set</b></i> is the set of<br>threads for which the actionpoint has been defined. There is also a <b><i>stop set</b></i>, establishing which<br>threads should be halted as a result of the actionpoint. When any member of the trigger set<br>causes the program event to trigger, the debugger intervenes, issues some type of deferred<br>output to indicate that the event has occurred, and stops all members of the stop set as well as<br>the triggering thread. The current execution location of the triggering thread becomes available<br>for the user to examine; its lines in the source code can be examined by specifying the debugger<br>state value $EXEC on the list command. <br>
Each actionpoint is associated with an <b><i>actionpoint identifier</b></i>, with which the user may reference<br>it on commands. Like process and thread identifiers, actionpoint identifiers are assigned numbers<br>as they are created. A single pool of identifiers (starting at zero) is shared by all types of<br>actionpoints, and identifiers are not re-used within a single debugging session. <br>
<b>1.3.4 References Cited in This Chapter</b><br>
[1] Richard Stallman and Cygnus Support, <i>Debugging with GDB</i>, Cygnus Solutions, Inc., 1994.<br>
[2] SunSoft, Inc., <i>Solaris Application Developer's Guide</i>, 1997, ISBN 0-13-205097-8. <br>
<b>High-Level Overview</b><br>
<b>1.4 Machine State, Program State, and</b><br>
<b>Debugger State</b><br>
Working Version 2.1 - last revised Sept. 10, 1998 <br>
<i>Comments and requests for clarification are welcome. They should be submitted to<br>hpd-comments@ptools.org.</i> <br>
<b>1.4.1 State Model: Machine State and Program State</b><br>
A central concept of debugging is that the target program has <i>state</i>, which can be characterized<br>by a set of state information. Program execution causes a series of orderly transitions from one<br>program state to another. <br>
The state of a serial program, which involves only one process with only one thread of control,<br>is typically characterized in terms of the contents of its memory, registers, and stack. For parallel<br>programs, a hierarchical state structure is needed. Every parallel program involves a collection<br>of one or more processes (at least one is an initial process), each occupying a distinct memory<br>address space. Every process has one or more threads, each with its own register set and its own<br>
33<br>
<hr>
<A name=34></a>HPD Version 1<br>
stack. <br>
Collectively, the state information about all the processes and threads of a parallel program is<br>referred to as <b><i>machine state</b></i>. Machine state is expressed in machine-level terms such as<br>addresses and registers, and includes the following for each process and thread: <br>
  process<br>
    memory<br>
    thread<br>
      register-set<br>
      stack-contents<br>
      execution-state<br>
    thread<br>
      register-set<br>
      stack-contents<br>
      execution-state<br>
    ...<br>
  process<br>
  ...<br>
The machine state includes a <b><i>stack pointer</b></i>, from which the debugger can infer the <b><i>current<br>frame</b></i> and a series of other stack <b><i>frames</b></i> (memory locations indicating the routine currently<br>executing, the routine that invoked that one, and so on). <br>
A debugger has the ability to examine machine state, make modifications to it - e.g., changing<br>the contents of a memory location or register - and infer relationships. (Recall that a thread that<br>is in the <b>running</b> state is changing the contents of its registers and perhaps memory locations.<br>Therefore, debugger commands that attempt to access a thread's machine state are not allowed<br>until the thread has paused its execution.) <br>
Rather than assisting the user to access machine state directly, HPD Version 1 standard provides<br>a higher-level interface, to the program state. <b><i>Program state</b></i> is an interpretation of machine state<br>in terms of the high-level language of the source code. Specifically, code addresses are related<br>back to source program statements, data addresses are related back to source program variables,<br>and the contents of stack addresses are expressed in terms of a call <b><i>stack</b></i>, reflecting the source<br>program's invocation of functions and subroutines. The depth of the call stack changes every<br>time a procedure is entered (depth increases) or exited (depth decreases). <br>
Debugger commands allow the user to examine program state in a variety of ways, including: <br>
to determine what processes are involved in the target program <br>to determine what threads are associated with each process <br>to determine what the current execution state of each thread is <br>to determine the current source-level location (file and line number) of any thread that is<br>stopped <br>to view the call stack of a thread to determine how that location was reached <br>to view the values of source variables <br>
Data display is a special case of examining program state, where what the user examines are data<br>
34<br>
<hr>
<A name=35></a>HPD Version 1<br>
values. As a simple example, if <b>x</b> is a variable in the user's program, <b>print x</b> is a request to<br>examine the &quot;value of x&quot; program state. This state is obtained by reading the machine state -<br>either memory or register - that represents x's value. <br>
When the target program executes, it goes through a series of program states. If we assume a<br>deterministic target program - as is the case with any serial program - it is possible to require<br>that, as the debugger starts and stops program execution, it does not change the sequence of<br>program states that would have occurred if the program were executing on its own from the<br>command line. In a parallel program, however, the debugger's intervention may change the<br>timing interrelationships among threads and/or processes; this in turn may change the overall<br>behavior of the target program. Although this is not the intent of the debugger, it can not be<br>guaranteed that it will not happen. <br>
Program state has a complicated structure and provides information that can be used in many<br>different ways by the debugger. One way in which the debugger uses the program state is to<br>determine its current dynamic context(s). In general, &quot;context&quot; means &quot;where you are&quot; - that is,<br>information that is derived from the current program state. Specifically, a <b>dynamic context</b> is a<br>tuple with the components: <br>
(process, thread, frame, active-line)<br>
Each thread has its own dynamic context, which may or may not be the same as that of other<br>threads. The process and thread components uniquely identify the thread. The frame and line<br>components indicate where the location is with respect to the thread's call stack. A frame<br>number of zero indicates the most recent - i.e., currently executing - procedure in the call stack.<br>Frame 1 refers to the procedure that invoked the current one, and the line number associated<br>with that frame is the source line from which the current procedure was invoked. The frame<br>number increases at every level farther back in the call stack. <br>
Debugger commands permit the user to change the current dynamic context(s) by altering one of<br>the components. For example, up and down change the frame number, making it possible to<br>move up (backward) and down in the call stack. <br>
The dynamic context(s) establishes how an expression's variables should be identified and<br>evaluated for each thread. The four components provide a stack and register/memory context<br>for evaluation of the symbol names used in the expression. For instance, if <b>x</b> is a local variable in<br>a recursive routine, its value will depend on where (which frame) it is being evaluated. <br>
Note that dynamic context also establishes each thread's <b>current execution location</b>, which by<br>default tracks the flow of program control each time that thread stops. In debugger output, the<br>execution location is expressed in terms of a <b>source location</b>, relating back to the user's source<br>files: <br>
[<b>#</b>{<i>exec|lib</i>}<b>#</b>][<i>file</i><b>#</b>]<i>procedure</i><b>#</b><i>line</i><br>
Note that the file name is necessary only if there are multiple procedures having the same name;<br>
35<br>
<hr>
<A name=36></a>HPD Version 1<br>
similarly, if the file name could be ambiguous, it will be preceded by an executable name. The<br>line number refers to the relative location within the file where execution will resume (when the<br>program continues or control returns to the calling procedure). <br>
The source location, in turn, implies a current high-level language, since it refers to a unique<br>source file. The debugger uses that <b><i>current language</b></i> information to supply the evaluation rules<br>for expressions. <br>
There is also a <b><i>current list location</b></i>, which governs what source code is displayed in response to<br>a list command. There are key distinctions between the list location and the source location.<br>While each thread may have a different source location, there is only one current list location.<br>Further, while a thread's source location is updated automatically each time the thread stops<br>executing, the list location is changed only by user action - when the user issues a list, up,<br>down, or load command. <br>
<b>1.4.2 Debugger State</b><br>
While program state describes the actual state of the executing target program, <b><i>debugger state<br></b></i>refers to the information that the debugger maintains in order to interpret and respond to user<br>commands. The information in debugger state is: <br>
defined by the user directly (e.g., defining aliases) <br>modified as a result of a more general command (e.g., setting a breakpoint); <br>modified as a result of a program event (e.g., triggering a breakpoint); or <br>determined by examining program state (e.g., evaluating the current state of a thread). <br>
In any case, information in debugger state is part of the debugger's address space, rather than the<br>target program's, and can only be modified through debugger intervention. <br>
In this section, we describe the parts of debugger state that are either affected by the commands<br>and program events defined by this standard, or that are used by commands in order to establish<br>what action should take place. Elements have been subdivided into three categories,<br>corresponding to general information (relevant to the overall debugging session),<br>executable-specific information (relevant to each executable that is involved), and thread-specific<br>information. <br>
Some of the state information can be modified directly by user command. These appear in <b>bold<br></b>or <b>monospace bold</b> type; non-bolded items are not directly visible to the user. The names of<br><b><i>debugger state variables</b></i>, whose values can be changed with the set command are shown in<br>upper-case letters. They are case-sensitive, and must be typed exactly as shown. Note that HPD<br>Version 1 does not support the use of debugger state variables in expressions or any commands<br>other than set. <br>
The names of four debugger variables may be referenced by prefixing them with a dollar sign:<br>
36<br>
<hr>
<A name=37></a>HPD Version 1<br>
$PTSET, $EXECUTABLE_PATH, $SOURCE_PATH, and $EXEC. The first three are used for the set<br>command and the last for the list command. <br>
<i>Debugger State: General Information</i> <br>
<i>Category and Variables</i> <br>
<i>Default Value</i> <br>
<i>Changed via</i> <br>
<i>Debugger operation</i><br>
 <br>
 <br>
  <b>debugging mode</b><br>
implementation-<br>
<b>set MODE</b><br>
<b>  thread-start model</b><br>
dependent <br>
<b>set START_MODEL</b><br>
<b>  thread-stop model </b><br>
<b>set STOP_MODEL</b> <br>
<i>Prompt</i><br>
 <br>
 <br>
  <b>current prompt</b><br>
<b>[$PTSET]&gt; </b> <br>
<b>set PROMPT</b><br>
<b>  max display length of prompt </b><br>
<b>40</b><br>
<b>set MAX_PROMPT</b> <br>
<i>Aliases</i><br>
 <br>
 <br>
  user-defined aliases counter<br>
0<br>
 <br>
  <b>list of user-defined aliases</b><br>
empty <br>
<b>alias</b> <br>
<i>General p/t</i><br>
 <br>
 <br>
  process counter<br>
0 <br>
 <br>
  list of processes<br>
empty<br>
 <br>
  p/t set counter<br>
0 <br>
 <br>
  <b>list of p/t sets</b><br>
<b>empty </b><br>
<b>defset</b> <br>
<i>Current focus</i><br>
 <br>
 <br>
  <b>current p/t set</b> (available to user as<br>
<b>all</b><br>
<b>focus</b><br>
<b>$PTSET</b>)<br>
empty <br>
  <br>
  arbitrated scope <br><i>Display</i><br>
 <br>
 <br>
  current list location<br>
first executable line<br>
 <br>
  <b>current list length</b><br>
<b>20</b><br>
<b>set MAX_LIST</b><br>
<b>  call stack max levels </b><br>
<b>20 </b><br>
<b>set MAX_LEVELS </b><br>
<i>Target program</i><br>
 <br>
 <br>
  default source search path<br>
./<br>
 <br>
  <b>executable search path</b><br>
<b>./:$PATH</b><br>
 <b>set EXECUTABLE_PATH</b><br>
    (available;nbsp;<br>
0<br>
 <br>
as <b>$EXECUTABLE_PATH</b>)<br>
empty <br>
 <br>
  executable counter<br>  list of executable files<br><i>Command I/O</i><br>
 <br>
 <br>
  debugger input location<br>
stdin<br>
 <br>
37<br>
<hr>
<A name=38></a>HPD Version 1<br>
  <b>debugger input mode</b><br>
<b>debugger</b><br>
<b>proginput</b><br>
<b>  event handling mode</b><br>
<b>ON</b><br>
<b>set EVENT_INTERRUPT</b><br>
  <b>verbosity level</b><br>
<b>WARN</b><br>
<b>set VERBOSE<br>set ERROR_CHECKS</b><br>
<b>  error checking mode</b><br>
<b>NORMAL<br>20</b><br>
<b>set MAX_HISTORY</b><br>
<b>  max size of command history</b><br>
0<br>
 <br>
  command history count<br>
empty<br>
 <br>
  command history list<br>
0<br>
 <br>
  log file counter<br>
empty<br>
<b>log</b><br>
  list of log files<br>
empty <br>
<b>log</b><br>
  list of log states <br><i>Events</i><br>
 <br>
 <br>
  actionpoint counter<br>
0<br>
 <br>
  list of actionpoints<br>
empty<br>
 <br>
  signal counter<br>
0<br>
 <br>
  list of signals <br>
empty<br>
  <br>
The debugging mode variable defines whether the target program is treated as processes-only<br>(PROCESSES), threads-only (THREADS), or multilevel (MULTILEVEL). Threads-only or<br>process-only debuggers will initialize the variable appropriately and issue a diagnostic message if<br>the user attempts to change its value. <br>
In debuggers that have implemented the extensions that control which threads within a process<br>are stopped at breakpoints, etc., two variables control which starting/stopping models are in<br>effect. Where these extensions apply, START_MODEL and START_MODEL can be set to ALL or ANY<br>to indicate whether thread starting/stopping is handled on a per-process or per-thread basis.<br>Process-only debuggers and debuggers that do not elect to implement the extensions will<br>initialize both variables to ALL and issue a diagnostic message if the user attempts to change<br>them. <br>
The prompt variables keep track of the text of the current prompt and the maximum number of<br>characters that should be displayed; this does not include the three periods (...) that are<br>appended whenever the actual prompt string exceeds the maximum display length. The<br>occurrence of $PTSET within the command string will be replaced by the current p/t set prior to<br>displaying the prompt. <br>
Alias information stores the text for any user-defined commands in effect. <br>
A process counter and process list track the number of processes associated with the target<br>program. If any user-defined sets have been defined, their membership is also maintained. <br>
The current p/t set is used in establishing the target sets for commands. An arbitrated scope<br>variable holds the static scope currently in effect - after application of the thread arbitration<br>algorithm, if needed - and is used to evaluate the symbols appearing in expressions. <br>
Display variables store information of concern in displaying information about the source<br>program. These include the current list location, which determines which source lines should be<br>
38<br>
<hr>
<A name=39></a>HPD Version 1<br>
displayed next, the number of source lines that should be displayed at a time, and the maximum<br>number of call stack levels that should be displayed. <br>
The default source search path is used in the absence of an executable-specific source path (see<br>next table). To find the executable itself, the debugger searches the current directory, then all the<br>directories included in the executable search path. The syntax for aggregating directories to form<br>composite paths is platform-specific; in this document, examples are shown using UNIX<br>conventions. <br>
Command I/O variables store information that describe the debugger's I/O interface. The input<br>location indicates whether command input is coming from the command-line where the<br>debugger was invoked, or from some other window (a recommended feature). Debugger input<br>mode tracks whether user typing is passed to the debugger or directly to the target program.<br>The event handling mode determines whether program events are detected and reported to the<br>user as soon as possible, or deferred until the user has completed typing a command. <br>
Verbosity level controls the suppression of debugger diagnostics. For HPD Version 1, VERBOSE<br>is restricted to one of three settings: ERR (show error messages only), WARN (show warning<br>messages and normal command output), and ALL (show maximum information). Another state<br>variable, ERROR_CHECKS, controls the circumstances under which the debugger prompts for user<br>confirmation before taking a possibly irreversible action. This, too, accepts one of three settings:<br>MAX (prompt before a potentially dangerous action is taken), NORMAL (prompt only before a<br>potentially fatal action; warn otherwise), or MIN (ignore potential danger). <br>
The command history list is maintained as part of debugger state, as are the items needed to<br>control one or more log files. <br>
Finally, all currently defined actionpoints are tracked, in terms of actionpoint type (breakpoint,<br>watchpoint, or barrier), trigger set, and stop set. The actionpoint counter is used to assign<br>unique actionpoint identifiers. Similarly, the signal list retains information on all signals that may<br>potentially be detected and the corresponding actions to be taken when the signal arrives. <br>
<i>Debugger State: Executable-Specific Information</i> <br>
<i>Category and Variables</i> <br>
<i>Default Value</i>  <i>Changed via</i> <br>
<b>source search path</b><br>
<b>empty</b><br>
<b>set SOURCE_PATH</b><br>
    (available as <b>$SOURCE_PATH</b>) 0<br>
 <br>
source file counter<br>
empty<br>
 <br>
list of source files<br>
empty<br>
 <br>
I/O redirection<br>
empty <br>
  <br>
program arguments <br>
<i>Debugger State: Thread-Specific Information</i> <br>
39<br>
<hr>
<A name=40></a>HPD Version 1<br>
<i>For each process For each thread<br></i>  process logical id    thread logical id <br>  parent (or nil) <br>
  execution state <br>
  executable file <br>
  current frame <br>
  core file <br>
  current execution location<br>
  physical location       (available as <b>$EXEC</b>)<br>  execution state <br>
  signal counter<br>
  thread counter <br>
  list of signals<br>
  thread list <br>
The information associated with each executable includes the source search path, where the<br>debugger will look to find source files associated with the executable; if this variable is empty,<br>the default source search path (from the general information, shown in the previous table) will<br>be searched instead. Source files that have been located by the debugger are tracked in a list. If<br>the user provides any program arguments or I/O redirection on the run command, this<br>information will be stored as well. <br>
Additional information is maintained for each process in the target program. The process<br>identifier uniquely identifies the process. The variable storing the identifier of the parent process<br>indicates whether this is an initial process or a spawned process. Information on the executable<br>and any core-file being debugged for that process help track which operations are permitted.<br>The physical location (e.g., processor) where the process is running and its current execution<br>state track the dynamic state of the process, while a thread counter and list keep track of which<br>threads are associated with it. <br>
A final set of variables maintain data on each thread involved in the target program, including<br>the thread's identifier, its current execution state, the current frame, and current execution<br>location. The user may refer to the current execution location (for example, to specify that<br>source be shown from that point forward) by using the debugger variable <b>$EXEC</b>. If there are any<br>signals specific to the thread, that information must also be stored. <br>
In general, the information contained in debugger state is used by some commands and modified<br>by others. For instance, executing a go command will cause the execution state of the process'<br>threads to change from <b>stopped/runnable</b> to <b>running</b>. The command will also access the<br>verbosity setting to determine how much output to display upon completion of the command.<br>(Note that this is just an example; actual uses of and modifications to debugger state are<br>specified in the relevant command descriptions.) <br>
<b>High-Level Overview</b><br>
<b>1.5 Symbols, Names, and Expressions</b><br>
Working Version 2.1 - last revised Sept. 11, 1998 <br>
40<br>
<hr>
<A name=41></a>HPD Version 1<br>
<i>Comments and requests for clarification are welcome. They should be submitted to<br>hpd-comments@ptools.org.</i> <br>
<b>1.5.1 Symbol Names and Scope</b><br>
This chapter discusses the debugger's handling of <b><i>symbols</b></i>, or those names corresponding to<br>various entities within the program state, the machine state, or the debugger state. Symbols<br>corresponding to machine state (e.g., register names) and to debugger state (e.g., debugger state<br>variables) are highly implementation dependent and are of only limited relevance to HPD<br>Version 1 support. Therefore, this discussion is concerned primarily with symbols from the<br>program state. These include: <br>
files associated with the target program - source files, executables files, data files <br>procedures - functions and subroutines <br>variables <br>data types and literal constants <br>templates, exceptions, and other elements specific to particular high-level languages <br>
The rules governing the character sets from which symbol names may be formed and acceptable<br>formats for names are determined by the programming language, the file system, and the<br>operating system. <br>
The term <b><i>symbol name</b></i> describes a name known to or knowable by the debugger, which can be<br>assigned a correspondence with a file, function, variable, data type, or other entity within the<br>programming paradigm shared by the debugger and the program. (It is possible for a source<br>program to include symbols that are not known to the debugger. This is the case, for example,<br>with a local variable that has been optimized away, or other symbols that are known only to the<br>compiler such as <b>ifdef</b> or some <b>typedef</b> names. Generally speaking, these will be inaccessible<br>during debugging.) <br>
Many commands refer to one or more program objects, by using symbol names as arguments. In<br>addition, some commands take expressions as arguments, where the expression may contain<br>symbol names representing program variables. Thus, the rules for forming and interpreting<br>symbol names affect much of the debugger's functionality. <br>
The debugger learns about a program's symbols and their relationships by reading the debugging<br>information that was generated during program compilation. The information includes a<br>mapping from symbol names to descriptions of objects, providing such information as what kind<br>of symbol it is (e.g., a function), where it is located in memory once the executable has been<br>loaded, and associated features (e.g., number and data types of any function arguments). <br>
The concept of scope is central to the debugger's support for controlling program execution and<br>examining program state. A <b><i>static (symbol) scope</b></i> is a region of a program's source code that<br>has a set of symbols associated with it. Whenever the program context lies in a given scope, the<br>associated symbols may legitimately be referenced. <br>
41<br>
<hr>
<A name=42></a>HPD Version 1<br>
For many programming paradigms, each program consists of one or more static scopes that are<br>established by the syntactic structure of the source program. Typically, some scopes are nested<br>within others. Every statement in a program is associated with a particular static scope, and<br>indirectly with the other scopes containing that scope. The HPD Version 1 standard is<br>concerned only with languages in which the set of scopes and their relationships are static; that<br>is, the scope can be established definitively as the program is compiled. (While there are<br>languages for which this is not the case, they will not be considered here.) <br>
Whenever a debugger command contains a symbol name, the debugger must consult its<br>debugging information to discover what object it refers to, a process known as <b><i>symbol lookup</b></i>.<br>Symbol names are not required to be unique within a program, making the task of symbol<br>lookup both complex and context-sensitive. A symbol lookup is performed with respect to a<br>particular dynamic context, expressed in terms of a single thread of execution. Each dynamic<br>context uniquely identifies to what static scope a symbol name refers. (The converse does not<br>apply; a static scope does not necessarily identify a unique dynamic context.) <br>
The algorithm for symbol lookup is language dependent. For most languages with which we are<br>concerned, however, the general process is similar. The current symbol context determines a<br>target scope, whose associated symbols are searched to find a matching name. If the name is not<br>found, the symbols for the scope that contains the target scope are searched; this occurs<br>recursively, so the symbols for the containing scopes are searched outwardly, in order of the<br>scopes' nesting. Symbols for any scope that does not contain the original scope are not searched;<br>these symbols are <b><i>out of scope</b></i> (i.e., cannot be matched). Additional language-independent rules<br>often apply. For instance, if lookup is performed on behalf of a breakpoint command, only a<br>symbol corresponding to a procedure will be matched; for a watchpoint, only one representing a<br>variable; and so forth. <br>
It is often convenient to say that a scope &quot;contains&quot; a particular symbol. This is shorthand for<br>saying that the symbol can be found in the scope's symbol set or in the symbol set of some outer<br>scope. <br>
If a matching symbol cannot be found, the debugger generates an error message indicating that<br>no object of the specified name can be found within the current or enclosing scopes. The user<br>will need to be more explicit in order to obtain information about a program symbol that is out<br>of scope. <br>
It is also possible for a user to include a symbol as part of a command argument or expression<br>that might match more than one object in the symbol table. If there is no rule that reliably selects<br>one match over the other(s), an error occurs. The debugger will issue an error message<br>indicating all matching symbols, so that the user can be explicit about which one is desired. <br>
<b>Recommended Practice:</b> To streamline user interaction, it is desirable that a menu-like list<br>of matching symbols be presented and that the user be permitted to select an item and<br>resume the interrupted command (rather than having to re-issue the command with the<br>properly qualified symbol name). <br>
42<br>
<hr>
<A name=43></a>HPD Version 1<br>
<b>1.5.2 Explicit Qualification of Symbol Names</b><br>
While the commands up and down make it possible to change the current dynamic context - and<br>hence, the target scope to be searched - to some frame other than the one currently executing,<br>this is unnecessarily awkward if the user merely wishes to examine a symbol in some other<br>scope. Moreover, a symbolic expression may involve symbols from more than one scope at a<br>time. As a result, it is necessary for the debugger to provide a syntax for qualifying a symbol<br>name with the scope where it should be sought. (Note that the ability to explicitly qualify symbol<br>names in an expression represents an extension to the source language's expression syntax, and<br>must be done in a way that will not interfere with the language's parsing rules by creating<br>ambiguities. For languages that do permit some form of scoping operator in expressions, such as<br>C++, the debugger's scoping syntax must be distinct enough so as not to be confused with that<br>of the programming language.) <br>
Static scopes are associated with program locations, so the syntax for qualifying a symbol with a<br>scope closely resembles that for specifying a source location. The many nested scopes in a target<br>program may be thought of as forming a tree with the outermost scope as the root. At the next<br>level are executable files and dynamic libraries; further down are compilation units (source files),<br>procedures, and whatever other scoping units (e.g., blocks) are supported by the programming<br>language. Qualifying a symbol is equivalent to specifying which scope it is in, or describing the<br>path to a node in the tree. This is similar to describing the path to a file in a tree-structured file<br>system. <br>
A symbol is <b><i>fully qualified</b></i> in terms of its static scope when all levels of the tree are included: <br>
<b>#</b><i>executable-or-library</i><b>#</b><i>file.ext</i><b>#</b><i>procedure-or-line</i><b>#</b><i>symbol</i><br>
where the sharp (<b>#</b>) serves as a separator character. Note that a file name must include an<br>extension. Because programming languages typically do not provide mechanisms for naming<br>blocks, that portion of the qualifier is specified as some line number that falls within the block. <br>
Just as file names need not be qualified with a full pathname, it may be possible to qualify a<br>symbol's scope without including all levels in the tree. The components of a <b><i>partially qualified<br></b></i>symbol name are distinguished by their relative positions, format, and the presence or absence of<br>a sharp as delimiter: <br>
[<b>#</b>{<i>exec|lib</i>}<b>#</b>][<i>file</i><b>#</b>][<i>proc|line</i><b>#</b>]<i>symbol</i><br>
The components of the symbol name are interpreted as follows. <br>
If a qualified symbol begins with #, the next name component refers to an executable or<br>shared library (just as a rooted file path begins with a directory immediately within the root<br>directory). If the executable/library component is omitted, the qualified symbol does not<br>begin with #. <br>
Following the (possibly omitted) executable or shared library may appear a source file name<br>
43<br>
<hr>
<A name=44></a>HPD Version 1<br>
component. Files are distinguished from procedure names because only files are expected<br>to contain a period (recall that source file names must have an extension, such as <b>.c</b>). The<br>file name is followed by #. <br>
Following the (possibly omitted) source file name may appear a procedure name<br>component or a block component (represented by a line number from that block). The<br>procedure/block component is followed by #. <br>
Following the (possibly omitted) procedure or block comes the actual symbol name. Since<br>qualified symbols often appear in the context of an expression, it is entirely possible for the<br>final symbol name to be followed by a &quot;.&quot;, plus the name of a field from a class, union, or<br>structure. This might appear to be potentially ambiguous with the file name in a qualified<br>symbol; however that should not be so, since the <b>class.fieldname</b> construct can never be<br>followed by #, whereas a <b>filename.extension</b> must always be. <br>
These rules enforce the fact that a symbol name consisting of a simple string, such as <b>arrayx</b>,<br>refers to a variable of that name, included in the scope indicated by the current execution<br>location. Note that there is still a potential for ambiguity between, for instance, the file <b>anim.c<br></b>and the member <b>c</b> of the structure <b>anim</b>; therefore, it must be clear from the context whether a<br>file or a variable is wanted. That is, each command calls a lookup function that either matches a<br>file name or that matches a symbol name. <br>
Given this syntax, it is possible to omit any part of the scope specification that is not needed to<br>uniquely identify the symbol. Thus, <b>meso3#x</b> identifies the symbol <b>x</b> in the procedure <b>meso3</b>; we<br>know that <b>meso3</b> is not a source file because source files are required to have extension (e.g.,<br><b>meso3.f</b>). We also know that <b>meso3</b> is not an executable or a library because if it were, the<br>symbol would begin with a sharp. With the addition of an initial sharp, <b>#meso3#x</b> identifies,<br>depending on the nature of the lookup function, either procedure <b>x</b> in executable <b>meso3</b> or<br>variable <b>x</b> in the scope from that executable. <br>
Similarly, <b>#meso3#ffts#x</b> identifies variable <b>x</b> in procedure <b>ffts</b> in executable <b>meso3</b>. If <b>ffts</b> were<br>not unique within that executable, the name would be ambiguous unless we further qualified it<br>by providing a file name. Ambiguities may also occur if a file-level variable (common in C<br>programs) has the same name as variables declared within functions in that file. For instance,<br><b>ffts.c#x</b> is the normal way to refer to a file-level variable, but the name is ambiguous when there<br>are different definitions of <b>x</b> embedded in functions occurring in the same file. In this case, it will<br>be necessary to say <b>ffts.c#1#x</b> to identify the scope as that corresponding to the &quot;outer level&quot; of<br>the file (i.e., the scope containing line 1 of the file). <br>
The what command may be used to determine if an unqualified or partially qualified symbol<br>name is ambiguous. <br>
Since dynamic context uniquely identifies a static scope, it is also possible to refer to a symbol<br>using a <b><i>contextually qualified</b></i> name. In this case, the format is <br>
[<i>process-id</i><b>.</b><i>thread-id</i><b>#</b><i>frame-number</i>]<i>symbol</i><br>
44<br>
<hr>
<A name=45></a>HPD Version 1<br>
A context specified in this way is treated as absolute; that is, it takes precedence over the<br>context(s) implied by the target p/t set. For example, while the command [2.*] print y<br>displays the value of y that is currently within the context of each thread of process 2, [2.*]<br>print [1.2#5]x will display just one value, that of <b>x</b> in the context referred to by frame 5 of<br>thread 1.2. <br>
Note that it is never necessary to qualify a symbol by both scope and context, since either one<br>suffices. <br>
<b>1.5.3 Expressions</b><br>
<i><b>Expressions</b></i> are a part of the data display and manipulation functions of the debugger. In effect,<br>they identify the data to be processed. For more information on the processing itself, including<br>limitations on the scope of HPD Version 1 expressions, see the appropriate command<br>descriptions. <br>
In debuggers, expressions appear in two contexts: expressions that are evaluated to yield a result<br>value (e.g., arguments to print), and expressions representing memory locations to be changed.<br>In keeping with computer language terminology, we call these <i>RHS expressions</i> (for &quot;Right<br>Hand Side&quot;, referring to the usual form of an assignment statement) and <i>LHS expressions</i> (for<br>&quot;Left Hand Side&quot;), respectively. <br>
Some languages allow very complex expressions in one or both contexts. For example, Fortran<br>90 is famous for its array sub-language. Although implementors are <i>encouraged</i> to provide<br>support for the largest possible sub-language, it is unreasonable to <i>require</i> all implementors to<br>do so in HPD Version 1. Many of the restrictions below are intended to ease the implementation<br>task; this is particularly true for LHS expressions. <br>
Another key issue for expressions is the data types supported by the debugger. For example, C<br>allows user-defined struct datatypes. The issue becomes even more tangled for multi-language<br>programs, where data may not be portable between scopes. For example, the declarations<br>
INTEGER, POINTER :: P<br>
in Fortran 90 and<br>
int *p;<br>
in C both declare a &quot;pointer to integer&quot;, but they may not be the same data type. (C, for<br>example, could use 64-bit integers while Fortran uses 32 bits, even on the same machine.)<br>Again, HPDF <i>encourages</i> debugger implementors to support the widest possible set of types,<br>but <i>mandates</i> a much smaller set to facilitate more rapid implementation. <br>
<b>RHS Expressions</b>. An expression consists of symbols (possibly qualified), constants, and<br>operators, arranged in the syntax of the current language. An RHS expression is interpreted<br>relative to the semantics of that language to produce an object, which is the value of that<br>expression. Debugger commands then use this value for various purposes, such as displaying<br>data or modifying program state. <br>
45<br>
<hr>
<A name=46></a>HPD Version 1<br>
The debugger generally accepts and evaluates expressions in the current language (that is, the<br>language inferred from the current execution location; there are some extensions and many<br>restrictions to this, as noted below. For most high-performance languages, these expressions<br>have data types, which the debugger respects. The debugger must handle the basic data types for<br>the language(s) it supports. <br>
C <br>
char, int, float, double, unsigned, long <br>
Fortran    CHARACTER, INTEGER, REAL, DOUBLE PRECISION, COMPLEX, LOGICAL <br>
For Fortran 90 and later compilers, the debugger must support only the &quot;default kind&quot; for each<br>type and (REAL(KIND=KIND(1.0D0)), which is the kind for double precision. In addition, the<br>debugger must support structures (&quot;struct&quot; in C, &quot;derived types&quot; in Fortran), arrays, and<br>pointers. Note that the mechanisms for supporting these new types differ from language to<br>language; for example, C blurs the distinction between pointers and arrays, while Fortran keeps<br>them separate. <br>
For the most part, the debugger need only support operators that accept scalar arguments and<br>return scalar results. Most languages, including C and Fortran, provide a wide variety of<br>operators for use in expressions. Support is required for a a subset of these, as indicated in the<br>table below. <br>
In addition, four aggregate operators are required: field reference, max, min, and sum. <br>
46<br>
<hr>
<A name=47></a>HPD Version 1<br>
<b>Feature </b><br>
<b>C syntax</b><br>
<b>Fortran syntax</b><br>
<b>and applicable types </b><br>
<b>and applicable types </b><br>
Pointer dereferencing  *p<br>
P<br>
for any pointer <br>
for any pointer <br>
Array subscripting <br>
a[i]<br>
A(I)<br>
for any declared array or<br>
for any declared array <br>
pointer <br>
Array sections <br>
a[lb:ub], a[lb:ub:step]<br>
A(LB:UB), A(LB:UB:STEP)<br>
for any array with declared<br>
for any array <br>
bounds <br>
Field references <br>
x.field, p-&gt;field<br>
X%FIELD<br>
for any struct or struct* <br>
for any derived type <br>
Address of a variable <br>
&amp;x<br>
<b>LOC(X)</b><br>
for any type <br>
for any type <br>
Size of a variable or<br>
sizeof(x)<br>
<b>SIZEOF(X)</b><br>
type <br>
for any type <br>
for any type <br>
Binary arithmetic <br>
x+y, x-y, x*y, x/y, x%y<br>
X+Y, X-Y, X*Y, X/Y, MOD(X,Y),<br>
for any character or numeric<br>
X**N<br>
type;<br>
for any numeric type <br>
+ and - for pointers as well <br>
Unary arithmetic <br>
-x,+x<br>
-X,+X<br>
for any char or numeric type <br>
for any numeric type <br>
Bitwise operators <br>
x&amp;y, x|y, x^y<br>
IAND(X,Y), IOR(X,Y),<br>
for char, int, long <br>
IEOR(X,Y)<br>
for INTEGER <br>
Logical operators <br>
x&amp;&amp;y, x||y<br>
X.AND.Y, X.OR.Y<br>
for char, int, long <br>
for LOGICAL <br>
Comparisons <br>
x==y, x!=y, x&lt;y, x&lt;=y,<br>
X=Y, X/=Y, X&lt;Y, X&lt;=Y, X&gt;Y,<br>
x&gt;y, x&gt;=y<br>
X&gt;=Y<br>
for any character or numeric<br>
for CHARACTER or any numeric<br>
type;<br>
type <br>
for pointers of like type <br>
Type casting <br>
(type) x<br>
INT(X), REAL(X), DBLE(X),<br>
for char, any numeric type or<br>
CMPLX(X)<br>
pointer <br>
for any numeric type <br>
Selected array<br>
<b>max(a), min(a), sum(a)</b><br>
MAXVAL(A), MINVAL(A), SUM(A)<br>
operators <br>
for arrays of char or any<br>
for arrays of any numeric type;<br>
numeric type <br>
MAXVAL and MINVAL for arrays<br>of CHAR as well <br>
Entries in <b>boldface</b> are extensions to the base language that are needed for the debugger.<br>Parentheses may be added to control the order of evaluation. <br>
47<br>
<hr>
<A name=48></a>HPD Version 1<br>
A few Fortran-specific features are convenient, and consequently are required by HPD Version<br>1: <br>
1. Fortran expressions must permit Fortran 90 free format (i.e., no limitations on beginning<br>
and ending columns or line continuation) <br>
2. Blanks are significant in Fortran expressions <br>3. Names are not case-sensitive in Fortran expressions <br>
Note that we consider Fortran 90 to be the &quot;base language&quot; for Fortran; some of the required<br>features represent extensions to Fortran 77. Nevertheless, debuggers are not required to<br>implement array arithmetic expressions, even though Fortran allows them. <br>
<b>Extension</b>: Some operators that are possible in the base languages - notably Fortran's<br>intrinsic functions, calls to user-defined functions, and C's side-effect operators - are not<br>included in the HPD Version 1 standard. The debugger may support such expressions as an<br>extension; if it does, the syntax of the underlying language should be used. <br>
Subscript expressions (including lower bounds, upper bounds, and steps in array sections) for<br>both C and Fortran must be of integer types. <br>
In general, RHS expressions with scalar values may be used in any context where an expression<br>is allowed. RHS expressions with aggregate result types (such as array sections or structs),<br>however, may only be used in a print command. <br>
As discussed previously, the debugger evaluates an expression under the rules of the current<br>language (which is also the language the expression must be written in). In particular, the type of<br>the expression is determined by the language. Qualification of symbol names may make variables<br>defined in one language accessible in expressions from another. In this case, the symbol is<br>treated as if it were passed as an argument to a subroutine from its defining language to the<br>current language. <br>
<b>LHS Expressions</b> The first argument of an assign command - used to change the value of<br>program variables - is an LHS expression. HPD Version 1 requires that a debugger accept such<br>an expression as long as: <br>
The value resulting from the RHS expression coded as the second assign argument has a<br>scalar type in the underlying language (i.e., a primitive type of the language or a pointer). <br>The LHS expression references an assignable location and can be used on the lefthand side<br>of an assignment statement in the underlying language. <br>The LHS expression is valid in the sub-language accepted by the debugger. <br>
Of the operators defined in the next section, the ones suitable for LHS expressions are pointer<br>dereferencing, array subscripting, and field references. <br>
It is possible that the two arguments (the target of the assignment and the value to be assigned)<br>
48<br>
<hr>
<A name=49></a>HPD Version 1<br>
are of different type. In this case, the underlying language's rules for coercing types during<br>assignment will be applied. For both C and Fortran, these rules automatically convert types with<br>a smaller range (e.g., short or INTEGER) to types with a larger range (float or REAL). <br>
<b>1.5.4 Language Support</b><br>
We say that a debugger &quot;supports a language&quot; if its commands apply to programs in that<br>language. (For example, gdb supports C.) An HPD-conforming debugger that supports a<br>language must provide the following functionality: <br>
Accept source files written in that language, and executables generated from them. <br>Navigate to source locations in procedures written in that language. <br>Accept RHS expressions in the syntax of that language, evaluate them to object values<br>using the semantics of the language, and display those values. (Note that this capability may<br>be restricted by the HPD release; in particular, HPD Version 1 does not require that a<br>debugger accept all possible expressions in either C or Fortran.) <br>Accept LHS expressions in the syntax of that language, evaluate them to object references<br>using the semantics of the language, and assign to those objects. (Again, this capability may<br>be restricted by the HPD release.) <br>
The HPD Version 1 definition gives specific directions for applying that functionality in C and<br>Fortran because they are the most common HPC languages. <br>
If a debugger &quot;supports&quot; several languages, it must provide the above functionality for each<br>language. It need not support use of multiple languages in the same program, however. To do so<br>requires language interoperability, involving the following new functionality: <br>
The underlying compiler and runtime system must allow linking programs with routines<br>written in both languages. Unfortunately, the mechanisms for doing this are not yet<br>standardized. The syntax and semantics of debugger operations that rely on those<br>mechanisms will therefore vary from machine to machine. <br>The debugger must accept programs that link procedures written in both languages. <br>The debugger must interpret expressions in each language which include (qualified)<br>symbols from the other language(s). The interpretation of these debugger expressions is<br>discussed in the section on RHS Expressions. Note that these expressions, by their nature,<br>do not fully belong in either language. <br>The debugger must allow the assignment of expressions evaluated in each language to<br>references generated in the other language(s). This is necessary if the debugger's assign<br>command uses a qualified symbol on the left-hand side, as explained in the section on LHS<br>Expressions. <br>The debugger must document type conversions that it (and the underlying compilers and<br>runtime system) uses for passing data from one language to another. Recommendations for<br>standard conversions are below, but do not cover all possible cases. <br>
49<br>
<hr>
<A name=50></a>HPD Version 1<br>
In general, an HPD-conforming debugger must follow the rules of the current language. For<br>example, expressions will be written in the syntax and semantics of that language, with<br>extensions for fully qualified and partially qualified symbol names, as described previously. If a<br>qualified symbol refers to an object in another language, the debugger treats the symbol as a<br>dummy argument passed from the &quot;source&quot; (defining) language to the &quot;target&quot; (referencing)<br>language. This parameter-passing rule implies that any type conversion that would normally be<br>done by the compiler when one language calls the other will be replicated in the debugger. On<br>most machines, the following types in C and Fortran are equivalent: <br>
<b>C </b><br>
<b>Fortran </b><br>
char <br>
CHARACTER <br>
int <br>
INTEGER <br>
float <br>
REAL <br>
double <br>
DOUBLE PRECISION or<br>
REAL(KIND=KIND(1.0D0))<br> Fortran 90 and later <br>
&lt;<i>type</i>&gt; a[n];      &lt;<i>type</i>&gt; a(n) <br>
struct t<br>
TYPE(t)<br>
{&lt;<i>type1</i>&gt; a;<br>
&lt;<i>type1</i>&gt; a<br>
&lt;<i>type2</i>&gt; b;} <br>
&lt;<i>type2</i>&gt; b<br>
END TYPE<br> Fortran 90 and later <br>
The last two entries describe how new types are constructed from existing ones; the procedure<br>can be applied (recursively) to any <b>type1</b> and <b>type2</b>. Note that we do not define equivalences<br>between pointer types, nor between multidimensional arrays. <br>
A particular debugger may add more equivalences. For instance, there might be an equivalence<br>to provide C access to Fortran's COMPLEX variables. Similarly, a debugger may elect to<br>support type equivalences that are different from the ones shown here (perhaps because C and<br>Fortran use different precisions for floating-point values). In either case, the debugger must<br>document the specific type conversions used. <br>
<b>High-Level Overview</b><br>
<b>1.6 Terminology and Notational Conventions</b><br>
Working Version 2.1 - last revised Sept. 22, 1998 <br>
<i>Comments and requests for clarification are welcome. They should be submitted to<br>hpd-comments@ptools.org.</i> <br>
<b>Incomplete Work</b>: Not all terms have been defined yet. However, all are linked to the defining<br>
50<br>
<hr>
<A name=51></a>HPD Version 1<br>
occurrences in Part 1. <br>
<b>1.6.1 Definitions of Key Terms</b><br>
The following terms are used in defining the behavior of standard-conforming debuggers. Terms<br>are presented in logical order; for an alphabetical listing, see the index. Each term is hyper-linked<br>to the chapter where it is discussed in detail. <br>
<b>Debugger Basics</b><br>
<i>target program:</i> The executing program that is the target of debugger operations. <br><i>parallel program:</i> A program whose execution involves multiple threads and/or processes. <br><i>source file:</i> Program file containing source language statements. HPD Version 1 targets<br>Fortran90, C, and C++, but the standard does not require that all source language expressions<br>be recognized by the debugger. <br><i>executable:</i> Compiled and linked version of source file(s), containing a &quot;main&quot; entry point. <br><i>shared library:</i> Compiled and linked set of source files that are dynamically loaded by other<br>executables - and have no &quot;main&quot; entry point. <br><i>process:</i> An executable that has been loaded into memory and is running (or capable of<br>running). <br><i>thread:</i> A thread of execution control and the associated values for program counter, register<br>contents, and stack contents. <br><i>SPMD (Single Program Multiple Data) programs:</i> Program involving just one executable,<br>executed by multiple threads and/or processes. <br><i>MPMD (Multiple Program Multiple Data) programs:</i> Program involving multiple executables,<br>executed by multiple threads and/or processes. <br>
<b>Debugger Invocation</b><br>
<i>threads-only debuggers:</i> Debugger capable of debugging just one process, which may contain<br>many threads. <br><i>processes-only debuggers:</i> Debugger capable of debugging multiple processes, each of which<br>may contain just one thread. <br><i>multilevel debuggers:</i> Debugger capable of debugging multiple processes, each containing<br>multiple threads. <br><i>debugging information:</i> Information relating an executable to the source code from which it was<br>generated. <br><i>core file:</i> Memory &quot;image&quot; of the running program, captured and stored when a program<br>terminates abnormally. <br><i>core-file debugging:</i> Debugging session that examines a core file image. Commands that modify<br>program state are not permitted in this mode of debugging. <br><i>input mode:</i> Debugger mode determining whether typed input is destined for the debugger or<br>for the target program. <br><i>user interrupt key:</i> Keystroke used to interrupt commands, most commonly defined as <b>^C<br></b>(Control-C). <br><i>debugger prompt:</i> String printed by the debugger to indicate that it is ready to receive another<br>
51<br>
<hr>
<A name=52></a>HPD Version 1<br>
user command. <br><i>unambiguous command prefix:</i> String of initial letters from a command; its length must be<br>sufficient that it forms a prefix of exactly one command. <br><i>simple command:</i> Command consisting of a verb, possibly an object, and optional options,<br>terminated by a newline character. This is the normal form of commands in HPD Version 1. <br><i>user-defined command:</i> A user-selected name that provides a shortcut or easily-remembered<br>way to reference and HPD command. <br><i>compound command:</i> A series of simple commands strung together, separated by semicolons<br>and terminated by a newline character. In HPD Version 1, these are permitted only on alias<br>commands <br><i>verbose output:</i> Debugger mode when the state variable VERBOSE is set to ALL. This causes the<br>debugger to generate fuller output concerning the target program and debugger operations. <br><i>deferred output:</i> Output that is not generated when a command is first processed, but when<br>some associated event occurs later in execution. <br><i>event handling mode:</i> Debugger mode controlling when events are detected and reported to the<br>user. By default, the occurrence of an even interrupts any ongoing user input. <br><i>debugger initialization file:</i> Optional file establishing initial settings for debugger state variables,<br>user-defined commands, and any commands that should be executed whenever the debugger is<br>invoked. Must be called <b>.hpdinit</b>. <br><i>command history list:</i> Debugger-maintained list storing copies of the most recent commands<br>issued by the user. <br><i>debugging mode:</i> Debugger mode establishing whether threads-only, processes-only, or<br>multilevel debugging is in effect. <br>
<b>Processes and Threads</b><br>
<i>initial process:</i> Process created as part of a load operation, or that already existed in the<br>runtime environment and was attached by the debugger. <br><i>spawned process:</i> Process created by a user process executing under debugger control. <br><i>process/thread identifier:</i> Unique integer ID associated with a particular thread. <br><i>process/thread notation:</i> Syntax used in HPD to refer to threads, with the IDs for the process<br>and the thread separated by a period and enclosed in square brackets. <br><i>alternate notation:</i> Alternate syntax accepted by HPD debuggers, permitting the user to specify<br>wildcards to convey a range of processes and/or threads. <br><i>p/t (process/thread) set:</i> Set of threads drawn from all threads in all processes of the target<br>program. <br><i>p/t set notation:</i> Syntax used in HPD to refer to a p/t set, consisting of a comma-delimited list of<br>threads enclosed in square brackets. <br><i>target p/t set:</i> HPD convention for restricting a debugger command to apply to just a particular<br>set of threads. <br><i>p/t set prefix:</i> Optional use of p/t set notation at the beginning of a command, in order to<br>establish the command's target p/t set. <br><i>current p/t set:</i> Used to establish the default target p/t set for cases where no p/t set prefix is<br>specified. This begins as <b>all</b>, and may be changed using the focus command. <br><i>target process set:</i> Target set for those occasions when operations may only be applied to entire<br>processes, not to individual threads within a process. <br>
52<br>
<hr>
<A name=53></a>HPD Version 1<br>
<i>affected p/t set:</i> Set of threads that will be affected by the command. For most commands, this is<br>identical to the target p/t set, but in some cases it may include additional threads. <br><i>thread arbitration:</i> Algorithm that selects among candidate threads when a location is<br>ambiguous because two or more threads are stopped at different points in the program. <br><i>debugger-defined set:</i> Pre-defined sets of threads that can be referred to by name. <br><i>user-defined set:</i> User-created set of threads that can be referred to by name. <br><i>dynamic set:</i> Set that is evaluated at the point of use. By default, all named sets are dynamic. <br><i>static set:</i> Set that is evaluated only once, at the time it is defined. Differentiated from dynamic<br>sets by the inclusion of an exclamation point just after the opening bracket. <br><i>aggregated output:</i> HPD requirement that the debugger compress output from multiple threads<br>when they would be identical except for the p/t identifier. <br>
<b>Program Execution and Events</b><br>
<i>program event:</i> Program occurrence that is being monitored by the debugger, such as a<br>breakpoint. <br><i>triggers:</i> Effect during execution when program operations cause an event to occur (e.g.,<br>arriving at a breakpoint), <br><i>thread execution state:</i> Convention of describing the operations available for a thread, and the<br>effects of the operation, in terms of a set of pre-defined states. <br><i>running state:</i> State of a thread when it is executing, or at least when the debugger has passed a<br>request to the underlying run-time system that the thread be allowed to execute. <br><i>stopped state:</i> State of a thread that is no longer executing, but will eventually execute again.<br>Subdivided into stopped/runnable and stopped/held. <br><i>resume commands:</i> Commands that cause execution to re-start from a stopped state: step, go,<br>cont, wait. <br><i>stopped/runnable state:</i> State of a thread whose execution has been paused (e.g., when a<br>breakpoint triggered or due to some user command) but can continue executing as soon as a<br>resume command is issued. <br><i>stopped/held state:</i> State of a thread whose execution has paused in such a way that another<br>program event (e.g., arrival of other threads at the same barrier) will be required before it is<br>capable of continuing execution. <br><i>stepping:</i> Advancing program execution by fixed increments, such as by source code statements.<br><i>actionpoint:</i> Debugger feature that allows user to request in advance that program execution<br>stop under certain conditions. In HPD Version 1.0, actionpoints include breakpoints,<br>watchpoints, and barriers. <br><i>breakpoint:</i> Actionpoint specifying that execution should stop whenever it reaches a particular<br>location in the source code. <br><i>watchpoint:</i> Actionpoint specifying that execution should stop whenever the value of a<br>particular variable is updated. <br><i>barrier:</i> Actionpoint specifying that processes reaching a particular location in the source code<br>should stop and wait for other processes to catch up. <br><i>trigger set:</i> Set of threads that may trigger an actionpoint (i.e., for which the actionpoint has<br>been defined). <br><i>stop set:</i> Set of threads that should be stopped once an actionpoint has been triggered. <br><i>actionpoint identifier:</i> Unique integer ID associated with an actionpoint. <br>
53<br>
<hr>
<A name=54></a>HPD Version 1<br>
<b>Machine and Debugger States </b><br>
<i>machine state:</i> Convention for describing the changes in memory, registers, and other machine<br>elements as execution proceeds. <br><i>stack pointer:</i> Pointer to the area of memory where subprocedure arguments, return addresses,<br>and similar information is stored. <br><i>frame:</i> Area in stack memory containing the information corresponding to a single invocation of<br>a subprocedure. <br><i>current frame:</i> Current portion of stack memory, in the sense that it contains information about<br>the subprocedure invocation that is currently executing. <br><i>program state:</i> Higher-level view of machine state, where addresses, instructions, registers, etc.<br>are interpreted in terms of source program variables and statements. <br><i>call stack:</i> Higher-level view of stack memory, interpreted in terms of source program variables<br>and locations. <br><i>dynamic context:</i> Syntax used by HPD debuggers to refer to a program location or variable in<br>terms of the process, thread, frame, and active line. <br><i>current execution location:</i> For a given thread, its position in terms of the values stored in the<br>current frame. This is a representation of dynamic location. If a subprocedure is invoked more<br>than once by a thread, its execution location upon reaching the third source code statement will<br>be different, depending on which invocation is active. <br><i>source location:</i> For a given thread, the source code line it will execute next. This is a static<br>location, indicating file and line number, but not which invocation of the subprocedure is<br>involved. <br><i>current language:</i> The source code language used by the file containing the current source<br>location. <br><i>current list location:</i> Location governing what source code will be displayed in response to a<br>list command. <br><i>debugger state:</i> Information the debugger maintains in order to interpret and respond to user<br>commands. Includes debugger modes, user-defined commands, and debugger variables. <br><i>debugger state variables:</i> Those variables maintained in debugger state whose values can be<br>changed by the user. <br>
<b>Symbols and Expressions</b><br>
<i>symbol:</i> Entities within program state, machine state, or debugger state. <br><i>symbol name:</i> Name associated with a symbol known to the debugger (e.g., function, variable,<br>data type, etc.). <br><i>static (symbol) scope:</i> A region of a program's source code that has a set of symbols associated<br>with it. A scope may be nested inside another, recursively. <br><i>symbol lookup:</i> Process whereby the debugger consults its debugging information to discover<br>what entity a symbol name refers to. Search starts with a particular static scope and occurs<br>recursively, so that containing scopes are searched in an outward progression. <br><i>out of scope:</i> When symbol lookup is performed for a particular symbol name and it is not found<br>in the current scope or any containing scopes, the symbol is said to be out of scope. <br><i>fully qualified (symbol):</i> A symbol is fully qualified when each levels of source code<br>
54<br>
<hr>
<A name=55></a>HPD Version 1<br>
organization is included. For variables, those levels are: executable or library, file, procedure or<br>line number, and variable name. <br><i>partially qualified (symbol):</i> A symbol name that includes only some of the levels of source<br>code organization (e.g., filename and procedure, but not executable). This is permitted as long<br>as the resulting name can be associated unambiguously with a single entity. <br><i>contextually qualified (symbol):</i> A symbol that is described in terms of its dynamic context,<br>rather than its static scope. This includes process identifier, thread identifier, frame number, and<br>variable or subprocedure name. <br><i>expression:</i> An expression consists of symbols (possibly qualified), constants, and operators,<br>arranged in the syntax of the current source language. Not all Fortran90, C, and C++ operators<br>are required by HPD Version 1. <br><i>RHS expression:</i> An expression suitable for inclusion on the right-hand side of an assignment<br>statement in the corresponding source language. In other words, an expression that evaluates to<br>a value or collection of values. <br><i>LHS expression:</i> A symbol name or expression suitable for use on the left-hand side of an<br>assignment statement in the corresponding source language. That is, the expression must be<br>appropriate as the target of an assignment. <br>
<b>1.6.2 Notational Conventions</b><br>
This document uses the following notational conventions. <br>
55<br>
<hr>
<A name=56></a>HPD Version 1<br>
<i>Typeface or Symbol  Where Used </i><br>
<i>Meaning </i><br>
<i><b>boldface italics</b></i> <br>
Text <br>
Indicates the location where a key term is defined<br>
(Part 1 only) <br>
in the text; references to the term will link back to<br>this location <br>
<b>monospace bold</b> <br>
Syntax definitions  Identifies command names, option names, and<br>(Part 2 only) <br>
other reserved words that must be typed exactly<br>as shown <br>
<b>monospace bold</b> <br>
Examples <br>
Demonstrates the appearance of user input for<br>
(Part 2 only) <br>
some typical debugging setting <br>
<i>monospace</i><br>
Syntax definitions  Identifies variables, filenames, user names, etc.,<br>
<i>italics</i> <br>
(Part 2 only) <br>
that will be filled in using some appropriate word<br>or number <br>
monospace <br>
Examples <br>
Demonstrates the appearance of debugger output<br>
(Part 2 only) <br>
for some typical debugging setting <br>
<b>[ ]</b> (boldface<br>
Syntax definitions  Delimiters that must be typed as brackets <br>
brackets) <br>
(Part 2 only) <br>
[ ] (brackets) <br>
Syntax definitions  Surround optional items; if multiple options occur<br>(Part 2 only) <br>
on a single command, they may be typed in any<br>order <br>
| (vertical bar) <br>
Syntax definitions  Separates two or more items from which exactly<br>(Part 2 only) <br>
one must be selected <br>
{ } (braces) <br>
Syntax definitions  Surround two or more items from which exactly<br>(Part 2 only) <br>
one must be selected (when they aren't already<br>surrounded by brackets) <br>
For example, the following syntax specification: <br>
barrier {<i>procedure</i> | <i>line</i> | #<i>file</i>#<i>line</i>} [-stop <i>stop-set</i>] <br>
indicates that one argument is required and the second is optional. The first argument must be<br>one of three types - procedure name, line number, or file and line number delimited by sharp<br>signs. If the second argument is present, it must include a hyphen and the keyword stop,<br>followed (after a blank space) by a set specifier. <br>
Thus, any of the following commands are (syntactically) valid: <br>
      barrier inv_ffts<br>
      barrier inv_ffts -stop [1.*]<br>
      barrier 210<br>
      barrier #gaussian.c#210 -stop [all]<br>
56<br>
<hr>
<A name=57></a>HPD Version 1<br>
<b>Part 2:</b><br>
<b>HPD Version 1 Command Descriptions</b><br>
Working Version 2.1 - last revised Sept. 10, 1998 <br>
<i>Comments and requests for clarification are welcome. They should be submitted to<br>hpd-comments@ptools.org.</i> <br>
Part 2 of this document provides detailed descriptions of the commands included in the HPD<br>Version 1 standard. Where the descriptions rely on terms from the conceptual model, they are<br>linked to appropriate sections in Part 1. Concise definitions will be found in the terminology<br>chapter. <br>
The first chapter describes the commands associated with the general debugger interface; that is,<br>commands that affect the debugging environment but do not directly affect execution of the<br>target program. A chapter outlining the commands available for defining process/thread sets is<br>next, followed by a discussion of operations used to initialize and terminate processes or the<br>debugging session itself. A fourth chapter defines the commands for viewing information on the<br>program's source code and the current location of each thread. The commands associated with<br>data display and manipulation occupy a separate chapter, which is followed by a discussion of<br>commands for controlling execution of the target program. A final chapter discusses the<br>commands that establish actionpoints. <br>
<b>HPD Command Descriptions</b><br>
<b>2.1 General Debugger Interface</b><br>
Working Version 2.1 - last revised Sept. 15, 1998 <br>
<i>Comments and requests for clarification are welcome. They should be submitted to<br>hpd-comments@ptools.org.</i> <br>
This chapter provides information on the general user interface with the debugger. The specific<br>command functionality includes: <br>
#: ignore remainder of this line (&quot;comment command&quot;) <br>alias: create/view user-defined command(s) <br>unalias: remove previously defined command <br>reference a command history <br>
57<br>
<hr>
<A name=58></a>HPD Version 1<br>
history: determine which commands are saved in the command history <br>!: execute a previous command from the command history <br>
set: change or view value(s) of debugger state variable(s) <br>unset: restore default setting(s) of debugger state variable(s) <br>log: start/stop writing debugger output to a file <br>input: read and execute commands from a file <br>proginput: send command-line input to the target program, rather than the debugger - <b>not<br>available for core-file debugging</b> <br>info: Display debugger environment information <br>help: display help information <br>
Because these commands affect debugger state, rather than program state, the target p/t set is<br>generally irrelevant. While a p/t set prefix can be included on the command, it will be ignored by<br>the debugger. The notable exception is the alias command, which retains any prefix for later<br>use when the user-defined command is invoked. <br>
<b># - Ignore remainder of this line (&quot;comment command&quot;) </b><br>
<b># <i>any-string</i> </b><br>
<i>any-string</i> <br>
Any arbitrary text string not containing a new-line character. <br>
<b>Description</b><br>
The # command is used for comments that will be ignored by the debugger. It can be included in<br>a script file or typed interactively (for possible logging to a script file). <br>
The comment is indicated by a <b>#</b> character as the first character on the line. The remainder of the<br>command (i.e., up to the end-of-line character) will be ignored. <br>
A target p/t set cannot be specified on this command. <br>
The command has no effect on debugger state or program state. It cannot be interrupted by the<br>user. <br>
<b>Command Output</b><br>
None. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A # command can be issued at any time. No messages are generated. <br>
58<br>
<hr>
<A name=59></a>HPD Version 1<br>
<b>Examples</b><br>
# This is a comment!  (no action is taken) <br>
<b>alias - Create or view user-defined command(s)</b><br>
1. Create a new user-defined command<br>
<b>alias <i>command-name</i> <i>command-body</i> </b><br>
2. View previously defined command(s)<br>
<b>alias [<i>command-name</i>] </b><br>
<i>command-name</i> <br>
The name of the command to be defined, using standard name syntax. <br>
<i>command-body</i> <br>
Simple command or compound command, using standard string syntax. <br>
<b>Description</b><br>
The alias command associates a user-defined name with a list of one or more debugger<br>commands. After definition, the user-defined command can be used in the same way as a<br>debugger-defined command, including as part of the definition of new user-defined commands. <br>
When no arguments are specified, the names and definitions for all user-defined commands<br>known to the debugger are displayed. When just a single argument is included, the debugger<br>echoes the user-defined name and displays its current definition. <br>
The second argument establishes how the command name should be interpreted, and must be<br>enclosed in quotes if it contains multiple words. The semantics of the alias command is a<br>simple text expansion. That is, using the newly defined alias is the same as typing in the<br>commands of <i>command-body</i> explicitly. If it is a simple command (i.e., just one command verb),<br>the alias operation makes it possible to shorten the amount of typing needed to issue the<br>command, or to provide a synonym that is more easily remembered. Defining a compound<br>command (i.e., a command list) allows the user to create shortcuts for specifying that a whole<br>sequence of commands be performed. <br>
The p/t set prefix, if present, is interpreted as affecting the defined command, rather than the<br>alias command itself. That is, the prefix will be retained as part of the <i>command-body</i>, and will<br>apply to all component commands (unless overridden by a focus command or a p/t set prefix<br>embedded within the quoted string). The prefix may refer to either a static set. If no prefix is<br>included, the target p/t set will default to the current p/t set at the time the user-defined<br>command is actually applied. <br>
Aliases can be nested. That is, an alias definition can contain the name of any alias that has<br>
59<br>
<hr>
<A name=60></a>HPD Version 1<br>
already been defined. <br>
The command name may be an unambiguous command prefix that would normally be<br>interpreted as a command abbreviation (e.g., st for step). The user definition will take<br>precedence over the debugger's command abbreviation; it is not possible, however, to redefine a<br>fully spelled out debugger-defined command name. <br>
The alias operation stores the new user-defined command in debugger state, but has no effect<br>on program state. The command completes once the command definition has been stored. <br>
As the amount of output can be considerable when no command is named as an argument, the<br>display can be stopped at any time by issuing the user interrupt key; this terminates the<br>command, but has no other effect. When the command is being used to define a new name and is<br>interrupted before it has completed, the name specified as the first argument is left undefined. <br>
<b>Command Output</b><br>
When an alias command is issued with no arguments, the names and definitions of all<br>user-defined commands are listed. If a single argument is specified, just the user-defined<br>command for that alias is displayed. An operation that defines a new command normally<br>produces no output other than error or warning messages. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
An alias command can be issued at any time. Attempting to re-define the name of a<br>debugger-defined command is an error, and an appropriate message will be generated. An<br>attempt to define such a command will generate an error, with an appropriate message. <br>
If the command name has not been defined, or has been deleted using the unalias command, a<br>warning message will be generated indicating that no such name is defined. <br>
Re-defining a command name without having first issued an unalias operation will result in a<br>warning message, but an implicit unalias operation will be carried out on the command name<br>and the new definition will be installed. <br>
The debugger will not attempt to parse the command body until it is first applied - when the user<br>issues the command name as a command. Thus, the debugger may accept a definition that is<br>nonsensical or incorrect. Appropriate error detection will be carried out if and when the<br>command is used. <br>
The commands !!, !, history, and alias may not be included in the second argument.<br>Similarly, circular definitions are not permitted; i.e., the name of the user command being<br>defined cannot appear in its own definition, nor in any alias referred to by its definition. While<br>these are errors, they will not be detected until the aliased command is actually used. <br>
<b>Examples</b><br>
60<br>
<hr>
<A name=61></a>HPD Version 1<br>
alias nt next <br>
Define a command called nt that executes the next<br>command. <br>
alias nt <br>
Display the definition of the nt alias. <br>
alias <br>
Display the definitions of all user-defined commands. <br>
alias s step <br>
Define a command called s. While normally <b>s</b> would<br>be an ambiguous abbreviation (could refer to step or<br>set, for instance) and would be flagged as a syntax<br>error, this definition makes it refer unambiguously to<br>the step command. <br>
alias m &quot;list main&quot; <br>
Define a command called m that lists the source code<br>of function main. <br>
alias step2 &quot;step; step&quot; <br>
Define a command called step2 that does two step<br>commands in a row. Will apply to the target p/t set<br>when the command is issued (either an explicit p/t set<br>prefix on the step2 command, or the default current<br>p/t set). <br>
[0.*] alias step0 &quot;step&quot; <br>
Define a command called step0 that advances all<br>threads in process 0 (evaluated at the time the step0<br>command is issued). <br>
alias steptoo &quot;step0; [1.*]<br>
Define a command called steptoo that does two<br>
step&quot; <br>
step commands in a row, the first affecting all<br>threads in process 0, and the second affecting all<br>threads in process 1. <br>
<b>unalias - Remove previously defined command </b><br>
<b>unalias {<i>command-name</i> | -all} </b><br>
<i>command-name</i> <br>
The name of the command to be deleted, using standard name syntax. <br>
<b>Description</b><br>
The unalias command removes the alias that was previously established for the specified<br>user-defined command name. Use of the argument -all deletes all user-defined commands at<br>once. <br>
The target p/t set is ignored by the debugger in performing this operation. <br>
The unalias command affects debugger state by removing the user's capability to reference the<br>command name. It does not affect program state. The command completes once the debugger<br>
61<br>
<hr>
<A name=62></a>HPD Version 1<br>
has eliminated the alias. <br>
This command may be time-consuming if many aliases have been defined. It may be interrupted<br>with the user interrupt key. This terminates the command; any remaining definitions will be left<br>intact. <br>
<b>Command Output</b><br>
No output is generated for an unalias in normal mode. When verbose output is in effect, the<br>debugger will print a message listing the name(s) and command body(ies) for everything that<br>was deleted. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
An unalias command can be issued at any time. Attempting to specify the name of a<br>debugger-defined command is an error, and an appropriate message will be generated. <br>
Unaliasing a non-existent command name will result in a warning message. <br>
<b>Examples</b><br>
unalias step2  Remove the step2 alias. step2 is now undefined and can no longer be used.<br>
If step2 was included as part of the definition of another command, that will<br>not be affected (since step2 was expanded when the second command was<br>defined. <br>
unalias -all  Remove all aliases. <br>
<b>history - Reference the session command history </b><br>
1. Display recent command history<br>
<b>history [<i>num_commands</i>] </b><br>
2. Repeat execution of most recent command<br>
<b>!! </b><br>
3. Repeat execution of a previous command<br>
<b>! {<i>command_id</i> | <i>rel_command_id</i> | <i>command_string</i>} </b><br>
<i>num_commands</i> <br>
Restricts output to the most recent commands in the history. Defaults to commands in the<br>history list. <br>
<i>command_id</i> <br>
Positive number referring to the identifier of the history command to be repeated. <br>
62<br>
<hr>
<A name=63></a>HPD Version 1<br>
<i>rel_command_id</i> <br>
Negative number indicating position of the history command to be repeated, relative to the<br>current point in the history. <br>
<i>command_string</i><br>
Character string match or partial-prefix match of the command text to be repeated.<br>
<b>Description</b><br>
The history command performs one of several operations related to recently-executed<br>commands recorded in the command history list. Initially, 20 commands are retained in the list;<br>the size of the list is maintained in the debugger state variable MAX_HISTORY and may be<br>changed with the set command. The command cannot be used in scripts of debugger commands<br>to be processed by the proginput command. <br>
When the history command is used with no arguments, formatted text is displayed giving an<br>identifier number and the command string for each command recorded in the list (including the<br>history command itself). If a number is specified, the output is restricted to that number of<br>commands, counting back from the most recent command. <br>
In order to re-execute a command from the command history list, &quot;!&quot; notation is used. !!<br>re-executes the previous command as though it had been re-typed. The exclamation point may<br>also be used as a prefix to refer to a specific command in the history list. A positive number is<br>interpreted by the debugger as referring to the command with that identifier number (all<br>commands in the debugger session are numbered, starting at 1). A negative number refers to a<br>command relative to the current one (i.e., !-1 repeats the previous command, !-2 repeats the<br>one before that, and so on). <br>
Specifying a string instead of a number causes the debugger to search for the most recent<br>command that matches the string. A match occurs only if the command's first characters exactly<br>match those in the string. <br>
When a command from the history list is re-executed, it is the same as if that command were<br>re-entered by the user. Therefore, the command's target p/t set will be evaluated and applied the<br>same as if the user were to physically re-type the command verbatim. Any target p/t set specified<br>on the re-execution command will be ignored by the debugger. <br>
All abbreviated commands are spelled out fully when they are stored in the history list. This<br>applies both to unambiguous prefixes and to user-defined abbreviations. <br>
This command has no effect on program state or debugger state directly. It is possible, however,<br>that the re-executed command will have an effect on one or both states. The command<br>completes when either the command history list has been displayed or the appropriate command<br>has been issued. (Note that the re-executed command itself may not complete immediately.) <br>
Interrupt behavior varies according to whether display or re-execution is involved. When an<br>explicit history command is issued, the amount of output can be considerable if a large history<br>
63<br>
<hr>
<A name=64></a>HPD Version 1<br>
list is being displayed, so output can be stopped at any time by the user interrupt key. This<br>terminates the command, but has no other effect. When the command is being used to<br>re-execute a command, that effect cannot be interrupted by the user; once the re-executed<br>operation has begun, however, interrupt behavior will be as described for the specific command. <br>
<b>Command Output</b><br>
Output from an explicit history command will consist of the formatted command history list.<br>For a command re-execution, the matching command will be displayed, followed by the normal<br>output (if any) of the re-executed command. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
The use of this command within a debugger script is an error, and an appropriate message will<br>be generated when the script is processed using the proginput command. <br>
Otherwise, an explicit history command can be issued at any time. Command re-execution is<br>subject to the restrictions for the particular command being repeated. <br>
If no command can be found to match the command identifier or command string, an error<br>occurs and an appropriate message will be generated. <br>
<b>Examples</b><br>
history <br>
Display a numbered list of the last 20 commands issued. <br>
history 10  Display a numbered list of the last 10 commands issued. <br>
!! <br>
Re-execute the most recent command. <br>
!15 <br>
Re-execute the command numbered 15 in the command history list. <br>
!-15 <br>
Re-execute the command appearing 15 entries back in the command history list<br>(i.e., 15th command before this one). <br>
!print <br>
Re-execute the last print command. <br>
!pr <br>
Re-execute the last command beginning with the prefixpr. <br>
!pri <br>
Re-execute the !pr command. The spelled-out command print is what was<br>stored in the history list. <br>
<b>set - Change or view the value(s) of a debugger state variable(s)</b><br>
1. Change a debugger state variable <br>
<b>set <i>debugger-var</i> = <i>value</i> </b><br>
2. View current debugger state variable(s) <br>
<b>set [<i>debugger-var</i>] </b><br>
64<br>
<hr>
<A name=65></a>HPD Version 1<br>
<i>debugger-var</i> <br>
Name of a debugger state variable. <br>
<i>value</i> <br>
Value to be assigned to that variable. <br>
<b>Description</b><br>
The set command supports the viewing of debugger state variables and the assignment of new<br>values to them. <br>
When no arguments are specified, the names and current values for all debugger state variables<br>are displayed. When just a single argument is included, the debugger echoes the variable name<br>and displays its current value. <br>
The second argument defines the value that should replace any previous value for that variable.<br>It must be enclosed in quotes if it contains multiple words. <br>
HPD Version 1 supports the set command only for a limited number of debugger state<br>variables. Their names and permissible values are shown below. The default settings appear in<br>the debugger initialization file included as part of each implementation. <br>
<i>Debugger Variable  Permitted Values </i><br>
<i>Default </i><br>
MODE <br>
THREADS (not valid for processes-only<br>debuggers), PROCESSES (not valid for<br>threads-only debuggers), or MULTILEVEL (not<br>valid for threads-only or processes-only<br>debuggers) <br>
START_MODEL <br>
ANY or ALL <br>
implementation- specific<br>
STOP_MODEL <br>
ANY or ALL <br>
implementation- specific<br>
MAX_PROMPT <br>
any positive integer <br>
40 <br>
PROMPT <br>
any string; to include the current p/t set, specify [$PTSET]  <br>$PTSET <br>
SOURCE_PATH <br>
any valid directory or directory path; to include empty <br>the current setting, specify $SOURCE_PATH <br>
EXECUTABLE_PATH  any valid directory or directory path; to include<br>
./:$PATH <br>
the current setting, specify $EXECUTABLE_PATH <br>
EVENT_INTERRUPT  ON or OFF <br>
ON <br>
VERBOSE <br>
WARN, ERR, or ALL, <br>
WARN <br>
ERROR_CHECKS <br>
NORMAL, MIN, or MAX <br>
NORMAL <br>
MAX_HISTORY <br>
any positive integer <br>
20 <br>
MAX_LEVELS <br>
any positive integer <br>
20 <br>
MAX_LIST <br>
any positive integer <br>
20 <br>
65<br>
<hr>
<A name=66></a>HPD Version 1<br>
MAX_LIST <br>
any positive integer <br>
In most cases, the target p/t set is ignored by the debugger in performing this operation. The<br>exception is SOURCE_PATH, where the target p/t set is used to identify a single executable whose<br>source path should be affected. <br>
The new value is stored in debugger state, but the operation has no effect on program state. A<br>set command completes once the value has been stored in the appropriate debugger state<br>variable. <br>
As the amount of output can be considerable when no argument is specified, the display can be<br>stopped at any time by issuing the user interrupt key; this terminates the command, but has no<br>other effect. When the command is being used to modify a debugger variable's value and is<br>interrupted before it has completed, that variable is left undefined. <br>
<b>Command Output</b><br>
When a set command is issued with no arguments, the names and values of all debugger state<br>variables are displayed. If a single argument is specified, just that variable's value is shown. <br>
An operation that changes a variable's value normally produces no output other than error or<br>warning messages. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A set command can be issued at any time. If the first argument refers to a non-existent<br>debugger state variable, an error occurs and an appropriate message will be generated. <br>
An error also occurs when the second argument specifies an inappropriate value setting. In this<br>case, the variable value will be left unchanged, and the error message will list the permissible<br>values. <br>
Threads-only and processes-only debuggers will issue a diagnostic message if the user attempts<br>to modify the MODE setting. Processes-only debuggers or debuggers that do not implement the<br>thread-level control extensions will do the same upon attempts to modify START_MODEL or<br>STOP_MODEL. <br>
<b>Examples</b><br>
66<br>
<hr>
<A name=67></a>HPD Version 1<br>
set PROMPT = &quot;Fixme% &quot; <br>
Set the prompt to be Fixme% followed by a<br>space. <br>
set MAX_PROMPT = 15 <br>
Restrict the prompt to a maximum of 15<br>characters, including an ellipsis (...) to<br>indicate that the prompt has been truncated. <br>
set VERBOSE = ALL <br>
Enable verbose mode, producing detailed<br>output from debugger commands. <br>
set VERBOSE <br>
Display the current setting for output<br>verbosity. <br>
set <br>
Display all debugger state variables and their<br>current settings. <br>
set EXECUTABLE_PATH = ( ../test_dir<br>
Prepends ../test_dir onto the previous<br>
$EXECUTABLE_PATH ) <br>
value for the executable path (shown using<br>UNIX syntax). <br>
<b>unset - Restore default setting for a debugger state variable(s) </b><br>
<b>unset {<i>debugger-var</i> | -all} </b><br>
<i>debugger-var</i> <br>
Name of debugger state variable whose default setting will be restored. <br>
-all <br>
Restores the default settings of all debugger state variables. <br>
<b>Description</b><br>
The unset command reverses the effects of any previous set operations, restoring the debugger<br>state variable(s) to their default settings. <br>
When the argument -all is specified, the command affects all debugger state variables,<br>restoring them to the original settings that were in effect when the debugging session began.<br>When just a single argument is included, only that variable is affected. <br>
HPD Version 1 supports the unset command only for a limited number of debugger state<br>variables. See the set command for a list. <br>
The user interrupt key. This terminates the command; any remaining settings will be left intact. <br>
<b>Command Output</b><br>
An unset command normally produces no output other than error or warning messages. <br>
67<br>
<hr>
<A name=68></a>HPD Version 1<br>
<b>Errors, Warnings, and Diagnostics</b><br>
An unset command can be issued at any time. If the argument refers to a non-existent debugger<br>state variable, an error occurs and an appropriate message will be generated. <br>
<b>Examples</b><br>
unset VERBOSE  Restore the output verbosity to its default setting (OFF). <br>
unset -all <br>
Restore all debugger state variables to their default settings. <br>
<b>log - Start or stop the logging of debugger input/output </b><br>
1. Start debugger logging <br>
<b>log <i>file</i> [-quiet] [ {-output | -input} ] </b><br>
2. Stop debugger logging <br>
<b>log <i>file</i> -off </b><br>
3. View current status of debugger logging <br>
<b>log </b><br>
<i>file</i> <br>
A fully or partially qualified symbol name denoting the file where the debugger log should<br>be written. <br>
-quiet <br>
Debugger output is written to the file, but doesn't show on the screen. <br>
-output <br>
Only debugger output (but not debugger commands) is written to the file. <br>
-input <br>
Only debugger commands (but not debugger output) are written to the file. <br>
<b>Description</b><br>
The log command causes all subsequent debugger commands and/or debugger responses to be<br>written to a file. This situation continues until a log -off command is issued. Multiple log files<br>may be in effect at any time. When no arguments are specified, the command displays the<br>current status of each log file that has been used in the debugging session. <br>
The target p/t set is ignored by the debugger in performing this operation. <br>
The <i>file</i> argument may specify any file location accessible to the debugger. If the file already<br>exists, further logging information will be appended to the existing file. When log -off is<br>issued, logging ends and the file is closed. <br>
68<br>
<hr>
<A name=69></a>HPD Version 1<br>
When no options are specified, all debugger input and output is written to both the screen and<br>the named file. The -quiet option directs the debugger that it should not display command<br>output on the screen; that is, commands will appear to generate no visible output. This does not<br>apply to error messages, which will still be printed in order to alert the user to problems. <br>
The -output option indicates that the debugger should log only its command input, not the text<br>of the prompt and the user's command input. This is a useful mechanism for storing the values of<br>program variable values, for instance. <br>
The -input option indicates that the debugger should log only its command output, but not its<br>responses (or the debugger prompt). This is useful for preparing scripts of commands that can<br>be executed in other debugging sessions. <br>
The -off option instructs the debugger to stop logging to the specified file. The file is closed,<br>and if -quiet was in effect, this is canceled. Further input or output appears on the screen <br>
The command affects debugger state when arguments are included, but does not affect program<br>state. A log command completes once the log file (if any) has been successfully opened/closed<br>and any command output has been generated. <br>
A log enabling command can be aborted using the user interrupt key; as a result, logging is left<br>disabled. For log disabling or for log information commands, any attempt at interruption will be<br>ignored by the debugger. <br>
<b>Command Output</b><br>
A log command with no arguments produces a list of log files that have been named in previous<br>log commands, the options in effect for each file, and its current logging status (on or off).<br>When arguments are present, the command normally produces no output other than error or<br>warning messages. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A log command can be issued at any time. If the first argument refers to a file that cannot be<br>opened (or closed, if -off is used), an error occurs and an appropriate message will be<br>generated. <br>
If log -off is issued when logging is not in progress, a warning message will be produced. <br>
<b>Examples</b><br>
69<br>
<hr>
<A name=70></a>HPD Version 1<br>
log ../deb_session <br>
Start recording all debugger input and output to the file<br>named <b>deb_session</b> in the parent of the directory where<br>the debugger was invoked. If the file already exists,<br>logging information will be appended to the previous<br>contents. <br>
log ../deb_responses -output  Start another log file, but restrict logging to just the<br>
output from debugger commands. <br>
log ../deb_commands -output  Start another log file, saving the commands typed by the<br>
user. <br>
log ../deb_sessions -off <br>
Stop logging the session in <b>deb_sessions</b>. (The other log<br>files are still active. <br>
log sessions -quiet -output  Start recording all debugger output to the file named<br>
<b>sessions</b>. Output will no longer show on the screen. <br>
log sessions -off <br>
Stop logging output to file <b>sessions</b> - and begin showing<br>debugger output on the screen again. <b>session2</b>, without<br>displaying that output on the screen. <br>
log <br>
Show the status for all log files, whether or not they are<br>still active. <br>
<b>input - Read and execute commands stored in a file </b><br>
<b>input <i>file</i> </b><br>
<i>file</i> <br>
Fully or partially qualified symbol name denoting a file that contains a sequence of<br>debugger commands. <br>
<b>Description</b><br>
The input command reads a sequence of debugger commands from the specified file and<br>executes them one after another. The debugger will not echo the commands, but any command<br>output is displayed normally. <br>
The p/t set prefix, if present, is ignored by the debugger. If commands from the file are affected<br>by the target p/t set, the current p/t set will be in effect (unless the file overrides it with a focus<br>command or a p/t set prefix). <br>
This command has no direct effect on debugger state or program state. It is possible, however,<br>that the command(s) executed from the file will have an effect on one or both states. <br>
The command may be aborted with the user interrupt key, causing any remaining commands<br>from the file to be ignored. <br>
70<br>
<hr>
<A name=71></a>HPD Version 1<br>
<b>Command Output</b><br>
The input command itself normally produces no output other than error or warning messages.<br>Any output resulting from execution of the command(s) in the file will be displayed. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
An input command can be issued at any time. If it specifies a file that is non-existent or cannot<br>be opened for reading, the command will fail and an appropriate error message will be<br>generated. <br>
When a command from the file results in an error, that command will be aborted and appropriate<br>output displayed according to that command's definition. (Warnings and diagnostics will be<br>ignored.) If any commands remain to be executed, the user will be prompted to decide whether<br>or not execution should continue. <br>
<b>Examples</b><br>
input debug/aliases  Execute the commands found in file <b>aliases</b>, located in subdirectory<br>
<b>debug</b>. <br>
<b>proginput - Send command-line input to the target program, rather than<br>the debugger </b><br>
<b>proginput </b><br>
[Not available for core-file debugging] <br>
<b>Description</b><br>
The proginput command directs the debugger to route all further input to the target program.<br>This makes it possible to debug programs that require interactive input. It will be necessary to<br>&quot;interrupt&quot; the proginput command in order to continue issuing debugger commands. This is<br>accomplished via the user interrupt key. <br>
The p/t set prefix, if present, is ignored by the debugger. <br>
This command has affects debugger state by changing the debugger input mode to &quot;program.&quot; It<br>has no effect on program state. <br>
The command completes when the user interrupt key is pressed. <br>
71<br>
<hr>
<A name=72></a>HPD Version 1<br>
<b>Command Output</b><br>
None. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A proginput command can be issued at any time. No messages are generated. <br>
<b>Examples</b><br>
The following command-line input, issued sequentially, would have the indicated results. The<br>debugger prompt is shown in order to distinguish between debugger-input mode and<br>program-input mode. User input is shown in boldface. <br>
[all]&gt; <b>run</b> <br>
<i> </i> <br>
[all]&gt; <br>
<i>Debugger prompts for next command</i> <br>
Enter degrees of freedom: <br>
<i>Program prompts for first value</i> <br>
<b>proginput</b> <br>
<i>User switches to program input mode</i> <br>
<b>4</b> <br>
<i>User interacts with program, </i><br>
File for results: <b>temp.dat  </b><i>... <br></i><b>^C</b> <br>
<i>then exits back to debugger input mode    </i> <br>
[all] <br>
<i>Debugger prompts for next command</i> <br>
<b>info - Display debugger environment information </b><br>
<b>info </b><br>
<b>Description</b><br>
The info command displays information about the general environment in which the debugger<br>operates. As a minimum, that information will include: <br>
identification of the current debugger release <br>version of HPD with which the debugger complies <br>type of debugger (threads-only, processes-only, or multilevel) <br>debugging mode (THREADS, PROCESSES, or MULTILEVEL) <br>thread-start model (ANY or ALL) <br>thread-stop model (ANY or ALL) <br>executable(s) currently being debugged, and their file location(s) <br>current log file(s), if any <br>current event interrupt mode (ON or OFF) <br>
72<br>
<hr>
<A name=73></a>HPD Version 1<br>
current verbosity level (WARN, ERR, or ALL) <br>current error-checking mode (NORMAL, MIN, or MAX) <br>total number of threads and processes currently executing <br>
The target p/t set is ignored by the debugger in performing this operation. <br>
The info command has no effect on debugger state or program state. It completes once the<br>appropriate information has been displayed. <br>
As the amount of output can be considerable, the display can be stopped at any time by issuing<br>the user interrupt key; this terminates the command, but has no other effect. <br>
<b>Command Output</b><br>
The format of command output is necessarily somewhat implementation dependent. Each item<br>will be clearly identified, and will have an associated help topic that explains its purpose and use.<br>
<b>Errors, Warnings, and Diagnostics</b><br>
A proginput command can be issued at any time. No errors are detected. <br>
<b>Examples</b><br>
info  Display general information about the debugging environment. <br>
<b>help - Display help information </b><br>
<b>help [<i>topic</i>] </b><br>
<i>topic</i> <br>
Specific topic or command name for which information should be displayed. <br>
<b>Description</b><br>
The help command displays information about the specified topic or command. When no<br>argument is included, the debugger displays a list of the topics for which help is available. <br>
The target p/t set is ignored by the debugger in performing this operation. <br>
The help command has no effect on debugger state or program state. It completes once the<br>appropriate information has been displayed. <br>
As the amount of output can be considerable, the display can be stopped at any time by issuing<br>
73<br>
<hr>
<A name=74></a>HPD Version 1<br>
the user interrupt key; this terminates the command, but has no other effect. <br>
<b>Command Output</b><br>
The format of help information is described *elsewhere in this document. Help topics include, as<br>a minimum, the name of each command and each debugger state variable included in HPD<br>Version 1. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A proginput command can be issued at any time. If the help topic specified does not exist, a<br>warning message will be generated. <br>
<b>Examples</b><br>
help help  Display information about how to use the help command. <br>
<b>HPD Command Descriptions</b><br>
<b>2.2 Process/Thread Sets</b><br>
Working Version 2.1 - last revised Sept. 11, 1998 <br>
<i>Comments and requests for clarification are welcome. They should be submitted to<br>hpd-comments@ptools.org.</i> <br>
In this chapter we describe the operations that are used to define and apply process/thread sets<br>(abbreviated as &quot;p/t sets&quot;): <br>
focus: change the current p/t set, or &quot;focus,&quot; of commands <br>defset: define a named set of processes/threads <br>undefset: undefine a named set <br>viewset: view the membership of a named set <br>whichsets: view what sets include a particular process/thread <br>
In contrast to most other types of commands, the target p/t set has little effect on most of the<br>commands described in this chapter. Only whichsets and focus operations are affected by an<br>explicit p/t set prefix or, in its absence, the current p/t set. While the addition of a set prefix on<br>the other commands is accepted by the debugger, it has no effect on the command operations. <br>
<b>focus - Change the current process/thread set </b><br>
74<br>
<hr>
<A name=75></a>HPD Version 1<br>
<b>focus [<i>p/t-set</i>] </b><br>
<i>p/t-set</i> <br>
A set of thread(s), using standard p/t set notation. Indicates identifiers to be included in the<br>new current p/t set. <br>
<b>Description</b><br>
The focus command changes the current p/t set. As a consequence, subsequent commands will<br>apply to just the threads specified in the argument of this command. When no argument is<br>specified, the command lists the threads in the current p/t set. <br>
The argument may be any named set, whether debugger-defined or user-defined, or an explicit<br>list of thread(s). Either a static set or a dynamic set may be specified. If the latter, membership<br>will be re-evaluated each time the set serves as the target p/t set for a command (i.e., for each<br>command issued that requires a target set and does not include an explicit p/t set prefix). <br>
The focus command affects debugger state by replacing the processes and threads previously<br>used as the current set, with those specified in the argument. It does not affect program state in<br>any way. <br>
The command completes when the specified threads have been stored as part of debugger state.<br>It cannot be interrupted by the user; the previous p/t set is deleted as soon as the operation has<br>begun. If some problem arises during the operation, the default p/t set, <b>[all]</b> is reinstated. <br>
<b>Command Output</b><br>
When no argument is specified, the focus lists the members of the current p/t set. For named<br>sets (debugger-defined or user-defined), the name of the set is listed as well. The <b>!</b> notation is<br>used to identify static sets. <br>
Other than error or warning messages, no output is normally generated by this command when<br>an argument has been included. If verbose output is in effect, the debugger will print a message<br>indicating which threads are included in the new current set. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A focus operation can be issued at any time after the executable(s) has been loaded. The<br>current p/t set must always contain at least one thread, so specifying an empty p/t set as the<br>argument - or a user- or debugger-defined set that has become empty - generates an error<br>message and the operation is aborted, leaving the previous p/t set still in effect. Use of an<br>undefined set name as the argument will result in the same behavior. <br>
When an explicit list is supplied as the argument, it is possible that only some of the specified<br>processes/threads actually exist while others do not. In this case, the result of the command will<br>be a current set including just those elements that were valid. A warning message will be issued<br>
75<br>
<hr>
<A name=76></a>HPD Version 1<br>
to inform the user of the situation. <br>
A similar result occurs when a thread occurs multiple times in an explicit list; the debugger will<br>issue a warning message but the current p/t set is re-assigned successfully. <br>
<b>Examples</b><br>
focus [!0.*]<br>
Change the current p/t set to include just those threads currently in<br>process 0. Set membership is static, and will not be re-evaluated. <br>
focus [0.*]<br>
Change the current p/t set to include all threads in process 0. Set<br>membership is dynamic; it will be re-evaluated for subsequent<br>commands affected by the target p/t set. <br>
focus [exec (meso3)] Change the current set to include all threads associated with the<br>
executable <b>meso3</b>. If new threads are created for <b>meso3</b> while this<br>focus is still in effect, they will be included when the set is<br>re-evaluated. <br>
focus [stopped]<br>
Change the current set to include all threads that are currently<br><b>stopped</b>. Set membership changes dynamically. <br>
focus [interesting] Change the current p/t set to the user-defined set named <b>interesting</b>.<br>
Set membership is dynamic, unless <b>interesting</b> was defined to be<br>static. <br>
focus [all]<br>
Change the current set to include all threads involved in executing<br>the target program. This effectively restores the default setting<br>(commands apply to all threads, even newly created ones). <br>
<b>defset - Assign a set name to a group of processes/threads </b><br>
<b>defset <i>set-name</i> <i>p/t-set</i> </b><br>
<i>set-name</i> <br>
The name of the set to be defined, using standard p/t set notation. <br>
<i>p/t-set</i> <br>
A set of thread(s), using standard p/t set notation. Indicates which identifiers should be<br>included in the named set. <br>
<b>Description</b><br>
The defset command associates a logical name with a group of threads and/or processes,<br>creating a user-defined set. Once a user-defined set has been established, it can be used<br>(enclosed in brackets) as a p/t set prefix or as the argument to a focus command, providing a<br>shorthand way of referring to potentially complex groupings of processes and threads. <br>
76<br>
<hr>
<A name=77></a>HPD Version 1<br>
In creating a new set, the user can explicitly list the identifiers of each process and thread to be<br>included, refer to the name of a debugger-defined set, or duplicate an existing user-defined set.<br>Note that set union is not supported in HPD Version 1. <br>
The specification may indicate either a static set or a dynamic set. If the former, membership is<br>evaluated when the defset command is issued. A dynamic set, on the other hand, will not be<br>evaluated until the set name is applied to some command. One consequence is that only<br>membership in dynamic sets can be inherited by new threads created as the program executes.<br>Some commands impose restrictions on the use of dynamic sets; these are explained in the<br>appropriate command descriptions. <br>
The target p/t set has no effect on this operation. <br>
A defset command does not affect program state, but adds the newly defined set to the<br>debugger state information on p/t sets. It completes once the debugger state information has<br>been updated. <br>
When the command is interrupted before it has completed, the set name specified as the first<br>argument is left undefined and cannot be used for specifying p/t sets in other commands. <br>
<b>Command Output</b><br>
The defset command normally does not generate any output other than error or warning<br>messages. When verbose output is in effect, the debugger prints a list of the members if the set is<br>static, expanding wildcards and debugger- or user-defined set names; if the set is dynamic the<br>message indicates the current membership, preceding the list with &quot;Set currently includes:&quot; or<br>similar words. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A defset command can be issued at any time after the executable(s) has been loaded.<br>Attempting to re-define the name of a debugger-defined set is an error, and an appropriate<br>message will be generated. The specification of a non-existent user-defined set name or an<br>empty set (e.g., a static list containing only processes or threads that do not exist) as the second<br>argument will generate an error message and abort the operation. In either case, debugger state<br>will not be affected by the operation. <br>
Re-defining a set name without having first issued an undefset will result in a warning message,<br>but an implicit undefine operation will be carried out on the set name and the new definition<br>will be installed. If the debugger state variable ERROR_CHECKS is set to MAX, the user will be<br>prompted for confirmation before this occurs. <br>
When the second argument names a particular thread more than once, or specifies an empty set,<br>a warning message will be generated, but the set will still be defined. Attempting to include a<br>non-existent p/t will produce a warning message; the set will be defined to include all valid<br>threads that were listed. <br>
77<br>
<hr>
<A name=78></a>HPD Version 1<br>
<b>Examples</b><br>
defset threethreads [0.0:0.2] <br>
Create a static set named <b>threethreads</b>,<br>containing any threads numbered 0<br>through 2 that currently exist in process 0. <br>
defset threads3 [threethreads] <br>
Associate the name <b>threads3</b> with the<br>same set as <b>threethreads</b>. <br>
defset interesting [1.0, 2.0, 5.0,<br>
Create static set <b>interesting</b>, whose<br>
356.0] <br>
members are the first threads in processes<br>1, 2, 5, and 356. <br>
defset static1 [!1.*] <br>
Create a static set containing all threads<br>currently in process 1. Membership will<br>not change over time. <br>
defset dyn1 [1.*] <br>
Create a dynamic set whose members are<br>all threads in process 1. Membership will<br>be evaluated dynamically, according to the<br>rules associated with individual debugger<br>commands, and the set may eventually<br>become empty. <br>
defset initialthreads [!running] <br>
Associate the name <b>initialthreads</b> with the<br>current members of the debugger-defined<br>set <b>running</b>. While the membership of<br><b>running</b> will change over time,<br><b>initialthreads</b> is static and will always<br>refer to the threads that were running<br>when the defset was issued. <br>
defset meso_procs [!exec(meso3)] <br>
Define set <b>meso_procs</b> as the set of all<br>processes currently associated with<br>executable <b>meso3</b>. Membership is static<br>and will not change, even if new processes<br>are later created to execute <b>meso3</b>. <br>
<b>undefset - Undefine a previously defined process/thread set </b><br>
<b>undefset {<i>set-name</i> | -all} </b><br>
<i>set-name</i> <br>
The name of the set to be deleted, using standard p/t set notation. <br>
-all <br>
Deletes all user-defined sets. <br>
78<br>
<hr>
<A name=79></a>HPD Version 1<br>
<b>Description</b><br>
The undefset command reverses the action of defset, so that the set is deleted. This command<br>is applicable only to user-defined sets. <br>
The name of the previously defined set, or the -all option, specifies what set(s) should be<br>deleted. When the argument is a set that is still in use by the debugger, such as the set to which a<br>breakpoint applies, all existing references to that set are replaced with the explicit names of the<br>set's members. If the set is dynamic, its membership will be evaluated for this purpose just before<br>the set is deleted. <br>
The target p/t set has no effect on this operation. <br>
The undefset command affects debugger state by removing the user's capability to reference<br>the set name. It does not affect program state in any way. The command completes once the<br>debugger has updated the information on any members still in use and printed any output. <br>
This command cannot be interrupted by the user; once the operation has begun, the specified set<br>will be deleted. <br>
<b>Command Output</b><br>
Other than error or warning messages, no output is normally generated by an undefset<br>command. When verbose output is in effect, the debugger will print a message indicating which<br>threads were in the deleted set. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
An undefset operation can be issued at any time. Attempting to specify the name of a<br>debugger-defined set is an error, however, and an appropriate message will be generated. <br>
If any members of the set are still in use, the debugger will issue a warning message naming the<br>thread identifier(s) that were substituted for the set name. Undefining a non-existent set will<br>result in a warning message. <br>
<b>Examples</b><br>
undefset threads3  Release the set name <b>threads3</b>, replacing any internal debugger<br>
references to it with the explicit names of the set members. <br>
<b>viewset - List the members of a process/thread set </b><br>
<b>viewset [<i>set-name</i>] </b><br>
79<br>
<hr>
<A name=80></a>HPD Version 1<br>
<i>set-name</i> <br>
The name of the set to be displayed, using standard p/t set notation. Defaults to all sets. <br>
<b>Description</b><br>
The viewset command displays the members of debugger- or user-defined sets. When no<br>argument is used, the members of all currently defined sets are displayed. <br>
The target p/t set has no effect on this operation. <br>
The command affects neither debugger nor program state in any way; it merely provides an<br>informational capability. It completes when the appropriate set name has been looked up and the<br>members listed. <br>
Since the amount of output can be considerable when no set is named as an argument, the<br>display can be stopped at any time by issuing the user interrupt key; this terminates the<br>command, but has no other effect. <br>
<b>Command Output</b><br>
When the command applies to a static set or to the target p/t set, the output from viewset lists<br>all set members, ordered by logical identifier. Because membership in a dynamic set can vary<br>over time, such sets are identified by &quot;Set currently includes:&quot;. <br>
<b>Recommended Practice:</b> As a convenience to users, implementors are encouraged to<br>display set members in a format that is suitable for cutting-and-pasting into a standard p/t<br>set prefix. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A viewset command can be issued at any time after the executable(s) has been loaded.<br>Attempting the operation on a non-existent set is an error, however, and an appropriate message<br>will be generated. <br>
If the specified set is currently empty, an explanatory warning message will be produced. <br>
<b>Examples</b><br>
viewset threads3  List the members of set <b>threads3</b>. <br>
viewset <br>
List the members of each debugger-defined and user-defined set. <br>
<b>whichsets - List all sets to which a process/thread belongs </b><br>
80<br>
<hr>
<A name=81></a>HPD Version 1<br>
<b>whichsets [<i>p/t-set</i>] </b><br>
<i>p/t-set</i> <br>
A set of thread(s), using standard p/t set notation. Indicates identifiers whose set<br>membership should be displayed. Defaults to the target p/t set. <br>
<b>Description</b><br>
The whichsets command displays sets to which a particular thread(s) belongs. When no<br>argument is used, the membership of each thread in the target p/t set is displayed. If a thread(s)<br>is specified as the argument, only its membership information will be displayed. <br>
The command affects neither debugger nor program state in any way; it merely provides an<br>informational capability. It completes when the appropriate thread(s) has been looked up and the<br>sets to which it belongs have been listed. <br>
Since the amount of output can be considerable for a large p/t set, the display can be stopped at<br>any time by issuing the user interrupt key; this terminates the command, but has no other effect. <br>
<b>Command Output</b><br>
The output from whichsets lists the names of all sets - debugger-defined or user-defined, static<br>or dynamic - in which each target thread is a member. If information is displayed for multiple<br>threads, it will be ordered by logical identifier and aggregated when appropriate. No distinction<br>is made between static and dynamic sets. <br>
If the thread does not belong to any sets, this is reported in a brief message. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A whichsets command can be issued at any time after the executable(s) has been loaded.<br>Attempting the operation on a non-existent thread results in a warning message. When that<br>thread is just one of several in the target set, output will be generated for as many threads as<br>possible. <br>
<b>Examples</b><br>
whichsets [2.1] <br>
List the sets of which thread 2.1 is a member. <br>
whichsets [0.*,1.*]  For each thread in processes 0 and 1, list all sets of which it is a<br>
member. <br>
whichsets <br>
List the set membership of each thread in the target p/t set. <br>
81<br>
<hr>
<A name=82></a>HPD Version 1<br>
<b>HPD Command Descriptions</b><br>
<b>2.3 Debugger Initialization/Termination</b><br>
Working Version 2.1 - last revised Sept. 15, 1998 <br>
<i>Comments and requests for clarification are welcome. They should be submitted to<br>hpd-comments@ptools.org.</i> <br>
This chapter describes the HPD Version 1.0 commands associated with initializing and<br>terminating the debugging session, and adding or removing processes from debugger control.<br>The following functionality <b>cannot be used in core-file debugging</b>: <br>
load: load debugging information about target program into debugger and prepare for<br>execution <br>run: start or re-start the execution of user process(es) under control of the debugger <br>attach: bring one or more processes currently executing in the normal run-time<br>environment (i.e., outside the debugger) under the control of the debugger <br>detach: detach the debugger from one or more processes, allowing them to continue<br>executing in the normal run-time environment <br>kill: kill existing user process(es), leaving debugging information in place <br>
In addition, the following commands are defined (and are permitted in core-file debugging): <br>
core: load a core-file image of process(es) for examination <br>status: show current status of processes and threads <br>quit, exit: exit from debugger, ending the debugging session <br>
P/t sets can be applied to only the run and status commands. In these cases, the target p/t set<br>establishes which threads are involved. It can be specified explicitly through the use of a p/t set<br>prefix; in the absence of a prefix, the target set defaults to the current p/t set. <br>
<b>Design Rationale</b><br>
The load, run, kill, attach, and detach operations can only affect entire processes. On a<br>UNIX system, when the debugger attaches to a process, all threads associated with the process<br>must normally also be placed under the control of the debugger. On these systems it may not be<br>possible or practical for the debugger to debug a subset of the threads in a process. When a<br>thread is created by the target process, it usually is placed automatically under the control of the<br>debugger by the target operating system. On some systems, the debugger is notified of thread<br>create and thread exit events, but on others it is not. In general, a good goal for UNIX<br>debuggers is to attach automatically to all threads in the target process and try to arrange to<br>receive all thread create and exit events. <br>
On non-UNIX systems, things become even fuzzier. For example, on some real-time systems<br>(such as pSOS and VxWorks), the &quot;process&quot; is the logical address space of the machine (there is<br>
82<br>
<hr>
<A name=83></a>HPD Version 1<br>
only one process and it always exists), and the threads (usually known as tasks) are completely<br>independent entities which can be created and destroyed without affecting each other. <br>
A distinction is made between user created processes and debugger created processes. HPD<br>commands only affect user processes directly; any effects on debugger processes are left to the<br>implementor. <br>
<b>load - Load debugging information about target program and prepare for<br>execution</b><br>
<b>load <i>executable</i> [-copies <i>copies</i>] </b><br>
<i>executable</i> <br>
Fully or partially qualified symbol name denoting the executable file corresponding to the<br>target program (or one of several such files for an MPMD program). <br>
<i>copies</i> <br>
Positive integer, indicating the number of processes that should be set up to run this<br>executable. Defaults to one. (Not used for threads-only debuggers.) <br>
[Not available for core-file debugging] <br>
<b>Description</b><br>
The load command causes the debugger to load the debugging information associated with the<br>specified executable. It also causes the executable to be loaded into memory, although execution<br>of the target program will not be started at this time. Only one load operation need be performed<br>for each executable, regardless of how many processes will execute it in the target program. <br>
Debugging information includes information about the symbol table, dynamic linking, compiler<br>optimizations, etc. It will be used to initialize debugger state, machine state, and (indirectly)<br>program state. Consequently, a load operation is required before any command that will<br>examine or modify either program state or debugger state. <br>
A load operation can be applied only at the level of processes, so threads are not mentioned<br>explicitly in this description. For threads-only debuggers, there will be just one process and a<br>single executable will be loaded in support of all threads. For processes-only debuggers or<br>multilevel debuggers, there may be many processes. The -copies option is used to specify how<br>many copies of the executable should be loaded into memory - and hence, how many processes<br>will execute the corresponding code. <br>
When the target program involves multiple executables, a separate load must be performed for<br>each. If the executable has already been loaded, the effect of the command is to prepare an<br>additional process(es) to execute it. Any previously loaded copies are unaffected. <br>
83<br>
<hr>
<A name=84></a>HPD Version 1<br>
A load operation can be re-issued for the same executable, later in the same debugging session.<br>There are two circumstances where this is useful: to create another instance(s) of a process<br>(e.g., another copy of a client program); or to verify the effects of a change made to the source<br>code. Intuitively, a subsequent load operation always results in a process with a new process<br>identifier, ready for execution. <br>
The target p/t set is ignored by the debugger in performing this operation. <br>
The load command serves to initialize program state. It also initializes the process-specific and<br>thread-specific portions of debugger state. <br>
If this is the first time that the executable has been loaded, a search is made for it so that its<br>executable-specific debugging information can be loaded. The search will include all directories<br>in the debugger state variable EXECUTABLE_PATH, which by default is initialized to include the<br>current directory as well as the PATH defined in the run-time environment. <br>
If this is the first load operation in the debugging session, general debugger state is initialized as<br>well. Otherwise, actionpoints, p/t sets, etc. are still in effect. They will not apply to the new<br>process, however, unless they were defined in terms of debugger-defined sets or<br>exec(<i>executable</i>). <br>
The command completes once the debugger has located and read the executable and performed<br>the appropriate initialization sequences. <br>
If the command is interrupted by the user interrupt key, the debugger issues a message indicating<br>whether or not the operation succeeded as requested. If not, the message indicates the number<br>of processes for which it failed. <br>
<b>Command Output</b><br>
A load command normally generates a status message, indicating how many processes are ready<br>for execution using the specified executable. If the executable has already been loaded, a<br>message to this effect is displayed as well. <br>
When verbose output is in effect, the debugger lists the identifiers for each process it has<br>created. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A load command must occur prior to the issuing of any commands except those controlling the<br>debugger interface (e.g., creating user-defined commands or changing the values of debugger<br>state variables). It cannot be applied when debugging a core-file. Specification of an executable<br>that does not exist, or a file that is not a valid executable, causes an error, as does specification<br>of a -copies number that is less than one. If any of these occur, the debugger will generate an<br>appropriate error message and abort the operation. <br>
84<br>
<hr>
<A name=85></a>HPD Version 1<br>
Implementations may place limits on the number of processes that may be created by a load<br>command, or may restrict them in some other way. If the constraints are violated, or if the<br>debugger is unable to create the processes for any reason, an error occurs and the command<br>terminates as soon as an error message can be generated. Note that this may or may not leave<br>one or more copies of the executable ready (the number will be made clear in the command<br>output). <br>
The inclusion of a -copies option on the command produces a warning if threads-only<br>debugging is in effect, but does not keep the operation from taking place. <br>
<b>Examples</b><br>
load meso3 <br>
Load object code of <b>meso3</b> into memory and load debugging<br>information for executable <b>meso3</b> into debugger. <br>
load worker -copies 20  Load object code and debugging info, in preparation for running<br>
20 processes executing <b>worker</b>. This option is not appropriate for<br>threads-only debugging. <br>
load meso3 <br>
Create a new copy of executable <b>meso3</b>. General debugger<br>settings, including actionpoints that were defined for <b>all</b> or for<br><b>exec(<i>executable</i>)</b>, will be in effect. <br>
<b>Extensions</b><br>
<b>load <i>executable</i> [-copies | -restart <i>restart-file</i>] </b><br>
<i>restart-file</i> <br>
Name of a checkpoint file from a previous execution of this executable (file must be<br>sufficiently complete to permit restarting) <br>
[Not available for core-file debugging] <br>
Numerous requests from users indicate that this would be a highly desirable extension of the<br>load command. Once the checkpoint file is loaded, further operations would be similar to those<br>when a pre-existing process is attached by the debugger. Unlike a core-file debugging session,<br>restart-based debugging would permit access to all the debugger's capabilities. <br>
The procedure for obtaining a checkpoint file will be implementation dependent. <br>
<b>Recommended Practice</b>: Implementors of this extension are encouraged to support<br>checkpoint from within the debugger using a command with the following syntax: <br>
checkpoint <i>restart-file</i><br>
85<br>
<hr>
<A name=86></a>HPD Version 1<br>
<b>run - Start or re-start execution of target process(es) </b><br>
<b>run [<i>arguments</i>] [<i>I/O-redirection</i>] </b><br>
<i>arguments</i> <br>
Argument list that should be passed to the process. <br>
<i>I/O-redirection</i> <br>
Redirection specification, indicating that I/O corresponding to stdin, stdout, and/or stderr<br>should be redirected. <br>
[Not available for core-file debugging] <br>
<b>Description</b><br>
The run command is used to begin the execution of all processes in the affected set. Any<br>program arguments are passed to the process(es) and I/O redirection for the target program, if<br>specified, takes effect. A prompt is then returned so that the user can continue issuing<br>commands. The command can be re-issued later in the same debugging session, indicating that<br>the process(es) should be re-executed from the beginning. <br>
The syntax of the arguments matches that used when the target program is executed in the<br>normal run-time environment (i.e., outside the control of the debugger). <br>
The affected set is derived from the target p/t set. It may be any static set, or a dynamic set of<br>the form <i>process</i>.*, all, or exec(<i>executable</i>). These are the permissible values for the<br>target p/t set when the command is issued. Note that due to the thread model supported by<br>threads-only debuggers and multilevel debuggers, the run command applies to entire<br>process(es), not to individual threads. Thus, if a single thread serves as the target set, the<br>debugger will apply the operation to an affected set containing all threads in the same process as<br>that thread. <br>
A re-issued run command can only be applied to initial processes, not to processes that were<br>spawned by the target program. Further, each initial process must be terminated; if it has not<br>already terminated normally or been killed explicitly by the user, the debugger will automatically<br>terminate it (after prompting the user for confirmation). Any processes that were spawned by the<br>initial process will be terminated at the same time. <br>
The command has significant effect on program state. It changes the state of all threads in the<br>affected set to <b>running</b>. The first time the command is issued, any arguments are copied to the<br>appropriate program variables and any I/O redirection is initiated. When the command is<br>re-issued for a process(es) that was started previously - or issued for the first time for a process<br>that was attached using the attach command - program state will be reinitialized. As a result,<br>arguments and I/O redirection must be re-specified if they are to be in effect. Further, the<br>command can only be re-issued after all processes in the affected set have been killed; the<br>debugger will prompt the user before killing any processes that are still alive. <br>
86<br>
<hr>
<A name=87></a>HPD Version 1<br>
A run command has only limited effect on debugger state. While process-specific and<br>thread-specific information (such as execution location) will be updated, actionpoint settings,<br>user-defined p/t sets, and other values corresponding to general debugger state will be left<br>unchanged. The appropriate commands must be used to un-define these values if the user does<br>not wish them to persist. Alternatively, the load command should be used to create a &quot;new&quot;<br>process. <br>
The command completes once execution of the appropriate threads has begun. From that point<br>on, the state(s) of the thread(s) will be subject to the normal changes caused by execution. <br>
If a run command is interrupted by the user interrupt key, the debugger prints a message<br>indicating whether or not the operation succeeded as requested. If not, the message indicates the<br>number of threads for which it failed. Note that any started processes will continue running; a<br>halt command will be needed in order to stop them. <br>
<b>Command Output</b><br>
A run command normally produces no output other than error or warning messages. When the<br>operation has been interrupted by the user and verbose output is in effect, the debugger lists<br>each thread for which the start operation was not successful; this output will be aggregated. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A run command cannot be applied when debugging a core-file, nor can it be issued before the<br>corresponding executable has been loaded. The target set is also restricted, in that the only<br>permissible dynamic sets are <i>process</i>.*, all, or exec(<i>executable</i>). Further, it is not possible<br>to apply the command to a spawned process. If any of these errors occurs, the operation is<br>aborted and an appropriate message is generated. <br>
When the command is re-applied to an existing process(es) that has not been killed explicity by<br>the user, it will be terminated and any processes that have been spawned by it will be destroyed<br>irrevocably. If this is necessary, the debugger will prompt the user before continuing with the<br>operation. The prompting will be suppressed only if the debugger state variable ERROR_CHECKS<br>has been set to MIN. <br>
If the affected set is empty or if a particular thread cannot be started, the debugger issues a<br>warning message; the operation will still be applied to any other processes in the set. <br>
<b>Examples</b><br>
The examples assume the current p/t set includes processes 0 and 1 only. <br>
87<br>
<hr>
<A name=88></a>HPD Version 1<br>
run <br>
Begin execution of all threads belonging to processes represented in the<br>current p/t set. A prompt is then returned so that the user can continue<br>issuing commands. <br>
[2.*,3.*] run  Begin execution of all threads in processes 2 and 3. <br>[4.2] run <br>
Begin execution of all threads belonging to process 4. Note that this is the<br>same as [4.*] run. <br>
[all] run <br>
Re-start execution of all threads known to the debugger. If they were not<br>previously killed, the user will be prompted for confirmation before the<br>debugger kills them. <br>
run &lt; file.in  Restart execution of all threads in the current p/t set, setting them up to get<br>
standard input from file <b>file.in</b>. <br>
run 1, 2, 3 <br>
Restart execution of the same threads, passing them the program arguments<br>&quot;1&quot;, &quot;2&quot;, and &quot;3&quot;; file redirection will no longer be in effect. <br>
<b>attach - Bring currently executing process(es) under control of the<br>debugger </b><br>
<b>attach <i>executable</i> <i>pid-list</i> </b><br>
<i>executable</i> <br>
Fully or partially qualified symbol name denoting the executable file corresponding to the<br>target program (or one of several such files for an MPMD program). <br>
<i>pid-list</i> <br>
Comma-separated list of system-level process identifiers (such as UNIX pids), indicating<br>pre-existing process(es) to be brought under debugger control. <br>
[Not available for core-file debugging] <br>
<b>Description</b><br>
The attach command causes the debugger to attach to an existing process(es), making it<br>possible to continue the process' execution under debugger control. The command applies at the<br>process level; all threads corresponding to the process will be attached by the operation. It is the<br>user's responsibility to ensure that the process(es) actually is executing the specified executable. <br>
For a target program that involves multiple executables, a separate attach must be performed<br>for each. <br>
If the <i>executable</i> is not already loaded, a search is made for the executable so that its<br>debugging information can be loaded. The search will include all directories in the debugger<br>state variable EXECUTABLE_PATH. <br>
88<br>
<hr>
<A name=89></a>HPD Version 1<br>
The process identifier(s) specified in the <i>pid-list</i> must refer to existing process(es) in the<br>run-time environment. The process will be attached, regardless of its current execution state. <br>
The target p/t set is ignored by the debugger in performing this operation. <br>
The attach command serves to initialize debugger state, like the load command does. In<br>addition, program state will be modified by changing the state of the process(es) to<br><b>stopped/runnable</b>. To re-start it, a resume command (e.g., go or step) should be used. (Note<br>that a run command will have the effect of terminating the process and re-starting it from the<br>beginning.) The command completes once the debugger has located and read the executable and<br>performed the appropriate state modifications. <br>
If the command is interrupted by the user interrupt key, the debugger issues a message indicating<br>whether or not the operation succeeded as requested. If not, the message indicates the number<br>of processes for which it failed. If multiple processes have been specified, no further processes<br>will be attached after a user interrupt. <br>
<b>Command Output</b><br>
An attach command normally generates a status message indicating how many processes have<br>been attached corresponding to the specified executable. When the operation has been<br>interrupted by the user and verbose output is in effect, the debugger lists each process for which<br>the operation was not successful; this output will be aggregated. If the executable has already<br>been loaded, a message to this effect is displayed. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
An attach command must occur before any command can be applied to the target process(es),<br>and cannot be issued when debugging a core-file. Specification of an executable that does not<br>exist, or a file that is not a valid executable, causes an error. Also, since threads-only debugging<br>supports only a single process, at most one attach or one load can be in effect at a time. If any<br>errors occur, the debugger will generate an appropriate message and abort the operation. <br>
Implementations may place limits on the number of processes that may be attached by a single<br>command, or may restrict them in some other way. If the constraints are violated, or if the<br>debugger is unable to attach the processes for any reason, an error occurs and the command<br>terminates as soon as an error message can be generated. Note that this may or may not leave<br>one or more processes attached (the number will be made clear in the command output). <br>
If an attempt is made to re-attach a process that already is attached, to specify an empty<br><i>pid-list</i>, or to name a process identifier that does not match an existing process within the<br>run-time environment, the debugger issues a warning message, but continues applying the<br>operation to any other processes in the list. <br>
It is the user's responsibility to ensure that the executable specified in the command actually<br>matches that used by the attached process. <br>
89<br>
<hr>
<A name=90></a>HPD Version 1<br>
<b>Recommended Practice:</b> Implementors are encouraged to use whatever means available<br>to detect if an executable does not correspond to the attached process, and to report this<br>situation to the user as an error. <br>
<b>Examples</b><br>
attach meso2 10020 <br>
Load debugging information for <b>meso2</b> and bring the<br>process known to the run-time system by pid 10020 under<br>control of the debugger. (The process must be executing<br><b>meso2</b>.) <br>
attach worker 51172, 52006  Load debugging information for <b>worker</b> and bring the<br>
processes corresponding to pids 51172 and 52006 under<br>control of the debugger. (The processes must be executing<br><b>worker</b>). <br>
<b>detach - Detach debugger from target process(es), leaving it executing </b><br>
<b>detach </b><br>
[Not available for core-file debugging] <br>
<b>Description</b><br>
The detach command detaches the debugger from all processes in the affected set. This serves<br>to undo the effects of attaching the debugger to a running process; that is, the debugger releases<br>all control over the process, eliminates all debugger state information related to it, and allows it<br>to continue execution in the normal run-time environment. Any process may be detached,<br>however, not just one that was originally loaded with an attach command. <br>
From this point on, the user will no longer be able to access program variables, source location,<br>actionpoint settings, or other information related to the detached process. <br>
The affected set is derived from the target p/t set. It may be any static set, or a dynamic set of<br>the form <i>process</i>.*, all, or exec(<i>executable</i>). These are the permissible values for the<br>target p/t set when the command is issued. Note that due to the thread model supported by<br>threads-only debuggers and multilevel debuggers, the detach command applies to entire<br>process(es), not to individual threads. Thus, if a single thread serves as the target set, the<br>debugger will apply the operation to an affected set containing all threads in the same process as<br>that thread. <br>
The debugger releases the process(es), leaving its threads in whatever state(s) the flow of<br>execution control dictates; that is, whatever states would exist if the debugger were absent. The<br>
90<br>
<hr>
<A name=91></a>HPD Version 1<br>
overall effect on the process is to remove all actionpoints and continue executing the process<br>without restriction. A detach command completes when the process has been released to the<br>run-time environment and the appropriate debugger state variables have been eliminated. <br>
The application of this command to any particular process cannot be interrupted by user<br>intervention - once it has begun, the process will be released from debugger control. If multiple<br>processes are involved, however, no further processes will be detached after detection of the<br>user interrupt key. <br>
<b>Command Output</b><br>
A detach command normally produces no output other than error or warning messages. When<br>the operation has been interrupted by the user and verbose output is in effect, the debugger lists<br>the status of all threads in the affected set. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A detach command cannot be applied when debugging a core-file, nor can it be issued before<br>an executable has been loaded (via either a load or an attach operation). The target set is also<br>restricted, in that the only permissible dynamic sets are <i>process</i>.*, all, or exec(<i>executable</i>).<br>If any of these errors occurs, the operation is aborted and an appropriate message is generated. <br>
If the affected set is empty or if one of the specified processes does not exist, the debugger<br>issues a warning message; the operation will still be applied to any other processes in the set. <br>
If the debugger is unable to detach the specified processes, an appropriate diagnostic will be<br>displayed. <br>
<b>Examples</b><br>
detach <br>
Detach all processes included in the current p/t set, leaving them<br>executing in the normal (outside the debugger) run-time<br>environment. <br>
[0:*,3.*] detach <br>
Detach processes 0 and 3. <br>
[1.2] detach <br>
Detach process 1. Note that this is the same as [1.*] detach. <br>
[exec(meso3)] detach  Detach all processes associated with <b>meso3</b>. <br>
<b>kill - Terminate execution of target process(es) </b><br>
<b>kill </b><br>
[Not available for core-file debugging] <br>
91<br>
<hr>
<A name=92></a>HPD Version 1<br>
<b>Description</b><br>
The kill command terminates the execution of all processes in the affected set. <br>
The executables associated with the defined processes will still be &quot;loaded&quot; in the debugger and<br>memory. Therefore, issuing another run command will have the effect of re-starting the<br>processes. <br>
The affected set is derived from the target p/t set. It may be any static set, or a dynamic set of<br>the form <i>process</i>.*, all, or exec(<i>executable</i>). These are the permissible values for the<br>target p/t set when the command is issued. Note that due to the thread model supported by<br>threads-only debuggers and multilevel debuggers, the kill command applies to entire<br>process(es), not to individual threads. Thus, if a single thread serves as the target set, the<br>debugger will apply the operation to an affected set containing all threads in the same process as<br>that thread. <br>
The command alters program state by terminating all process(es) in the affected set. Further, any<br>spawned processes are irrevocably destroyed when the initial process that created them is killed.<br>Only the initial process will be available for subsequent re-starting using the run command. The<br>command destroys all process-specific and thread-specific debugger state, but does not affect<br>general debugger information. (That is, all actionpoints, user-defined sets, etc. are retained; to<br>eliminate them, follow kill with a run command. The command completes once the<br>appropriate processes have been destroyed. <br>
If a kill command is interrupted by the user interrupt key, the debugger prints a message<br>indicating how many processes were terminated. Note that any other processes will continue<br>executing. <br>
<b>Command Output</b><br>
A kill command normally produces no output other than error or warning messages. When the<br>operation has been interrupted by the user and verbose output is in effect, the debugger lists the<br>status of all threads in the affected set. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A kill command cannot be applied when debugging a core-file, nor can it be issued before an<br>executable is loaded and execution has been initiated. The target set is also restricted, in that the<br>only permissible dynamic sets are <i>process</i>.*, all, or exec(<i>executable</i>). If any of these<br>errors occurs, the operation is aborted and an appropriate message is generated. <br>
If the affected set is empty or if one of the specified processes does not exist, the debugger<br>issues a warning message; the operation will still be applied to any other processes in the set. <br>
If any of the affected threads are currently in the <b>running</b> state, the debugger will prompt the<br>
92<br>
<hr>
<A name=93></a>HPD Version 1<br>
user before continuing with the operation. This prompting will be suppressed only if the<br>debugger state variable ERROR_CHECKS has been set to MIN. <br>
If the debugger is unable to kill the specified processes, an appropriate diagnostic will be<br>displayed. <br>
<b>Examples</b><br>
kill <br>
Terminate all threads belonging to processes in the current p/t set. <br>
[0:*,3.*] kill <br>
Terminate all threads belonging to processes 0 and 3. <br>
[1.2] kill <br>
Terminate all threads belonging to process 1. Note that this is the same<br>as [1.*] kill. <br>
[exec(meso3)] kill  Terminate all threads in any process associated with <b>meso3</b>. <br>
<b>core - Load core-file image of process(es) for examination </b><br>
<b>core <i>executable</i> <i>core-list</i> </b><br>
<i>executable</i> <br>
Fully or partially qualified symbol name denoting the executable file corresponding to the<br>target program (or one of several such files for an MPMD program). <br>
<i>core-list</i> <br>
Comma-separated list of fully or partially qualified symbol names denoting core-files. <br>
<b>Description</b><br>
The core command instructs the debugger to load a core-file into memory, allowing the user to<br>examine its state. Because the core-file corresponds to a target program that is no longer<br>executing, only certain debugging operations can be performed in core-file debugging. In<br>particular, program state must remain static, meaning that execution cannot be continued, nor<br>can the contents of program variables be modified. The only debugger commands allowed in<br>core-file debugging, then, are those that examine (read) program state. <br>
A search is made for the <i>executable</i> so that its debugging information can be loaded. The<br>search will include all directories in the debugger state variable EXECUTABLE_PATH. (If the<br>core-file has already been loaded, a message to this effect is displayed.) <br>
The command applies at the process level; it is not possible to load a core-file corresponding to<br>a single thread. It is the user's responsibility to ensure that the core-file was actually generated<br>through execution of the specified executable. If the original program involved multiple<br>executables, a separate core must be performed for each. <br>
The core-file(s) specified in the <i>core-list</i> must refer to an existing file(s) accessible to the<br>
93<br>
<hr>
<A name=94></a>HPD Version 1<br>
debugger in the run-time environment. <br>
The target p/t set is ignored by the debugger in performing this operation. <br>
The core command serves to initialize debugger state and program state like the load command<br>does. However, program state will not be allowed to change. The command completes once the<br>debugger has located and read the executable and initialized its state information. <br>
If the command is interrupted by the user interrupt key, the debugger issues a message indicating<br>whether or not the operation succeeded as requested. If not, the message indicates the number<br>of core-files for which it failed. If multiple files have been specified, no further core-files will be<br>loaded after a user interrupt. <br>
<b>Command Output</b><br>
A core command normally generates a status message, indicating how many core-files were<br>loaded for the specified executable. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A core command must occur before any command can be applied other than general debugger<br>interface commands. Specification of an executable that does not exist, or a file that is not a<br>valid executable, causes an error. Similar restrictions apply to the core-files specified on the<br>command. If any of these errors occur, the debugger will generate an appropriate message and<br>abort the operation. <br>
Implementations may place limits on the number of core-files that may be loaded by a single<br>command, or may restrict them in some other way. If the constraints are violated, or if the<br>debugger is unable to load the files for any reason, an error occurs and the command terminates<br>as soon as an error message can be generated. Note that this may or may not leave one or more<br>core-files loaded (the number will be made clear in the command output). <br>
If an attempt is made to load a core-file that already is loaded or to specify an empty <i>core-list<br></i>the debugger issues a warning message, but continues applying the operation to any other<br>core-files in the list. <br>
It is the user's responsibility to ensure that the executable specified in the command actually<br>matches that which provoked generation of the core-file(s). <br>
<b>Recommended Practice:</b> Implementors are encouraged to use whatever means available<br>to detect if an executable does not correspond to the core-file, and to report this situation<br>to the user as an error. <br>
<b>Examples</b><br>
94<br>
<hr>
<A name=95></a>HPD Version 1<br>
core meso2 ../core <br>
Load debugging information and the core image<br>stored in <b>../core</b>. Only debugger commands for<br>examining program state (not for modifying it) will<br>be available. The core-file must have been the<br>result of executing <b>meso2</b>. <br>
core meso3 core.0056, core.0058,<br>
Load debugging information and the core images<br>
core.0059 <br>
stored in the three files indicated. Commands will<br>be restricted, and the user is responsible for<br>ensuring that the core-files were generated by a<br>single failed execution of <b>meso3</b>. <br>
<b>status - Show current status of processes and threads </b><br>
<b>status [-mpi] </b><br>
-mpi <br>
Includes the rank in MPI_COMM_WORLD (available only for threads that have already called<br>MPI_INIT). Not used for threads-only debuggers. <br>
<b>Description</b><br>
The status command displays information about the current state of all threads involved in the<br>target p/t set. (Only user-level entities are reported; additional processes or threads created as<br>part of the debugger implementation are hidden from the user.) Output is always aggregated<br>when the command applies to more than one thread. <br>
The effect of the target p/t set is to restrict the display to just those threads belonging to that set.<br>Any static set or dynamic set can be used as the target set. <br>
The -mpi option indicates that the debugger should also display information on the thread's<br>&quot;rank&quot; in communicator MPI_COMM_WORLD used by the MPI run-time system. The information<br>will be shown only for threads that have already called routine MPI_INIT. <br>
The command has no effect on program state or debugger state. It completes as soon as the<br>appropriate state data have been accessed and reported to the user. <br>
The display of lengthy command output can be stopped at any time by issuing the user interrupt<br>key. This terminates the command, but has no other effect on program or debugger state. <br>
<b>Command Output</b><br>
Status is displayed in a table with one line per process or thread, presented in order of debugger<br>process/thread identifiers. In addition to the logical id, the following information is included: <br>
95<br>
<hr>
<A name=96></a>HPD Version 1<br>
threads-only debuggers: <br>
for the process: executable name, mapping to run-time identifier (e.g., pid for an<br>executing process, or core-file name) <br>for each thread: current state <br>
processes-only debuggers: <br>
for each process: executable name, mappings to run-time identifiers (e.g., pid for an<br>executing process, or core-file name), mapping to rank in MPI_COMM_WORLD if -mpi is<br>in effect current state <br>
multilevel debuggers: <br>
for each process: executable name, mappings to run-time identifiers (e.g., pid for an<br>executing process, or core-file name), mapping to rank in MPI_COMM_WORLD if -mpi is<br>in effect <br>for each thread: current state <br>
The output format for a single process with multiple threads is of the general form: <br>
 Log.ID  State:Reason      Executable    Mapping<br>
==============================================================<br>
 0.*                       meso3         pid=100456, mpi=0<br>
 0.0     stopped/held         <br>
 0.1     running        <br>
 0.2     stopped/runnable       <br>
 0.3     running      <br>
 0.4     stopped/runnable<br>
 0.5     stopped/held     <br>
 0.6     stopped/runnable<br>
When the text of subsequent lines is identical, they are aggregated. In the previous example, if<br>thread 2 were in the <b>running</b> state, the third, fourth, and fifth lines would be aggregated to<br>appear as follows: <br>
 0.1:3  running<br>
Output from a multilevel debugger would add lines for each additional process and its member<br>threads. <br>
Processes-only output lists one line per process, with output of the general form: <br>
 Log.ID  State:Reason    Executable    Mapping<br>
============================================================<br>
 0.*     running         meso3         pid=100456, mpi=0<br>
 1.*     stopped/held    meso3         pid=101214, mpi=1<br>
 2.*     running         hist_gen      pid=101033, mpi=2<br>
 4.*     running         hist_gen      pid=101037, mpi=3<br>
 6.*     running         meso3         pid=101046, mpi=4<br>
 7.*     stopped/held    meso3         pid=101055, mpi=5<br>
A threads-only debugger, or a processes-only or multilevel debugger that supports only SPMD<br>programming models, may elect to omit the name of the executable from the display. <br>
96<br>
<hr>
<A name=97></a>HPD Version 1<br>
<b>Recommended Practice:</b> Implementors are encouraged to display a &quot;reason&quot; for threads<br>being stopped (e.g., &quot;watch&quot; or &quot;break&quot; plus the corresponding actionpoint identifier). <br>
<b>Errors, Warnings, and Diagnostics</b><br>
The status command may be issued at any time, even before any threads exist under debugger<br>control. <br>
If no thread exists within the target p/t set (or if no thread exists at all) a warning message is<br>issued. A similar action takes place when -mpi is specified in threads-only debugging, or does<br>not apply to any of the target threads. <br>
Specification of an invalid thread causes a warning message to be issued. If this is just one in a<br>list of several threads, the status of other items in the list will be displayed. <br>
<b>Examples</b><br>
status <br>
Display the status of all threads in the current p/t set. <br>
[1.*] status <br>
Display the status of only the threads associated with process 1. <br>
[1.*,2.*] status -mpi  Display the status of all threads in processes 1 and 2, including<br>
their rank in MPI_COMM_WORLD (if MPI_INIT has been called). Not<br>used in threads-only debugging. <br>
[exec(meso3)] status  Display the status of only the threads associated with the<br>
executable <b>meso3</b>. <br>
<b>Extensions</b><br>
<b>status [-all] [-mpi] [-changed] </b><br>
-changed <br>
Displays only those threads whose state has changed since the last status command. <br>
This option provides a way of restricting the quantity of output generated for target programs<br>that involve many processes and/or threads. Only threads whose state has actually changed will<br>be displayed. <br>
<b>quit, exit - Terminate the debugging session </b><br>
<b>quit </b><br>
<b>exit </b><br>
97<br>
<hr>
<A name=98></a>HPD Version 1<br>
<b>Description</b><br>
The quit/exit command terminates the debugging session, eliminating all information<br>pertaining to debugger state and program state. Control is returned to the run-time<br>environment's command line where the debugger was originally invoked. <br>
Any process(es) and threads that were created by the debugger are destroyed. Any processes<br>that existed prior to the debugging session (i.e., were attached by the debugger as part of an<br>attach operation) are subjected to an implicit detach command and left executing in the<br>run-time environment. <br>
The command has no arguments. <br>
The target p/t set is ignored by the debugger in performing this operation. <br>
This command clears all debugger state information, so no further commands can be issued in<br>the debugging session. It completes as soon as the debugger has destroyed or detached all<br>processes and performed its housekeeping chores. <br>
The quit/exit command cannot be halted by the user interrupt key; once issued, it will take<br>effect and the debugging session will end. <br>
<b>Command Output </b><br>
A quit/exit command normally produces no output. If processes are automatically detached,<br>however, a message is produced that includes their process identifiers. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
None. <br>
<b>Examples</b><br>
quit      Exit the debugger, leaving any &quot;attached&quot; processes running (in the run-time<br>
environment). <br>
exit <br>
Same effect. <br>
<b>HPD Command Descriptions</b><br>
<b>2.4 Program Information</b><br>
Working Version 2.1 - last revised Sept. 10, 1998 <br>
98<br>
<hr>
<A name=99></a>HPD Version 1<br>
<i>Comments and requests for clarification are welcome. They should be submitted to<br>hpd-comments@ptools.org.</i> <br>
The commands described in this chapter provide information about the target program's current<br>execution location, as well as allowing the user to browse the program's source files. Command<br>functionality includes: <br>
list: browse source code <br>
relative to a particular file, procedure, or line <br>relative to the current list location <br>relative to the current execution location of a particular thread <br>
where: examine current execution location(s) of the target program <br>
(short form) current location of process(es)/thread(s), shown in terms of source<br>procedure and statement <br>(full form) current location of process(es)/thread(s), shown as a complete listing of the<br>call stack, with or without argument values <br>
up, down: navigate through the call stack by manipulating the current frame <br>what: determine what a symbol name from the target program refers to <br>
Any of these operations can be applied to multiple threads. The target p/t set establishes which<br>threads are involved. It can be specified explicitly through the use of a p/t set prefix; in the<br>absence of a prefix, the target set defaults to the current p/t set. <br>
<b>list - Display source code lines</b><br>
1. Display code relative to the start of some file or procedure, or to some specific code line <br>
<b>list <i>source-loc</i> [-length [-]<i>num-lines</i>] </b><br>
2. Display code relative to current list location <br>
<b>list [-length [-]<i>num-lines</i>] </b><br>
3. Display code relative to current execution location <br>
<b>list $EXEC [-length [-]<i>num-lines</i>] </b><br>
<i>source-loc</i> <br>
Fully or partially qualified symbol name, specifying a source location. <br>
$EXEC <br>
Displays from the current execution location (resolving to a single location, if necessary). <br>
<i>num-lines</i> <br>
Number of lines to display, measured forward or backward from the current list location.<br>For location-relative, file-relative, or line-relative display, defaults to current value of<br>debugger state variable MAX_LIST. For procedure-relative, the default is to display code<br>for the entire procedure. <br>
99<br>
<hr>
<A name=100></a>HPD Version 1<br>
<b>Description</b><br>
The list command displays lines of source code. The user can control both the location in the<br>source code and the number of lines displayed. Successive list commands without location<br>arguments result in the display of consecutive sequences of source lines. <br>
Specification of a source location as an argument to the command directs the debugger to<br>display lines relative to a particular, fixed point in the source code. When a file or procedure is<br>named, the listing begins at the first line (the precise location may vary somewhat for<br>procedures, depending on how the compiler generates debugging information). If a line number<br>is specified instead, a window of code around that line will be displayed, starting<br><i>floor(num-lines/2)</i> lines prior to the named location. If the location argument is not fully<br>qualified, the debugger may need to perform a symbol lookup or search the directories in the<br>debugger state variable SRCPATH in order to locate the appropriate source file. <br>
When a procedure name has been specified without a -length option, the entire procedure is<br>displayed. In other cases when the option is omitted, the number of lines displayed is based on<br>the current value of the debugger state variable MAX_LIST (initially set to 20). This may be<br>modified using the set command, or the user can override it using the -length option and<br>specifying any non-zero integer. A positive value causes <i>num-lines</i> lines to be displayed, starting<br>at the current list location. A negative value causes -<i>num-lines </i>(i.e., the absolute value of the<br>specified length) to be displayed, ending at the current list location. <br>
Any request that logically includes lines before the first line of a file or after the last line will<br>display all existing lines within the requested window and complete normally (no warning<br>message). <br>
When no argument is furnished, the listing begins at the current list location, which is established<br>as follows. When an executable is loaded, the current list location is set to the first line of the<br>source file containing the &quot;main&quot; entry point for that executable. This location is modified by<br>subsequent list, up, and down commands. <br>
After the lines have been displayed, the length is added to the value of the current list location so<br>that subsequent list commands will display successive portions of source code. When the user<br>changes the direction of listing (e.g., by performing a list operation with a positive length<br>followed by one with a negative length), the current list location is adjusted automatically so that<br>the previous lines will not be repeated. Conceptually, when the list direction is changed, the<br>current list location is set to the current-list-location minus the length-of-last-listing before any<br>lines are displayed. (Actual implementation algorithms may vary.) <br>
The current list location is also adjusted automatically in response to up or down commands, so<br>as to make the next list command center around the current execution location in the current<br>frame. To accomplish this, the value <i>floor(num-lines/2) </i>is subtracted from the current list<br>location before the listing begins. At the end of the operation, the current list location is updated<br>as usual. <br>
100<br>
<hr>
<A name=101></a>HPD Version 1<br>
When $EXEC is specified, source code is displayed relative to the current execution location,<br>which is altered automatically as program events (e.g., breakpoints) are triggered. Again the<br>lines displayed center around the line of interest in the code. <br>
The effect of the target p/t set is to indicate that the source display reflect the source code<br>associated with a particular thread(s). Note that when the set includes more than one thread, it is<br>possible for the starting location to be ambiguous. Consider the case where the target set<br>contains two threads that have stopped at distinct locations in the code. A list $EXEC<br>command actually refers to two current execution locations. The debugger will choose one of<br>the threads by applying a thread arbitration algorithm and use that value as the list location. To<br>see the source code corresponding to the other thread, it will be necessary to specify a<br>p/t-set-prefix naming just the one thread, or issue an appropriate focus command prior to the<br>list. <br>
Any collection of processes and threads can be specified as the target set of this command. Since<br>set membership is evaluated immediately, however, there is no significance in using a dynamic<br>versus a static set. <br>
This command has no effect on program state, but it does modify that portion of debugger state<br>that defines the current list location, as described above. <br>
The list command completes when the appropriate source code lines have been found and<br>displayed, and the list location has been updated accordingly. <br>
Since the amount of output can be considerable - especially if a procedure name is given as the<br>argument and no -length option is included - the display can be stopped at any time by issuing<br>the user interrupt key; this terminates the command, but has no other effect on program or<br>debugger state. In This case, the current list location is left unchanged. <br>
<b>Command Output</b><br>
Each line of output duplicates the text of the source file, except that it is preceded by a line<br>number. <br>
<b>Recommended Practice</b>: Implementors are encouraged to annotate the source listing with<br>a character(s) indicating the current execution location(s). The encoding of additional<br>information, such as the locations of current actionpoint settings, also is encouraged. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A list command specifying a particular procedure or line as the starting point can be issued at<br>any time after the executable is loaded. To list from the current execution location, however, all<br>threads in the target set must be stopped, as only then can the location be evaluated. If a target<br>thread is still running, or if there is no current execution location (e.g., because the thread no<br>longer exists), an error occurs and an appropriate message is generated. <br>
101<br>
<hr>
<A name=102></a>HPD Version 1<br>
An error also occurs if the file, procedure, or line location argument is improperly formed, or if<br>no such location can be found. Specifying a source location that has been modified since being<br>used for compilation will not necessarily generate an error or warning, since there may be no<br>way for the debugger to detect this. In that case, the location and/or the lines displayed may be<br>incorrect. <br>
<b>Recommended Practice</b>: Implementors are encouraged to use whatever mechanisms are<br>available to detect a mismatch between the source file specified (or found through search)<br>and that used for the executable - for example, by comparing date information for the two<br>files. Any mismatch should be reported in the form of a warning issued the first time that<br>code from the source file is displayed. <br>
When the debugger must apply a thread arbitration algorithm (because the command applies to<br>multiple threads that are stopped at different locations), a warning message will follow the<br>listing, identifying which thread's (or threads') location is being shown. <br>
<b>Examples</b><br>
The examples assume that MAX_LIST is still at its initial value of 10. <br>
list <br>
Display twenty lines of source code, beginning at<br>the current list location. The list location will be<br>incremented by 20 when the command<br>completes. <br>
list 10 <br>
Display twenty lines, starting with line 10 of the<br>file corresponding to the current list location<br>(i.e., 10 lines before the current location). The<br>list location will be updated to line 30. <br>
list -length 10 <br>
Display ten lines, starting with the current list<br>location. The value of the list location will be<br>increased by ten. <br>
list -length -50 <br>
Display source code preceding the current list<br>location; fifty lines will be shown, ending with<br>the list location. The list location will be<br>decremented by fifty. <br>
list inv_fft <br>
Display all source code lines for procedure<br><b>inv_fft</b>. The list location will be updated to the<br>first line following the end of the procedure. <br>
[2.*] list inv_fft <br>
Display all source code lines for the routine<br><b>inv_fft</b> associated with process 2. This could<br>also be specified as list #meso3#inv_fft,<br>naming the executable for process 2. <br>
list $EXEC <br>
Display twenty lines starting ten lines above the<br>current execution location. If more than one<br>
102<br>
<hr>
<A name=103></a>HPD Version 1<br>
location is current for the target set, a thread<br>arbitration algorithm will determine which one<br>will be shown (e.g., the lowest-numbered<br>thread), and a warning will be issued. The list<br>location will be updated to that line plus ten. <br>
[1.2] list $EXEC <br>
Start the display ten lines before the current<br>execution location of thread 1.2. The list location<br>will be updated to that line plus ten. <br>
list ffts.f#80 -length 10 <br>
Display ten lines, starting with line 75 in file<br><b>ffts.f</b>. The list location will be updated to line 85.<br>
... intervening up or down command ...<br>
Display twenty lines, relative to the current<br>
list <br>
location in the new frame. <br>
[1.*]&gt; list main<br>
List the entire procedure <b>main</b>. After breakpoint<br>
[1.*]&gt; break inv<br>
[1.*]&gt; cont<br>
is set at entry to procedure <b>inv</b> and execution is<br>
<i> ... stopped at meso3.c#inv#12</i> [1.*]&gt; list continued, arrival at the breakpoint does not alter<br>
[1.*]&gt; list $EXEC<br>
the list location, but does update $EXEC. Thus,<br>the unmodified list displays the lines following<br><b>main</b>. The command list $EXEC must be<br>specified in order to change the list location to<br>the line where the breakpoint occurred. <br>
<b>where - Display the current execution location and call stack</b><br>
<b>where [ {<i>num-levels</i> | -all} ] [-args] </b><br>
<i>num-levels</i> <br>
Restricts output to the most recent N levels of the call stack(s). Defaults to the value of<br>debugger state variable MAX_LEVELS. <br>
-all <br>
Show all levels of the call stack. <br>
-args <br>
Display argument names and values as well as program location information. <br>
<b>Description</b><br>
The where command displays the current execution location(s) and the call stack(s) - or<br>sequence of procedure calls - which led to that point. <br>
Arguments control the amount of command output in two ways. First, by specifying<br>num-levels, the user controls how many levels of the call stack(s) will be displayed, counting<br>from the uppermost (most recent) level; the keyword -all indicates that all levels should be<br>shown. Second, -args is used to specify that procedure argument names and values be<br>displayed as well, for each stack level. A where command with no arguments displays the call<br>
103<br>
<hr>
<A name=104></a>HPD Version 1<br>
stacks for all threads in the target set, showing (per thread) no more than the number of levels<br>indicated in the debugger state variable MAX_LEVELS. Initially, this is 20 levels; the value can<br>be changed using the set command. <br>
Output will be generated for each thread in the target p/t set. When the command applies to<br>more than one thread, the output will be aggregated. Any collection of processes and threads<br>can be specified as the target set. Since set membership is evaluated immediately, however, there<br>is no significance in using a dynamic set versus a static set. <br>
A where command has no effect on program state or debugger state. It completes as soon as the<br>appropriate data have been accessed and reported to the user. The display of lengthy command<br>output can be stopped at any time by issuing the user interrupt key; this terminates the<br>command, but has no effect on program or debugger state. <br>
<b>Command Output</b><br>
A call stack is displayed one line per stack level, beginning at level 0 (where 0 corresponds to<br>the frame containing the current execution location, 1 to the frame where the current procedure<br>was invoked, etc.). Each line shows the stack level and the source location where the thread is<br>stopped, expressed in terms of file (qualified if necessary by the name of the executable),<br>procedure, and line number. <br>
If the -args option is in effect, this line is followed by a series of indented lines representing the<br>argument values. Each such line is labeled with the symbol name of the argument (with<br>unambiguous levels eliminated). The format is identical to that obtained through use of the<br>print command with the names option in effect. <br>
The command output for a single call stack, then, is of the general form: <br>
0   #gauss.c#gauss#28<br>
      <i>argument display, if specified</i><br>
1   #matfs#linsol.c#solv1#310<br>
      <i>argument display, if specified</i><br>
...<br>
4   #matfs#linsol.c#main#83<br>
      <i>argument display, if specified</i><br>
If the number of levels specified by the user exceeds the depth of the call stack, all levels will be<br>shown and no diagnostic will be issued. <br>
When the command applies to multiple threads, their call stacks are aggregated prior to display,<br>with each call stack preceded by a string identifying the threads to which it corresponds. Thus,<br>the overall format of where output is as follows: <br>
      <i>first process/thread group</i><b>:<br></b>         <i>call stack</i><br>
      <i>second process/thread group</i><b>:<br></b>         <i>call stack</i><br>
104<br>
<hr>
<A name=105></a>HPD Version 1<br>
      ...<br>
      <i>last process/thread group</i><b>:<br></b>         <i>call stack</i><br>
<b>Errors, Warnings, and Diagnostics</b><br>
A where command can be issued at any time after the executable has been loaded. The operation<br>is valid only for threads that are stopped, however, as the current execution location is not<br>accessible while a thread is running or before it has begun execution. If one or more threads in<br>the target p/t set are not stopped, an error message is generated for that thread, but the stack<br>information from all stopped threads will be displayed. <br>
<b>Examples</b><br>
where <br>
Displays the call stacks for all threads in the current p/t set, in<br>aggregated form. A maximum of 20 levels is shown per stack. <br>
[all] where <br>
Displays the call stacks for all threads involved in the target<br>program, in aggregated form. A maximum of 20 levels is shown<br>per stack. <br>
[2.1] where 1 <br>
Displays just the most recent level of the call stack corresponding<br>to thread 1 in process 2. This is used to see just the immediate<br>execution location of a thread or threads. <br>
[2.1] where -all <br>
Displays the complete call stack for thread 1 in process 2,<br>regardless of how many levels it includes. <br>
where 1 -args <br>
Displays the current execution locations (one level only) of threads<br>in the current p/t set, together with the values of any arguments<br>that were passed into the current procedure(s). Output is<br>aggregated. <br>
[exec(meso3)] where 1  Displays the current execution locations of threads associated with<br>
the executable <b>meso3</b>. <br>
[1.*] where 5 <br>
The most recent five levels of the call stacks for all threads<br>involved in process 1 will be displayed. If the depth of any call<br>stack is less than five levels, all of its levels will be shown. <br>
<b>Extensions</b><br>
<b>where [ {<i>num-levels</i> | -all} ] [-args] [-u] [-g] </b><br>
-u <br>
Show only user-level procedures (suppress library/system procedures). <br>
-g <br>
Show only procedures compiled for debugging. <br>
105<br>
<hr>
<A name=106></a>HPD Version 1<br>
These options make it possible to filter out information on system and library calls, or on<br>procedures that were not compiled with the debugger flag in effect. <br>
<b>Examples</b><br>
where -all -u  Displays the complete call stacks for all processes/threads in the current set,<br>
suppressing information on any system or library calls. <br>
where -all -g  Displays the complete call stacks for all processes/threads in the current set,<br>
showing only those procedures that were compiled to generate debugging<br>information. <br>
<b>up - Move up one or more levels in the call stack <br>down - Move down one or more levels in the call stack </b><br>
<b>up [<i>num-levels</i>] </b><br>
<b>down [<i>num-levels</i>] </b><br>
<i>num-levels</i> <br>
Number of levels to move up or down. Defaults to one. <br>
<b>Description</b><br>
The up (down) command modifies the current frame location(s) by adding (subtracting)<br><i>num-levels</i>. Call stack movements are all relative, so up effectively &quot;moves up&quot; (or back) in the<br>call stack, to a frame that has existed longer, while down &quot;moves down&quot; in the call stack,<br>following the progress of program execution. <br>
Frame 0 is the most recent - i.e., currently executing - frame in the call stack, frame 1<br>corresponds to the procedure that invoked the currently executing one, and so on. The call<br>stack's depth is increased by one each time a procedure is entered, and decreased by one when it<br>is exited. The effect of up is to change the dynamic context - and hence the static scope of<br>symbols - of commands which follow. For example, moving up one level makes it possible to<br>access variables that are local to the procedure that called the current one. <br>
The change affects each thread in the target p/t set. Any collection of processes and threads can<br>be specified as the target set. Since set membership is evaluated immediately, however, there is<br>no significance in using a dynamic set versus a static set. <br>
This command has no effect on program state, but does modify that portion of debugger state<br>that defines the current frame. Each up (down) command updates the frame location by adding<br>(subtracting) the appropriate number of levels. <br>
106<br>
<hr>
<A name=107></a>HPD Version 1<br>
In addition, the command modifies the current list location to be the current execution location<br>for the new frame, so a subsequent list will display the code surrounding this location. Issuing<br>an up 2 command followed by a list, for instance, will display source lines centered around the<br>source location from the current routine's parent was invoked. Since it is possible for the target<br>p/t set to include more than one thread, a thread arbitration algorithm may be necessary to<br>determine what source location will be used to update the list location. <br>
The context and scope changes effected by the command remain in effect until the subsequent<br>execution of some command that modifies the current execution location (e.g., <b>step</b>), or until a<br>subsequent up or down command is issued. <br>
The command completes as soon as the appropriate frame(s) and list location have been<br>modified and that action is reported to the user. <br>
If an up (down) command is interrupted, any threads whose current frame have not yet been<br>affected will be left unaltered. Threads already affected will not be restored to their previous<br>locations, however. A message will be issued indicating to what threads the command was<br>applied. <br>
<b>Command Output</b><br>
An up (down) command normally produces no output other than error or warning messages.<br>When verbose output is in effect, the debugger prints a one-line source location, expressed in<br>terms of file (and executable, if necessary), procedure, and line for each thread in the target set.<br>If multiple threads are involved, the output will be aggregated. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
An up (down) command can be issued only after the executable(s) has been loaded. The<br>operation is only valid when applied to threads that are stopped, however, as the call stack is not<br>accessible while a thread is running or before it has begun execution. If one or more threads in<br>the target p/t set are not stopped, an error message is generated for that thread, but the current<br>frames of all stopped threads will be modified. <br>
Since the call stacks of different threads may be of different depth, it is possible to specify a<br>number of levels that exceeds the remaining depth of one or more call stacks. In this case, the<br>corresponding frame is set to the uppermost frame (i.e., the procedure that serves as the<br>executable's entry point) and a warning message is generated. <br>
<b>Examples</b><br>
107<br>
<hr>
<A name=108></a>HPD Version 1<br>
up <br>
Moves up one level in the call stack. As a result, subsequent list<br>commands will refer to the procedure that invoked this one. Affects all<br>processes/threads in the current set. <br>
[1.*] up&amp;nbsp5  The current frame for each thread involved in process 1 will be moved up<br>
five levels in the call stack. A warning will be displayed if any of the threads<br>has fewer than five levels in its stack. <br>
[2.1] down <br>
Moves down one level in the call stack(s) for thread 1 in process 2,<br>adjusting the value of the current list location so that subsequent list<br>commands will refer to the procedure called by this one. <br>
<b>what - Determine what a target program name refers to </b><br>
<b>what <i>symbol-name</i> [-all] </b><br>
-all <br>
Show information on all symbols (from all scopes) that correspond to this name <br>
<i>symbol-name</i> <br>
Fully or partially qualified symbol name, specifying a variable, procedure, or other source<br>code symbol. <br>
<b>Description</b><br>
The what command queries the debugger about its current interpretation of a symbol name from<br>the target program. Intuitively, the command shows what program symbol(s) would be<br>displayed (modified) if the symbol name were used as the argument of a print command<br>(assign command). The argument may be any symbol name - fully qualified, partially qualified,<br>or without qualifiers - corresponding to a source program entity. (To view information on<br>symbols associated with debugger state variables, user-defined commands, or p/t sets, it will be<br>necessary to use the set command, alias command, or viewset command, respectively.) <br>
The target p/t set constrains the query to a particular dynamic context(s). To obtain information<br>on what the symbol name means in terms of the current p/t set, the name is used with no<br>qualification and no p/t set prefix. Addition of a prefix applies the query to the symbol(s)<br>corresponding to the current execution location(s) of the specified threads. <br>
By fully or partially qualifying the name of the symbol, the user can restrict the query to a<br>particular static scope (e.g., a particular source code file, procedure, or block). The -all option<br>indicates that the debugger should produce a comprehensive list showing all interpretations of<br>the name in all scopes. <br>
This command has no effect on debugger state or program state. It completes when the<br>appropriate debugging information has been searched and all matching symbols displayed. <br>
108<br>
<hr>
<A name=109></a>HPD Version 1<br>
The display of lengthy command output can be stopped at any time by issuing the user interrupt<br>key; this terminates the command, but has no effect on program or debugger state. <br>
<b>Command Output</b><br>
The what command displays information on all symbols that match the specified name,<br>including: <br>
symbol name, qualified to sufficient levels that it unambiguously identifies the static scope<br>in which the symbol is defined (typically, the file and procedure levels suffice; occasionally<br>the executable or block is needed as well). <br>symbol attributes, indicating at least the data type or general function of the name. In the<br>case of a program variable, this might be a copy of the variable's declaration; for a<br>procedure, it might be a list of the arguments and their types, return value type, etc. <br>
The output will be aggregated. <br>
<b>Recommended Practice:</b> As a convenience to users, implementors are encouraged to<br>format set list elements in a form so that fully qualified symbols can be cut-and-pasted into<br>other commands. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A what command can be issued only after the executable(s) has been loaded. If a thread's<br>dynamic context is needed to resolve the identity of the symbol, the operation is only valid when<br>applied to threads that are stopped (as the context is not accessible while a thread is running or<br>before it has begun execution). The operation also fails if the specified symbol cannot be found<br>within the scope of search. If any of these circumstances occur, an error message is generated<br>for the offending thread, but the operation continues for other threads. <br>
<b>Recommended Practice:</b> If the user constrained the scope of search by including a<br>process/thread set modifier or by qualifying the symbol, implementators are encouraged to<br>search other scopes as well. If the symbol is found, the message will be in the form of a<br>warning, rather than an error, to let the user know that a better-formulated qualification<br>will result in search success. <br>
<b>Examples</b><br>
109<br>
<hr>
<A name=110></a>HPD Version 1<br>
[1.*] what arrayx <br>
Lists the occurrences of <b>arrayx</b> that are currently visible to<br>each thread in process 1 (determined on the basis of<br>dynamic context). <br>
what #meso3#ffts.c#arrayx <br>
Lists the occurrences of <b>arrayx</b> that are within file <b>ffts.c</b> of<br>executable <b>meso3</b>. <br>
what #meso3#inv_ffts#arrayx  Lists any occurrence of <b>arrayx</b> visible within procedure<br>
<b>inv_ffts</b> in executable <b>meso3</b>. <br>
what #meso3#ffts.c#1#arrayx  Lists any &quot;file-level&quot; (shared) variable <b>arrayx</b> within the file<br>
<b>ffts.c</b> in executable <b>meso3</b>. <br>
what [1.2#5]arrayx <br>
Lists any occurrence of <b>arrayx</b> that is visible within the<br>context of the current execution location in call stack frame<br>5 of thread 1.2. <br>
[1.*] what [1.2#5]arrayx <br>
Same result - the context in a contextually qualified name<br>takes precedence over the context implied by a p/t set<br>prefix. <br>
what arrayx -all <br>
Lists all known occurrences of the symbol name <b>arrayx<br></b>corresponding to any portion of the target program. <br>
<b>HPD Command Descriptions</b><br>
<b>2.5 Data Display and Manipulation</b><br>
Working Version 2.1 - last revised Dec. 29, 1997 <br>
<i>Comments and requests for clarification are welcome. They should be submitted to<br>hpd-comments@ptools.org.</i> <br>
This chapter outlines basic operations related to data display and modification. Such operations<br>are minimal in the HPD Version 1 standard, and are expected to be amplified in future versions.<br>The scope of the standard also restricts us to text-based displays, although it is clear that textual<br>formats are unwieldy for data sets of any significant size or complexity. <br>
Two operations supporting data display and manipulation are available: <br>
print: evaluate an expression or program variable and display the resulting value <br>assign: change the current value of a program variable - <b>cannot be used in core-file<br>debugging</b> <br>
Either operation can be applied to multiple threads. The target p/t set establishes which threads<br>are involved. It can be specified explicitly through the use of a p/t set prefix; in the absence of a<br>prefix, the target set defaults to the current p/t set. <br>
110<br>
<hr>
<A name=111></a>HPD Version 1<br>
<b>print - Evaluate and display the value of a program variable or expression </b><br>
<b>print <i>expression</i> [-name] [-index] [-format <i>format-spec</i>] </b><br>
<i>expression</i> <br>
The source language expression to be evaluated and printed. <br>
-name <br>
Indicates that variable and field names should also be printed. <br>
-index <br>
Indicates that array indices should also be printed. <br>
<i>format-spec</i> <br>
An output format descriptor, using one of the following codes: <br>
f[<i>w</i>][<i>.d</i>] - signed decimal floating point; default for real <br>e[<i>w</i>][<i>.d</i>][E <i>e</i>] - signed exponential floating point <br>d[<i>w</i>] - decimal integer; default for integer <br>x[<i>w</i>] - hexadecimal; default for pointer values <br>o[<i>w</i>] - octal <br>b[<i>w</i>] - binary <br>u[<i>w</i>] - unsigned decimal integer <br>l - logical; default for Boolean types <br>c - unsigned char; default for character <br>s - string; default for character arrays <br>
(HPD Version 1 does not define format specifiers for structures.) <br>
<b>Description</b><br>
The print command evaluates and displays an expression. The debugger interprets the<br>expression by looking up the value(s) associated with each symbol and applying the operators.<br>The result of an expression may be a scalar value or an aggregate (array, array slice, record, or<br>structure). <br>
Format and layout options allow the user to exercise some control over the appearance of<br>command output. By default, the length and format of the result will be inferred from its data<br>type, as dictated by the current language(s). <br>
<b>Recommended Practice:</b> Implementors are encouraged to format pointer addresses<br>output in such a way that they may be cut and pasted into other commands. <br>
The -format option is used to override the default formatting. For example, a character array<br>would normally be displayed as a single string; in order to see the values one character at a time,<br>-format c would be necessary. <br>
The <i>w</i> specifier is used to define a total field width for displaying numbers; this width includes<br>
111<br>
<hr>
<A name=112></a>HPD Version 1<br>
any sign, decimal point, etc. The <i>d</i> specifier defines the number of decimal (fractional) digits for<br>displaying floating-point numbers. A third specifier, <i>e</i>, is used to define the number of exponent<br>digits to display. If the value specified is too small to accommodate the number (e.g., using d4<br>when the value is -1234, the specifier will be ignored and the full value printed. If the value is<br>larger than needed, the number will appear right-justified (for integers) or left-justified (floating<br>point) in a field of the specified width. For example, the value -1024.5 would exactly fit the<br>option -format f7.1, or appear as -0.10245E4 with two trailing blanks if the option were<br>-format e12.5 or -format e12.5E2. <br>
The format specifiers x, b, and o may be applied to an expression of any data type. Format<br>specifiers that do not match the expression type may be applied only if the current language<br>provides rules for coercing the result to the specifier's type; alternatively, a type cast operator<br>can be included as part of the expression. <br>
<b>Recommended Practice:</b> Implementors are encouraged to improve the readability of<br>hexadecimal, octal, and binary output by grouping digits into byte or word groups,<br>separated by blank spaces. <br>
The -name option specifies that the symbol name of each symbol in the expression be printed, in<br>addition to the expression's value. The name will be qualified to sufficient levels that it<br>unambiguously identifies the static scope (or the dynamic context, implicitly identifies a single<br>scope) in which the symbol is defined (typically, the file and procedure levels suffice;<br>occasionally the executable or block is needed as well). <br>
The -index option can be used with array expressions (i.e., expressions returning an array as<br>the result) to specify that the indices corresponding to each element of the array be printed just<br>prior to the element's value. It does not affect the display of other types of expressions. <br>
Any static set or dynamic set can be used as the target p/t set for this operation. When the set<br>includes more than one thread, the expression is evaluated within the dynamic context of each<br>member thread. Note that in this case, it is possible that a particular symbol name may refer to<br>different variables in different threads, or even be out of scope for some thread(s). The user will<br>be notified of this event, but the operation will complete normally. <br>
The print command completes as soon as the appropriate data have been accessed and<br>evaluated and the results reported to the user. It has no effect on program state or debugger<br>state. <br>
Since a considerable amount of output can be generated, the output display can be stopped at<br>any time by issuing the user interrupt key; this terminates the command, but has no other effect<br>on program or debugger state. <br>
<b>Command Output</b><br>
A scalar result is printed on a single line. Inclusion of -name specifies that the expression - with<br>any symbol name(s) expanded to identify its static scope - be displayed prior to the value of the<br>
112<br>
<hr>
<A name=113></a>HPD Version 1<br>
result: <br>
        <i>[name =]</i> <i>value</i><br>
Structure output appears with one field printed per line. Specification of -name causes each field<br>to be labeled with its member name. In addition, the structure name is printed as the first line of<br>output. For example: <br>
        <i>[structure-name =]<br></i>         <i>[field-name =]</i> <i>value</i><br>
         ...<br>
If the expression result is an array or array slice, the results will appear in multi-column<br>(table-like) output, in the order dictated by the current language; that is, column-major order for<br>Fortran, row-major order for C and C++. When -name is specified, the array values will be<br>preceded by the symbol name, printed on a separate line. If -index is included, the indices for<br>each array member will be printed; thus, columns of array indices will alternate with columns of<br>array values. For example: <br>
        <i>[array-name =]<br></i>         <i>[indices]</i>    <i>value</i>    <i>[indices]</i>    <i>value</i><br>
         ...<br>
When the values of consecutive array elements or record/structure fields are identical, their<br>output will be aggregated to conserve space. In this case, the values will be identified by names<br>(and indices, for arrays), regardless of whether or not the corresponding option has been<br>specified. <br>
Each expression is evaluated in the context of each thread in the target p/t set. When the<br>command applies to multiple threads, their expression results are aggregated prior to display,<br>with each result preceded by a string identifying the processes/threads to which it corresponds.<br>Thus, the overall format of print output is as follows: <br>
        <i>first process/thread group</i><b>:<br></b>           <i>expression result</i><br>
        <i>second process/thread group</i><b>:<br></b>           <i>expression result</i><br>
        ...<br>
        <i>last process/thread group</i><b>:<br></b>           <i>expression result</i><br>
<b>Errors, Warnings, and Diagnostics</b><br>
A print command whose expression is limited to constants may be issued at any time after the<br>executable(s) has been loaded. If the expression includes symbol names, however, data values<br>may or may not be valid while a thread is running or before it has begun execution (depending<br>on the implementation) so it may or may not be possible to evaluate the expression. For<br>
113<br>
<hr>
<A name=114></a>HPD Version 1<br>
implementations that restrict symbol evaluation to stopped threads, only the results of<br>expressions for stopped threads will be displayed, and a warning will be issued naming the<br>threads for which no results are available. <br>
The specification of a syntactically incorrect expression, or one combining mismatched types and<br>formats (according to the evaluation rules of the current language) will result in an error. An<br>appropriate message will be generated and the operation will abort. To the extent possible, the<br>debugger will also generate errors when attempts are made to illegally access regions of<br>memory, such as de-referencing an obsolete pointer value or naming an array element that is<br>out-of-bounds. <br>
When one or more symbols are determined to be out of scope for some thread, or when they<br>evaluate to different scopes for different threads, a warning message will be issued, but<br>evaluation will proceed for other threads in the target set. <br>
<b>Examples</b><br>
print scalar_y <br>
Displays the values of variable <b>scalar_y</b> known to all<br>processes/threads in the current set, aggregating them<br>wherever consecutive threads have identical values. <br>
print 100 -format x <br>
Displays the value 100 in hexadecimal format, yielding<br><b>64</b>. Only one copy of the value is printed, regardless<br>of the size of the current process/thread set, due to<br>aggregation of output. <br>
print 100. -format f3.2 <br>
Displays the value 100 in floating-point format,<br>yielding <b>100.00</b>. The decimal point in <b>100.</b> is required,<br>unless the current language provides automatic<br>coercion of integers to floating-point values. <br>
print (float)100 -format f3.2 <br>
Displays the value 100 in floating-point format,<br>yielding <b>100.00</b>. Explicit type-casing is used to<br>convert from an integer to a floating-point value. <br>
[1.*] print scalar_y <br>
Displays the aggregated values of variable <b>scalar_y<br></b>for just the threads in process 1. <br>
[1.2] print arrayx <br>
Displays the aggregated values of the array <b>arrayx</b> for<br>just the second thread in process 1. Values will be<br>printed in multiple columns to conserve space. <br>
[1.2] print arrayx -name -index  Displays the aggregated values of the array <b>arrayx</b> for<br>
just the second thread in process 1. Values will be<br>labeled with the name of the array and the indices. <br>
[1.2] print ffts.c#field2 -name Displays the aggregated values of the structure <b>field2</b><br>
in file <b>ffts.c</b>, for just the second thread in process 1.<br>Values will be labeled with the name of the structure<br>and its fields, <br>
114<br>
<hr>
<A name=115></a>HPD Version 1<br>
<b>assign - Change the value of a scalar program variable </b><br>
<b>assign <i>scalar-target</i> <i>scalar-value</i> [-force] </b><br>
<i>scalar-target</i> <br>
A reference to a scalar location in the target program. This must be an LHS expression. <br>
<i>scalar-value</i> <br>
A source-language expression that evaluates to a scalar value. <br>
-force <br>
Perform the assignments even if they refer to different target variables in different threads. <br>
[Not available for core-file debugging] <br>
<b>Description</b><br>
The assign command evaluates a scalar expression and uses the result to replace the previous<br>contents of a program variable. The target location may be a scalar variable, an element of an<br>array or structure/record, or a de-referenced pointer variable. <br>
The debugger interprets each symbol name in the expression according to the current dynamic<br>context. When the data type of the resulting value is incompatible with that of the target<br>location, type-casting must be used to accomplish the appropriate conversion. <br>
The target of the assignment must be a scalar varia ble (see Extensions). The assignment is<br>performed for each thread in the target p/t set, which may refer to any static set or dynamic set.<br>When the expression is formed entirely of constants, the same value will be stored at all<br>locations. <br>
If one or more symbol names are used, these are evaluated on a thread-by-thread basis. It is<br>possible for the name specified as the target of the assignment to refer to different static scopes -<br>or even be out of scope - with respect to different threads. In this case, the debugger's response<br>depends on the level of error-checking in effect. If ERROR_CHECKS is set to NORMAL (the default)<br>or MAX, the user will be prompted for confirmation before this possibly irreversible operation<br>takes place. If error-checking is MIN, the assignment will take place without confirmation. <br>
The -force option is used to override these protective mechanisms. If included, the debugger<br>performs the assignment, regardless of the level of error-checking in effect. <br>
The assign command completes as soon as the expression(s) has been evaluated and the result<br>converted if necessary and stored in the appropriate location(s). This clearly affects program<br>state, but does not alter debugger state. If the command is interrupted, no further evaluation or<br>store operations are carried out. Some locations may already have been modified, however, or<br>may be in an undefined state because the operations did not complete. <br>
115<br>
<hr>
<A name=116></a>HPD Version 1<br>
<b>Command Output</b><br>
An assign command normally produces no output. If the target of the assignment refers to<br>different variables in different threads, the user is prompted for confirmation of the operation<br>before it occurs; if the -force option is in effect, this message does not appear. <br>
When verbose output is in effect, the debugger prints the thread identifier and the value that was<br>stored for that thread. If multiple threads are involved, the output will be aggregated. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
An assign command may be issued at any time after the executable(s) has been loaded, except<br>that it cannot be applied when debugging a core-file. The operation is valid only for threads that<br>are stopped, as data locations cannot be modified while a thread is running or before it has<br>begun execution. If all processes and threads in the current set are not stopped, an error message<br>is generated, and no locations are modified. <br>
It is illegal to attempt an assignment that includes a syntactically incorrect expression or uses an<br>aggregate as either the source or target of the operation (see Extensions). It is also an error<br>when the data type of the expression result is incompatible with that of the target location. In<br>these cases, an appropriate error message will be generated and the operation will abort. <br>
When one or more expression symbols are determined to be out of scope for some thread, or<br>when a given symbol is ambiguous (i.e., refers to more than one scope), a warning message will<br>be issued, but the operation will continue for other threads in the target set. <br>
If the target of the assignment refers to different static scopes or is out of scope for some thread,<br>the debugger will prompt the user before continuing with the operation. The prompting will be<br>suppressed only if the debugger state variable ERROR_CHECKS has been set to MIN. <br>
<b>Examples</b><br>
assign scalar_y -102 <br>
Stores the value -102 in each occurrence of variable<br><b>scalar_y</b> for all processes/threads in the current set. Assumes<br>the target is an integer. <br>
[1.*] assign scalar_y -102  Stores the value -102 in each occurrence of variable<br>
<b>scalar_y</b> for just the threads in process 1. <br>
assign scalar_y 2.0 <br>
Stores the floating-point value <b>2.0</b> in each occurrence of<br>variable <b>scalar_y</b> for all threads in the current set. Note that<br>this assumes the target is a variable declared to be of type<br><b>float</b>. <br>
<b>Extensions</b><br>
<b>assign <i>target</i> <i>value</i> [-force] </b><br>
116<br>
<hr>
<A name=117></a>HPD Version 1<br>
<i>target</i> <br>
A symbol name referring to a target program scalar, array, or array slice. <br>
<i>value</i> <br>
An expression that evaluates to a scalar value or array value equal to the <b>target</b> in both<br>number of dimensions and extents of those dimensions. <br>
-force <br>
Perform the assignments even if they refer to different target variables in different threads. <br>
Extends the semantics of assign to include simple array assignments, subject to the following<br>restrictions: <br>
Assigning a scalar to an array copies the scalar value to all members of the array; in effect,<br>it is equivalent to a separate assignment command for every array element, with the same<br>value for each. <br>Assigning an array to an array copies corresponding elements between the arrays. To<br>ensure that &quot;corresponding&quot; is unambiguous, HPD Version 1 requires that the target and<br>value have the same number of dimensions and extent in each dimension. In effect, an array<br>assignment is equivalent to a series of assignments where the target and values both iterate<br>through their arrays in the same order. <br>
<b>HPD Command Descriptions</b><br>
<b>2.6 Execution Control</b><br>
Working Version 2.1 - last revised Sept. 21, 1998 <br>
<i>Comments and requests for clarification are welcome. They should be submitted to<br>hpd-comments@ptools.org.</i> <br>
Commands governing the control of the target program's execution are defined in this chapter. It<br>should be noted that the HPD Version 1 standard does not require that the debugger support<br>control over individual threads - such functionality is specified in the form of extensions to the<br>standard. The required commands, then, restrict the user to starting and stopping whole<br>processes (i.e., all threads associated with a given process). <br>
The following functionality is provided for controlling execution. Since all affect program state,<br>none of these commands can be used in core-file debugging. <br>
step: execute statement(s) <br>
stepping into called procedures <br>stepping over embedded procedure calls <br>
117<br>
<hr>
<A name=118></a>HPD Version 1<br>
up to the end of the current procedure <br>
go: resume execution of processes (without blocking) <br>halt: suspend execution of processes <br>cont: continue execution of processes, blocking further commands <br>wait: block command input until processes stop <br>
Any of these operations can be applied to multiple threads. The target p/t set establishes which<br>threads are involved. It can be specified explicitly through the use of a p/t set prefix; in the<br>absence of a prefix, the target set defaults to the current p/t set. <br>
<b>step - Execute statement(s) by a specific process/thread </b><br>
1. Execute one or more statements by a specific process/thread <br>
<b>step [<i>repeat-count</i>] </b><br>
2. Execute one or more statements, stepping around procedure calls <br>
<b>step [<i>repeat-count</i>] -over </b><br>
3. Execute to end of current procedure <br>
<b>step -finish </b><br>
<i>repeat-count</i> <br>
An integer value greater than zero, indicating the number of statements that should be<br>executed. Defaults to 1. <br>
-over <br>
Steps around invocations of procedures. Default is to step into each function or subroutine<br>as it is invoked. <br>
-finish <br>
Steps to the end of the current procedure. The thread will stop after it executes the<br>appropriate <b>return</b> statement. <br>
[Not available for core-file debugging] <br>
<b>Description</b><br>
The step command resumes execution of a single thread, advancing it by the specified number<br>of statements. Note that due to the thread model supported by threads-only debuggers and<br>multilevel debuggers, the step command affects the entire process containing the thread to be<br>stepped. Thus, while only one thread will be stepped forward, all other threads contained in the<br>same process will resume executing in an unrestricted fashion (see Extensions). <br>
The target p/t set must contain just one thread. The affected set is derived from this, and<br>includes all threads belonging to the same process as the specified thread. <br>
118<br>
<hr>
<A name=119></a>HPD Version 1<br>
The precise meaning of &quot;advancing a statement&quot; may be implementation-dependent, as the<br>debugger relies on compiler information about the starting locations for statements. Intuitively, a<br>statement corresponds to an executable statement, which may span one or more lines in the<br>source code. <br>
When a <i>repeat-count</i> is specified, it indicates that execution of the thread should advance by<br>that number of statements, rather than just a single statement. <br>
Inclusion of -over specifies that any subroutine or function call should be treated as &quot;a single<br>statement&quot;. When this argument is not present, execution actually enters the procedure and steps<br>through its statements. <br>
The -finish option indicates that execution should continue up to, and including, the return<br>statement that causes the current procedure to finish. <br>
The step command alters program state by changing the state of the target thread to <b>running</b>,<br>after establishing an implicit breakpoint after the appropriate number of statements. The state of<br>all other threads in the affected set is changed to <b>running</b> as well. Since no implicit breakpoint is<br>established for these threads (see Extensions), their state will then be subject to the normal<br>changes caused by execution. They may advance many statements before their execution is<br>halted. <br>
Only threads that are currently in the <b>stopped/runnable</b> state can actually be changed to<br><b>running</b>. Program state will be unaffected for any thread(s) that is already running, held at a<br>barrier, etc. <br>
The command completes once the thread being stepped has advanced the specified number of<br>statements. The implicit breakpoint then causes the debugger to halt any other threads contained<br>in the same process. At the end of the operation, the entire process is in the <b>stopped/runnable<br></b>state. <br>
The step command may be interrupted by the user interrupt key. Threads-only and multilevel<br>debuggers will respond by halting any threads that were resumed simply because they belonged<br>to the same process as the thread being stepped. (In some implementations - such as those<br>where debugger control directives must be transmitted across a network - the process of halting<br>threads may be time-consuming; if so, the user may choose to issue a second interrupt during<br>this period, causing the debugger to abort its attempt to halt any remaining threads.) The<br>debugger will issue a message indicating how many threads in the affected set are currently<br>stopped and how many are running. Note that an explicit halt command may be needed in<br>order to stop those that continue running. <br>
<b>Command Output</b><br>
A step command normally produces no output other than error or warning messages. When the<br>operation has been interrupted by the user and verbose output is in effect, the debugger displays<br>the current source location of the thread that was being stepped. <br>
119<br>
<hr>
<A name=120></a>HPD Version 1<br>
<b>Errors, Warnings, and Diagnostics</b><br>
A step command cannot be applied when debugging a core-file, nor can it be issued before an<br>executable is loaded and execution has been initiated. The target p/t set must have only one<br>member - the thread to be stepped - and it must currently be <b>stopped/runnable</b>; if not, the<br>operation fails. If any of these errors occurs, the operation is aborted and an appropriate<br>message is generated. <br>
If the debugger is unable to step the specified thread, or to resume the stopped process, an<br>appropriate diagnostic will be displayed. <br>
<b>Examples</b><br>
step <br>
For the single thread in the current p/t set, execute the next statement,<br>stepping into any procedure call that is encountered. For threads-only<br>and multilevel debuggers, simultaneously resume execution of all other<br>threads in the containing process; they are halted once the stepping<br>thread has executed its statement. (This command generates an error if<br>the current set includes multiple threads.) <br>
[1.2] step <br>
Step thread 2 in process 1 by one statement. For threads-only and<br>multilevel debuggers, simultaneously resumes execution of all other<br>threads in process 1; they are halted once thread 1.2 has executed its<br>statement. <br>
[1.2] step 5 -over  Steps thread 2 in process 1 forward by five statements, counting any<br>
procedure invocations as &quot;single statements&quot;. Other threads behave as<br>described previously.<br>
[1.2] step -finish  Steps thread 2 in process 1 through the end of the procedure it is<br>
currently executing. Other threads behave as described previously. <br>
<b>Extensions</b><br>
1. Execute one or more statements by a single thread <br>
<b>step [{<i>repeat-count</i> | <i>repeat-count</i> -over | -finish | -over}] </b><br>
2. Execute one or more statements by specific processes/threads (&quot;parallel step&quot;) <br>
<b>step [{<i>repeat-count</i> | <i>repeat-count</i> -over | -finish | -over}] [-waitany] </b><br>
<i>wait-any</i> <br>
In a parallel step operation, returns a prompt to the user after any one process/thread in the<br>target set has completed its step. By default, control is not returned until all threads have<br>completed their stepping. <br>
[Not available for core-file debugging] <br>
120<br>
<hr>
<A name=121></a>HPD Version 1<br>
Extends the semantics of step so that individual threads can be stepped without automatically<br>resuming the other threads in that process, and/or so that multiple processes/threads may be<br>stepped at one time. <br>
The first extension requires that the debugger variable START_MODEL be examined. If its value is<br>ANY, only the thread specified in the target set is stepped; other threads in the same process are<br>unaffected. If its value is ALL, the other threads in that process resume execution, as described<br>under the required version of the command. It is expected that debuggers supporting this<br>extension will assign the default value of ANY to the debugger variable. <br>
The second extension may be implemented independently of the first. It allows the target p/t set<br>to include more than one thread, so that multiple threads perform step operations in parallel.<br>When -waitany is specified, a prompt is returned to the user as soon as any thread has<br>completed the step. Otherwise, control returns only after all stepping has completed. <br>
If only the second extension is implemented, each thread in the target set must belong to a<br>different process, and all threads in the same process as any target thread will resume execution<br>while the thread is stepping (as in the required version of the command). <br>
<b>Examples</b><br>
[1.2] step <br>
Step thread 2 in process 1 by one statement. When START_MODEL is<br>set to ANY&gt;, only that one thread will be affected. For threads-only<br>and multilevel debuggers, when its value is ALL, the command<br>simultaneously resumes execution of all other threads in process 1;<br>they are halted once thread 1.2 has executed its statement. <br>
[1.2,3.2] step <br>
Steps threads 2 in processes 1 and 3. The behavior of other threads<br>in those processes is governed by START_MODEL, as described<br>previously. Control returns to the user after both threads have<br>completed their stepping (and if appropriate, after other threads in<br>those processes have been halted). <br>
[1:3.2] step -waitany  Steps thread 2 in processes 1, 2 and 3, but returns a prompt to the<br>
user as soon as any of the threads has completed its step operation.<br>The behavior of other threads in those processes is governed by<br>START_MODEL, if that extension is implemented. Otherwise, they are<br>resumed and halted as in the required version of the command. <br>
<b>go - Resume execution of target process(es) </b><br>
<b>go </b><br>
[Not available for core-file debugging] <br>
121<br>
<hr>
<A name=122></a>HPD Version 1<br>
<b>Description</b><br>
The go command resumes execution of a collection of processes. The prompt will then be<br>returned so that the user can issue further commands; execution continues behind the scene. <br>
The target process set may be any static set, or a dynamic set of the form <i>process</i>.*, all, or<br>exec(<i>executable</i>). These are the permissible values for the target p/t set when the command is<br>issued. Note that due to the thread model supported by threads-only debuggers and multilevel<br>debuggers, the go command applies to entire process(es), not to individual threads (see<br>Extensions). Thus, if a single thread serves as the target set, the debugger will apply the<br>operation to a target process set containing all threads in the same process as that thread. <br>
The command has no arguments. <br>
The go command alters program state by changing the state of all process(es) in the affected set<br>to <b>running</b>. Only threads that are currently in the <b>stopped/runnable</b> state can actually be<br>changed in this way, however. Program state will be unaffected for any thread(s) that is already<br>running, held at a barrier, etc. <br>
The command completes once execution of the appropriate threads has been resumed. From that<br>point on, the state(s) of the thread(s) will be subject to the normal changes caused by execution. <br>
If a go command is interrupted by the user interrupt key, the debugger prints a message<br>indicating whether or not the operation succeeded as requested. If not, the message indicates the<br>number of threads for which it failed. Note that any resumed processes will continue running; a<br>halt command will be needed in order to stop them. <br>
<b>Command Output</b><br>
A go command normally produces no output other than error or warning messages. When the<br>operation has been interrupted by the user and verbose output is in effect, the debugger lists<br>each thread for which the resumption operation was not successful. This output will be<br>aggregated. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A go command cannot be applied when debugging a core-file, nor can it be issued before an<br>executable is loaded and execution has been initiated. The target p/t set is also restricted, in that<br>the only permissible dynamic sets are <i>process</i>.*, all, or exec(<i>executable</i>). If any of these<br>errors occurs, the operation is aborted and an appropriate message is generated. <br>
If the affected set is empty, or if one or more threads in the set are not currently<br><b>stopped/runnable</b>, the debugger issues a warning message, but continues applying the<br>operation to any other threads in the set. <br>
If the debugger is unable to resume the specified threads, an appropriate diagnostic will be<br>
122<br>
<hr>
<A name=123></a>HPD Version 1<br>
displayed. <br>
<b>Examples</b><br>
go <br>
Resume execution of all <b>stopped/runnable</b> threads belonging to processes in<br>the current p/t set. (Threads held at barriers are not affected.) A prompt is then<br>returned so the user can continue issuing commands. <br>
[border] go  Resume execution of all <b>stopped/runnable</b> threads belonging to processes in<br>
the user-defined set <b>border</b>. <br>
[1.2] go <br>
Resume execution of all <b>stopped/runnable</b> threads belonging to process 1.<br>Note that this is the same as [1.*] go. <br>
<b>Extensions</b><br>
<b>go </b><br>
[Not available for core-file debugging] <br>
Extends the semantics of go so that an individual thread(s) may be resumed, without<br>automatically resuming the entire process containing it. Thus, the affected set contains exactly<br>the members of the target p/t set. <br>
This extension requires that the debugger variable START_MODEL be examined. If its value is ANY,<br>only the thread specified in the target set is resumed; other threads in the same process are<br>unaffected. If its value is ALL, the other threads in that process resume execution, as described<br>under the required version of the command. It is expected that debuggers supporting this<br>extension will assign the default value of ANY to the debugger variable. <br>
<b>halt - Suspend execution of target process(es) </b><br>
<b>halt </b><br>
[Not available for core-file debugging] <br>
<b>Description</b><br>
The halt command temporarily suspends the execution of a collection of processes. <br>
The target process set may be any static set, or a dynamic set of the form <i>process</i>.*, all, or<br>exec(<i>executable</i>). These are the permissible values for the target p/t set when the command is<br>issued. Note that due to the thread model supported by threads-only debuggers and multilevel<br>debuggers, the halt command applies to entire process(es), not to individual threads (see<br>Extensions). Thus, if a single thread serves as the target set, the debugger will apply the<br>
123<br>
<hr>
<A name=124></a>HPD Version 1<br>
operation to a target process set containing all threads in the same process as that thread. <br>
The command has no arguments. <br>
The halt command alters program state by changing the state of all process(es) in the affected<br>set to <b>stopped/runnable</b>. Only threads that are currently in the <b>running</b> state can actually be<br>changed in this way, however. Program state will be unaffected for any thread(s) that is already<br>stopped, held at a barrier, etc. <br>
The command completes once execution of the appropriate threads has been halted. <br>
If a halt command is interrupted by the user interrupt key, the debugger prints a message<br>indicating for how many threads it has succeeded. Note that any other processes will continue<br>running. <br>
<b>Command Output</b><br>
A halt command normally produces no output other than error or warning messages. When the<br>operation has been interrupted by the user and verbose output is in effect, the debugger lists the<br>status of each thread in the affected set. This output will be aggregated. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A halt command cannot be applied when debugging a core-file, nor can it be issued before an<br>executable is loaded and execution has been initiated. The target p/t set is also restricted, in that<br>the only permissible dynamic sets are <i>process</i>.*, all, or exec(<i>executable</i>). If any of these<br>errors occurs, the operation is aborted and an appropriate message is generated. <br>
If the affected set is empty, or if one or more threads in the set are not currently <b>running</b>, the<br>debugger issues a warning message, but continues applying the operation to any other threads in<br>the set. <br>
If the debugger is unable to halt the specified threads, an appropriate diagnostic will be<br>displayed. <br>
<b>Examples</b><br>
halt <br>
Suspend execution of all <b>running</b> threads belonging to processes in the current<br>p/t set. (Threads held at barriers are not affected.) <br>
[1.2] halt  Suspend execution of all <b>running</b> threads belonging to process 1. Note that this<br>
is the same as [1.*] halt. <br>
<b>Extensions</b><br>
<b>halt </b><br>
124<br>
<hr>
<A name=125></a>HPD Version 1<br>
[Not available for core-file debugging] <br>
Extends the semantics of halt so that an individual thread(s) may be stopped, without<br>automatically halting the entire process containing it. Thus, the affected set contains exactly the<br>members of the target p/t set. <br>
This extension requires that the debugger variable START_MODEL be examined. If its value is ANY,<br>only the thread specified in the target set is stopped; other threads in the same process are<br>unaffected. If its value is ALL, the other threads in that process are halted, as described under the<br>required version of the command. It is expected that debuggers supporting this extension will<br>assign the default value of ANY to the debugger variable. <br>
<b>cont - Resume execution of target process(es), blocking command input </b><br>
<b>cont [-waitany] </b><br>
-waitany <br>
Command will block only until some process in the target set has stopped. Not needed in<br>threads-only debugging. <br>
[Not available for core-file debugging] <br>
<b>Description</b><br>
The cont command resumes execution of a collection of processes, blocking further command<br>input until those processes have reached stopping points due to the triggering of actionpoints,<br>termination, etc. The prompt is then returned. <br>
The target process set may be any static set, or a dynamic set of the form <i>process</i>.*, all, or<br>exec(<i>executable</i>). These are the permissible values for the target p/t set when the command is<br>issued. Note that due to the thread model supported by threads-only debuggers and multilevel<br>debuggers, the cont command applies to entire process(es), not to individual threads (see<br>Extensions). Thus, if a single thread serves as the target set, the debugger will apply the<br>operation to a target process set containing all threads in the same process as that thread. <br>
When the -waitany option is specified, the command blocks only until some process, not the<br>whole collection, has stopped. <br>
The cont command alters program state by changing the state of all process(es) in the affected<br>set to <b>running</b>. Only threads that are currently in the <b>stopped/runnable</b> state can actually be<br>changed in this way, however. Program state will be unaffected for any thread(s) that is already<br>running, held at a barrier, etc. Once execution of the appropriate threads has been resumed, their<br>state(s) will be subject to the normal changes caused by execution. <br>
125<br>
<hr>
<A name=126></a>HPD Version 1<br>
A cont command completes when all threads in the appropriate process(es) have stopped<br>executing (i.e., none of them is in the <b>running</b> state). <br>
If the command is interrupted by the user interrupt key, the debugger will begin halting any<br>threads that have already been resumed. (In some implementations - such as those where<br>debugger control directives must be transmitted across a network - the process of halting<br>threads may be time-consuming; if so, the user may choose to issue a second interrupt during<br>this period, causing the debugger to abort its attempt to halt any remaining threads.) The<br>debugger will issue a message indicating how many threads in the affected set are currently<br>stopped and how many are running. Note that an explicit halt command will be needed in order<br>to stop those that continue running. <br>
<b>Command Output</b><br>
A cont command normally produces no output other than error or warning messages. When the<br>operation has been interrupted by the user and verbose output is in effect, the debugger lists the<br>current status (including stop location, if applicable) of each thread in the target set; this output<br>will be aggregated. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A cont command cannot be applied when debugging a core-file, nor can it be issued before an<br>executable is loaded and execution has been initiated. The target set is also restricted, in that the<br>only permissible dynamic sets are <i>process</i>.*, all, or exec(<i>executable</i>). If any of these<br>errors occurs, the operation is aborted and an appropriate message is generated. <br>
If the affected set is empty, or if one or more threads in the set is <b>running</b>, the debugger issues a<br>warning message, but continues applying the operation to any other threads in the set. <br>
If the debugger is unable to resume a stopped thread, an appropriate diagnostic will be<br>displayed. <br>
<b>Examples</b><br>
126<br>
<hr>
<A name=127></a>HPD Version 1<br>
cont <br>
Resume execution of all <b>stopped/runnable</b> threads belonging to<br>processes in the current p/t set. (Threads held at barriers are not<br>affected.) The command blocks further input until all threads in all<br>target processes have stopped. A prompt is then returned so the user<br>can continue issuing commands. <br>
[1.2] cont <br>
Resume execution of all <b>stopped/runnable</b> threads belonging to<br>process 1. Note that this is the same as [1.*] cont. Command<br>input is blocked until the process stops. <br>
[1:3.2] cont<br>
Resume execution of all <b>stopped/runnable</b> threads belonging to<br>
-waitany <br>
processes 1, 2, and 3, blocking further command input until at least<br>one process has stopped. <br>
<b>Extensions</b><br>
<b>cont [-waitany] </b><br>
[Not available for core-file debugging] <br>
Extends the semantics of cont so that an individual thread(s) may be resumed, without<br>automatically resuming the entire process containing it. Thus, the affected set contains exactly<br>the members of the target p/t set. <br>
This extension requires that the debugger variable START_MODEL be examined. If its value is ANY,<br>only the thread specified in the target set is resumed; other threads in the same process are<br>unaffected. If its value is ALL, the other threads in that process resume execution, as described<br>under the required version of the command. It is expected that debuggers supporting this<br>extension will assign the default value of ANY to the debugger variable. <br>
When the -waitany option is specified, the command will block until some thread in the<br>affected set has stopped. <br>
<b>wait - Block command input until target process(es) stop </b><br>
<b>wait [-waitany] </b><br>
-waitany <br>
Blocking ends when some process in the target set has stopped. Not needed in threads-only<br>debugging. <br>
[Not available for core-file debugging] <br>
<b>Description</b><br>
127<br>
<hr>
<A name=128></a>HPD Version 1<br>
The wait command temporarily blocks command input while the debugger waits for the<br>process(es) in the affected set to reach a stopping point (due to an actionpoint, process<br>termination, etc.). The prompt is then returned. <br>
It is possible that the target program might require user input while this command is in effect.<br>Therefore, during the time that command input is blocked, the debugger automatically switches<br>to program input mode, as though the user had issued a proginput command. All typing will be<br>interpreted as input to the program - with the exception of the user interrupt key, as described<br>below. Once the wait is satisfied, the mode automatically switches back to debugger input. <br>
The affected set is derived from the target p/t set. It may be any static set, or a dynamic set of<br>the form <i>process</i>.*, all, or exec(<i>executable</i>). These are the permissible values for the<br>target p/t set when the command is issued. Note that due to the thread model supported by<br>threads-only debuggers and multilevel debuggers, the wait command applies to entire<br>process(es), not to individual threads (see Extensions). Thus, if a single thread serves as the<br>target set, the debugger will apply the operation to a set containing all threads in the same<br>process as that thread. <br>
The -waitany option indicates that the command should terminate - that is, command input<br>should resume - as soon as some process in the affected set has reached a stopping point. <br>
The wait command does not change program state or debugger state. Rather, it waits for<br>changes to occur due to circumstances of program execution. <br>
The command completes once the appropriate processes have stopped executing (i.e., their<br>threads are no longer <b>running</b>). <br>
If a wait command is interrupted by the user interrupt key, the debugger prints a message<br>indicating for how many threads the wait was satisfied. Note that any other threads will continue<br>running. <br>
<b>Command Output</b><br>
A wait command normally produces no output other than error or warning messages. When the<br>operation has been interrupted by the user and verbose output is in effect, the debugger lists the<br>status of all threads in the affected set. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A wait command cannot be applied when debugging a core-file, nor can it be issued before an<br>executable is loaded and execution has been initiated. The target set is also restricted, in that the<br>only permissible dynamic sets are <i>process</i>.*, all, or exec(<i>executable</i>). If any of these<br>errors occurs, the operation is aborted and an appropriate message is generated. <br>
If the affected set is empty, or if all threads in the set have already stopped executing, the wait is<br>considered satisfied and a prompt is displayed for further user input. <br>
128<br>
<hr>
<A name=129></a>HPD Version 1<br>
<b>Examples</b><br>
wait <br>
Block further command input until all processes in the current p/t<br>set has stopped (that is, none of their threads are still <b>running</b>). <br>
[1:2.*] wait <br>
Block command input until both processes 1 and 2 have stopped. <br>
[1:2.*] wait -waitany  Block command input until either process 1 or process 2 has<br>
stopped. <br>
<b>Extensions</b><br>
<b>wait [-waitany] </b><br>
[Not available for core-file debugging] <br>
Extends the semantics of wait so that an individual thread(s) may be waited for, rather than an<br>entire process. Thus, the affected set contains exactly the members of the target p/t set. <br>
This extension requires that the debugger variable STOP_MODEL be examined. If its value is ANY,<br>only the thread(s) specified in the target set is waited for; other threads in the same process may<br>continue running. If its value is ALL, all threads in the process must be stopped, as described<br>under the required version of the command. It is expected that debuggers supporting this<br>extension will assign the default value of ANY to the debugger variable. <br>
When the -waitany option is specified, the wait will not be satisfied until some thread in the<br>affected set has stopped. <br>
<b>HPD Command Descriptions</b><br>
<b>2.7 Actionpoints</b><br>
Working Version 2.1 - last revised Sept. 10, 1998 <br>
<i>Comments and requests for clarification are welcome. They should be submitted to<br>hpd-comments@ptools.org.</i> <br>
The functionality associated with actionpoints is intended to help debugger users track down<br>particular kinds of bugs or find out more about the behavior of their applications. Actionpoints<br>make it possible to: <br>
Determine when a particular thread reaches a given point in its execution. <br>
129<br>
<hr>
<A name=130></a>HPD Version 1<br>
Discover what other processes/threads are doing at that point in time. <br>Examine the state of a program only after a procedure has been called a specified number<br>of times. <br>Examine the state of a program at a particular code location, but only when specific<br>variables have particular values. <br>Wait for all threads to reach the same location in the application. <br>Find out where particular global variables are being modified. <br>Find the source of wild stores into stack or heap storage being caused by a dangling<br>pointer, an uninitialized pointer, or a pointer to a local variable that has gone out of scope. <br>
Actionpoint commands are responsible for defining the points at which the flow of program<br>execution should suspend so that the user can examine debugger or program state. Basic<br>functionality includes: <br>
defining actionpoints <br>
break: define a breakpoint <br>barrier: define a barrier <br>watch: define a watchpoint <br>
actions: view information on actionpoint definitions and their current status <br>delete: delete an actionpoint <br>disable: temporarily disable an actionpoint <br>enable: re-enable an actionpoint that has been disabled <br>export: store actionpoint settings for future re-use <br><b>None of these commands can be used in core-file debugging</b> <br>
Actionpoint operations are applied to a trigger set, controlling for what threads the actionpoint<br>event is defined. The trigger set is established by the target p/t set, either in the form of an<br>explicit p/t set prefix or through its default value (the current p/t set). <br>
<b>break - Define a breakpoint </b><br>
1. Define an unconditional breakpoint <br>
<b>break {<i>proc</i> | <i>line</i> | #<i>file</i>#<i>line</i>} [-stop <i>stop-set</i>] </b><br>
2. Define a count-dependent breakpoint <br>
<b>break {<i>proc</i> | <i>line</i> | #<i>file</i>#<i>line</i>} -count <i>n</i> [-stop <i>stop-set</i>] </b><br>
3. Define a conditional breakpoint <br>
<b>break {<i>proc</i> | <i>line</i> | #<i>file</i>#<i>line</i>} -if <i>condition</i> [-stop <i>stop-set</i>] </b><br>
<i>procedure</i> <br>
Breakpoint location specified as the name of a procedure, expressed using a fully or<br>partially qualified symbol name. <br>
<i>line</i> <br>
Breakpoint location specified as a line number (in the file containing the current source<br>
130<br>
<hr>
<A name=131></a>HPD Version 1<br>
location). <br>
#<i>file</i>#<i>line</i> <br>
Breakpoint location specified as a line number preceded by a fully or partially qualified<br>symbol name denoting a source file. <br>
<i>n </i><br>
An integer value greater than zero, indicating number of times the breakpoint location must<br>be reached before it is triggered. Defaults to 1. <br>
<i>condition </i><br>
A source language expression that evaluates to true or false. <br>
<i>stop-set</i> <br>
The processes that should be suspended once the breakpoint has triggered, expressed using<br>standard process set notation. Defaults to the process where the breakpoint triggered. <br>
[Not available for core-file debugging] <br>
<b>Description</b><br>
The break command defines a breakpoint that will be triggered when some thread(s) in the<br>trigger set arrives at the specified location during program execution. When that occurs, the<br>process(es) containing the triggering thread(s) plus all processes in the stop set will be forcibly<br>stopped so the user can examine program state information. <br>
There may be multiple breakpoints defined at the same source location (e.g., naming different<br>trigger or stop sets, different conditions, etc.). Each thread stops at most once on arrival at a the<br>breakpoint location, where it is held until a resume command is issued, at which point it<br>continues executing. When a barrier is defined at the same location as a breakpoint, the barrier<br>takes precedence, so execution will continue only when the barrier has been satisfied. <br>
The first argument indicates where the breakpoint should occur. When a procedure name is<br>specified, with no line number, this is interpreted by the debugger as referring to the beginning<br>of that procedure. When an unqualified line number is used, it is assumed to refer to the file<br>associated with the current source location. <br>
The user may request a breakpoint at any line in a source file. However, the compiler might not<br>generate the appropriate debugging information to permit the debugger to stop execution at a<br>given line. This may happen, for example, because the requested line contains no executable<br>statements or because of the way the compiler generates line number information for statements<br>that span multiple lines. Therefore, the set of lines in a source file at which the debugger can<br>stop execution is implementation dependent. <br>
When the user requests a breakpoint on a line at which the debugger cannot stop execution, it<br>will be set at the next line in the source file where execution can be halted. If the user requests a<br>breakpoint beyond the last possible stopping line in the file, it is inserted at the last feasible<br>location. When reporting the status of a breakpoint, the debugger will name the location where<br>threads will actually stop. <br>
131<br>
<hr>
<A name=132></a>HPD Version 1<br>
The trigger set may be any static set or a dynamic set of the form <i>process</i>.*, all, or<br>exec(<i>executable</i>). These are the permissible values for the target p/t set when the command is<br>issued (see Extensions). <br>
The -stop option specifies the stop set for the breakpoint, and may be any target process set<br>(see Extensions), either static or dynamic. If none is specified, the default is the process(es)<br>containing the triggering thread(s). To achieve a <i>global breakpoint</i> - one that stops all processes<br>as soon as any of them has reached the breakpoint location - a stop set of [all] should be<br>specified. <br>
When a -count value is specified, the breakpoint will not trigger until the location has been<br>arrived at a total of <b>n</b> times; the count is incremented each time that any thread in the trigger set<br>reaches the breakpoint. <br>
The presence of the -if condition specifies that the breakpoint should not trigger unless the<br>condition evaluates to <b>true</b>. The condition is evaluated like any other expression; that is, the<br>dynamic context established at the time the breakpoint condition is evaluated, according to the<br>current execution location of the triggering thread. <br>
Defining a breakpoint affects debugger state, where membership in the trigger and stop sets is<br>established. Program state is not affected by the breakpoint definition, but triggering of a<br>breakpoint halts one or more processes, leaving them in the <b>stopped/runnable</b> state. Further,<br>the current execution location of the triggering thread(s) will be used to update the value of<br>$EXEC, used for the list command. <br>
A break command completes when the debugger has either rejected the command because of an<br>error, or when it has updated its internal information about actionpoints, and assigned an<br>actionpoint identifier. <br>
Once a breakpoint has triggered, the debugger suspends each process in the stop set as well as<br>the process(es) containing the triggering thread(s). It then issues the deferred output described<br>below. <br>
If the break command is interrupted by the user interrupt key, the debugger prints a message<br>indicating whether or not the operation succeeded as requested. If not, the message indicates the<br>number of threads for which it failed. <br>
<b>Command Output</b><br>
A break command normally produces no output other than error or warning messages. When<br>the operation has been interrupted by the user, and verbose output is in effect, the debugger lists<br>each thread for which the breakpoint was not set; this output will be aggregated. <br>
<b>Deferred Output</b>. After a breakpoint has triggered, the debugger issues a message showing the<br>identifier of the triggering thread(s), the breakpoint location, and the actionpoint identifier. If<br>there were multiple breakpoints defined at this source location, the output lists the actionpoint<br>
132<br>
<hr>
<A name=133></a>HPD Version 1<br>
identifiers of all breakpoints for which the condition is true or the count has been met. <br>
If verbose output is in effect, the debugger also reports the current location of each thread in the<br>stop set. All output will be aggregated. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A break command cannot be applied when debugging a core-file. The trigger (target) set is<br>restricted in two ways. First, it can only include threads that are stopped; if any of the specified<br>threads is running, the operation fails. Second, the only permissible dynamic sets are <i>process</i>.*,<br>all, or exec(<i>executable</i>). Further, a breakpoint cannot be defined for an executable that has<br>not yet been loaded. If any of these errors occurs, the operation is aborted and an appropriate<br>message is generated. <br>
When a -count option is included, it must be an integer value greater than zero, or an error<br>results. <br>
It is also an error to specify a condition that cannot be evaluated to true or false each time the<br>breakpoint is reached. This occurs if symbol names are used that do not fall within the scope of<br>the breakpoint location, or if invalid syntax is used. However, the debugger may not be able to<br>detect this in advance; the error may be deferred until some later point in execution when the<br>condition is actually evaluated. <br>
If the breakpoint location is ambiguous because the threads in the trigger set have conflicting<br>source locations, an error occurs and a message is generated indicating where the conflicting<br>locations are. <br>
Whenever the user requests that a breakpoint be set at a location that is not feasible (or at a<br>location whose line is beyond the last line at which execution can be stopped) and the debugger<br>adjusts the location, it issues a warning message to that effect. <br>
Breakpoints can have significant impact on debugger performance. If this is true for a particular<br>implementation and verbose output is in effect, the debugger will issue a diagnostic message<br>indicating in some relative way the cost of defining and detecting breakpoints. <br>
<b>Special Requirements for Documentation</b> Each implementation may elect to handle the<br>following features as valid or invalid breakpoint locations. The documentation will describe<br>how each is handled. <br>
Specifying as the breakpoint location a line that begins with a partial source statement<br>(and perhaps includes additional statements as well). <br>Specifying as the breakpoint location a line within an included file. <br>
<b>Examples</b><br>
For all examples, assume the current process set is [2] when the breakpoint is defined. <br>
133<br>
<hr>
<A name=134></a>HPD Version 1<br>
break 12 <br>
Suspend process 2 when it reaches line 12. The trigger set<br>defaults to process 2, and the stop set to the triggering<br>process (which is certain to be process 2); there is no effect<br>on other processes. <br>
[3.*] break 12 <br>
Suspend process 3 when it reaches line 12. The default<br>trigger set has been overridden, so it includes just process<br>3. The default stop set is again the triggering process; there<br>is no effect on other processes. <br>
[0:2.*] break 12<br>
Whenever any of the first three processes reaches line 12,<br>suspend it. Since the stop set is still just the triggering<br>process, the other processes will be allowed to continue<br>executing. <br>
[1.*] break 12 -stop [2] <br>
When process 1 reaches line 12, suspend it and halt<br>process 2 wherever it happens to be executing. <br>
[1:3.*] break 12 -stop [all] Whenever any of processes 1, 2, or 3 reaches line 12,<br>
suspend it and halt all other processes, wherever they<br>happen to be executing. This is an example of a global<br>breakpoint. <br>
[all] break 12 -stop [2] <br>
When any thread reaches line 12, halt all threads in the<br>process containing it, as well as all threads in process 2. <br>
[all] break 12 -stop [all] <br>
Whenever any process reaches line 12, suspend it and halt<br>each of the other processes. This is a full global breakpoint.<br>
break 123 -count 50 <br>
Suspend the current process the fiftieth time it reaches line<br>123. No other processes will be affected. <br>
break 123 -if x&gt;y <br>
Stop the current process when it reaches line 123, if the<br>value of variable <b>x</b> in scope at line 123 is greater than the<br>value of variable <b>y</b> in scope there. <br>
<b>Extensions</b><br>
<b>break {<i>procedure</i> | <i>line</i> | #<i>file</i>#<i>line</i>}</b><br>
<b>[ {-count <i>n</i> | -if <i>condition</i>} ] [-stop {<i>stop-set</i> | &quot;[]&quot;} ] </b><br>
<i>stop-set</i> <br>
The threads that should be suspended once the breakpoint has triggered, expressed using<br>standard p/t set notation, or using an empty set ([]) to signify that just the triggering thread<br>should stop. Defaults to all threads in the process containing the triggering threads. <br>
[Not available for core-file debugging] <br>
Extends the semantics so that threads can be stopped individually, rather than as a group (all<br>threads within a process). <br>
This extension requires that the debugger variable STOP_MODEL be examined. If its value is ANY,<br>
134<br>
<hr>
<A name=135></a>HPD Version 1<br>
only the threads specified in the -stop option are stopped when the breakpoint is triggered. If<br>its value is ALL, it is a process set (not a thread set) that is stopped, as described under the<br>required version of the command. <br>
It is expected that debuggers supporting this extension will assign the default value of ANY to the<br>debugger variable. <br>
<b>barrier - Define a barrier point </b><br>
<b>barrier {<i>procedure</i> | <i>line</i> | #<i>file</i>#<i>line</i>} </b><br>
<i>procedure</i> <br>
Barrier location specified as the name of a procedure, expressed using a fully or partially<br>qualified symbol name. <br>
<i>line</i> <br>
Barrier location specified as a line number (in the file containing the current source<br>location). <br>
#<i>file</i>#<i>line</i> <br>
Barrier location specified as a line number preceded by a fully or partially qualified symbol<br>name denoting a source file. <br>
[Not available for core-file debugging] <br>
<b>Description</b><br>
The barrier command is used to synchronize a set of threads. The target p/t set defines which<br>threads are affected. A barrier is similar to a breakpoint in that it causes threads to be suspended,<br>but it has an additional characteristic. When a thread reaches a barrier, it will stop, just as it does<br>for a breakpoint. The difference is that each thread reaching a barrier will be inhibited from<br>responding to resume commands (e.g., step, next, go) until all threads in the affected set have<br>arrived at the same barrier. When that condition has been met, the barrier is said to be satisfied<br>and the affected thread are &quot;released.&quot; Only then will they then respond to resume commands. <br>
It is important to note that the use of barriers can induce deadlock. For example, if two threads<br>participate in two different barriers, it may be possible for each to be left waiting at a different<br>barrier - neither of which can be satisfied. Deadlock will also occur if a barrier is set in a<br>procedure that will never be invoked by some thread(s) in the affected set. If this occurs, the<br>delete command should be used to remove the barrier, since a side effect of deletion is that any<br>threads held at the barrier will be released. <br>
Note also that barriers cannot always be implemented with precision for threads-only debuggers<br>or multilevel debuggers, since they require that the debugger be able to hold and release<br>individual threads. Therefore, threads-only debuggers may elect not to implement this command,<br>while multilevel debuggers may elect to implement it only at the level of whole processes (i.e.,<br>
135<br>
<hr>
<A name=136></a>HPD Version 1<br>
such that only processes may be named as elements of the barrier set). All HPD debuggers,<br>however, should recognize the command name and be able to report to the user if it is not<br>available. <br>
The user may request a barrier at any line in a source file. However, the compiler might not<br>generate the appropriate debugging information to permit the debugger to stop execution at a<br>given line. This may happen, for example, because the requested line contains no executable<br>statements or because of the way the compiler generates line number information for statements<br>that span multiple lines. Therefore, the set of lines in a source file at which the debugger can<br>stop execution is implementation dependent. <br>
When the user requests a barrier on a line at which the debugger cannot stop execution, it will<br>be set at the next line in the source file where execution can be halted. If the user requests a<br>barrier beyond the last possible stopping line in the file, it is inserted at the last feasible location.<br>When reporting the status of a barrier, the debugger will name the location where threads will<br>actually stop. <br>
To achieve a &quot;global&quot; barrier - one that synchronizes all processes - the target p/t set should be<br>specified as [all]. <br>
Defining a barrier affects debugger state, where membership in the barrier set is established.<br>Program state is not affected by the barrier definition, but arrival at a barrier halts the<br>newly-arrived process or thread, leaving it in the <b>sopped/held</b> state. Further, for each thread<br>held at the barrier, the barrier location will be used to update the value of that thread's $EXEC<br>(used for the list command. When all threads in the barrier set have arrived at the barrier<br>location they are all moved from the <b>stopped/held</b> to the <b>stopped/runnable</b> state. <br>
The command completes when the debugger has either rejected the command because of an<br>error, or when it has updated its internal information about actionpoints, and assigned an<br>actionpoint identifier. <br>
No *deferred output* will be generated until all threads in the barrier set have arrived at the<br>barrier. <br>
If a barrier and a breakpoint are defined at the same source location, the breakpoint does not<br>trigger until the barrier is satisfied. <br>
If the barrier command is interrupted by the *user interrupt key*, the debugger prints a<br>message indicating whether or not the operation succeeded as requested. If not, the message<br>indicates the number of threads for which it failed and deletes the barrier. <br>
<b>Command Output</b><br>
A barrier command normally produces no output other than error or warning messages. When<br>the operation has been interrupted by the user, and verbose output is in effect, the debugger lists<br>each thread for which the barrier was not set; this output will be aggregated. <br>
136<br>
<hr>
<A name=137></a>HPD Version 1<br>
<b>Deferred Output</b>. After a barrier has been satisfied (i.e., all threads in the trigger set have<br>arrived), the debugger issues a message showing the actionpoint identifier and barrier location. If<br>verbose output is in effect, the debugger also reports the identifier of each thread participating in<br>the barrier. All output will be aggregated. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A barrier command cannot be applied when debugging a core-file. The affected (target) set is<br>restricted in two ways. First, it can only include threads that are stopped; if any of the specified<br>threads is running, the operation fails. Second, the only permissible dynamic sets are <i>process</i>.*,<br>all, or exec(<i>executable</i>). Further, a barrier cannot be defined for an executable that has not<br>yet been loaded. If any of these errors occurs, the operation is aborted and an appropriate<br>message is generated. <br>
If the barrier location is ambiguous because the threads in the trigger set have conflicting source<br>locations, an error occurs and a message is generated indicating where the conflicting locations<br>are. Similar output is generated if the barrier location has already been used to define another<br>barrier that affects some or all of the same threads. <br>
Whenever the user requests that a barrier be set at a location that is not feasible (or at a location<br>whose line is beyond the last line at which execution can be stopped) and the debugger adjusts<br>the location, it issues a warning message to that effect. <br>
Barriers can have significant impact on debugger performance. If this is true for a particular<br>implementation and verbose output is in effect, the debugger will issue a diagnostic message<br>indicating in some relative way the cost of defining and satisfying barriers. <br>
<b>Examples</b><br>
barrier 123 <br>
As each process in the current process set arrives at line 123, it<br>is stopped. Once all have arrived, the barrier is reported to the<br>user. <br>
[0:2.*] barrier inv_fft  As each thread in processes 0, 1, and 2 arrives at the first<br>
executable line in procedure <b>invfft</b>, it is held there. Once all have<br>arrived, the barrier is reported to the user. <br>
<b>watch - Define an unconditional watchpoint </b><br>
<b>watch <i>variable</i> [-length <i>byte-count</i>] [-stop <i>stop-set</i>] </b><br>
<i>variable</i> <br>
A symbol name corresponding to a program scalar or aggregate identifier, an element of an<br>
137<br>
<hr>
<A name=138></a>HPD Version 1<br>
aggregate, or a de-referenced pointer. <br>
<i>byte-count</i> <br>
The number of bytes to watch. The default is the length of the named object, as determined<br>by its data type. <br>
<i>stop-set</i> <br>
The processes that should be suspended once the watchpoint has triggered, expressed using<br>standard process set notation. Defaults to the process where the watchpoint triggered. <br>
[Not available for core-file debugging] <br>
<b>Description</b><br>
A watch command defines a watchpoint on a particular area in memory, where the specified<br>variable(s) is stored. The watchpoint triggers whenever the value of the variable(s) changes. <br>
The variable can be the name of a scalar, array, record, or structure object, or a reference to a<br>particular element in an array, record, or structure. It can also be a de-referenced pointer<br>variable. Intuitively, it must be possible for the debugger to evaluate the symbol as a memory<br>address and length by accessing the debugging information generated by the compiler. <br>
The static scope of the named variable is established when the watchpoint is defined. If the<br>variable is local to a procedure, the watchpoint is automatically re-installed each time the<br>procedure is invoked (and removed when it exits), so the watchpoint remains in effect until the<br>user explicitly removes it. <br>
The target p/t set establishes for which processes (not individual threads) the watchpoint is in<br>effect. Any static set may be specified, or a dynamic set of the form <i>process</i>.*, all, or<br>exec(<i>executable</i>). <br>
The -stop option specifies the stop set for the watchpoint, and may be any target process set<br>(see Extensions), either static or dynamic. If none is specified, the default is the process(es)<br>containing the triggering thread(s). To achieve a <i>global watchpoint</i> - one that stops all processes<br>as soon as any of them has reached the watchpoint location - a stop set of [all] should be<br>specified. <br>
If no -length modifier is specified, the length attribute from the symbol table is used, so the<br>watchpoint applies to the data object named; that is, specifying the name of an array has the<br>effect of watching all elements of the array for modifications. Alternatively, the user can specify<br>that a certain number of bytes be watched, starting at the named location. This makes it possible<br>to watch arbitrary slices of arrays, regions of heap storage, etc. <br>
Conditional watchpoints are not included in HPD Version 1. <br>
Defining a watchpoint affects debugger state, where membership in the trigger and stop sets is<br>established. Program state is not affected by the watchpoint definition, but triggering of a<br>watchpoint halts one or more processes, leaving them in the <b>stopped/runnable</b> state. Further,<br>
138<br>
<hr>
<A name=139></a>HPD Version 1<br>
the current execution location of the triggering thread(s) will be used to update the value of<br>$EXEC, used for the thread arbitration algorithm. <br>
The command completes when the debugger has either rejected the command because of an<br>error, or when it has updated its internal information about actionpoints, and assigned an<br>actionpoint identifier. <br>
Once a watchpoint has triggered, the debugger suspends each process in the stop set as well as<br>the process(es) containing the triggering thread(s). It then issues the deferred output described<br>below. <br>
If the watch command is interrupted by the user interrupt key, the debugger prints a message<br>indicating whether or not the operation succeeded as requested. If not, the message indicates the<br>number of threads for which it failed. <br>
<b>Design Rationale</b><br>
Typically, the debugger does not have access to information on which particular thread in a<br>process actually modified the target location. Therefore, the target set is interpreted as a process<br>set. <br>
Further, access-specific watchpoints - those triggered by reads or writes to memory locations<br>rather than changes to the contents - are not covered by the standard because they depend on<br>hardware and operating system support that might not be available to all implementations. <br>
<b>Command Output</b><br>
A watch command normally produces no output other than error or warning messages. When<br>the operation has been interrupted by the user, and verbose output is in effect, the debugger lists<br>each thread for which the watchpoint was not set; this output will be aggregated. <br>
<b>Deferred Output</b>. After a watchpoint has triggered, the debugger issues a message showing the<br>actionpoint identifier, location being watched, current execution location of the triggering<br>thread, and identifier of the triggering thread(s). If verbose output is in effect, the debugger also<br>reports the current location of each thread in the stop set. All output will be aggregated. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
A watch command cannot be applied when debugging a core-file. The trigger (target) set is<br>restricted in two ways. First, it can only include threads that are stopped; if any of the specified<br>threads is running, the operation fails. Second, the only permissible dynamic sets are <i>process</i>.*,<br>all, or exec(<i>executable</i>). Further, a watchpoint cannot be defined for an executable that has<br>not yet been loaded or if the watchpoint location is ambiguous - for example, if threads in the<br>trigger set have conflicting uses of the symbol name. If any of these errors occurs, the operation<br>is aborted and an appropriate message is generated. <br>
139<br>
<hr>
<A name=140></a>HPD Version 1<br>
The naming of a data location that attempts to access an illegal region of memory - such as<br>de-referencing an obsolete pointer value, naming an array element that is out-of-bound, or<br>naming a variable that has been optimized away - is also an error, although this might not be<br>detected until later in execution, when the watchpoint location is tested. <br>
To assist the user in minimizing the impact of watchpoints on debugger performance, diagnostic<br>feedback will be reported if verbose output is in effect and if watchpoints are intrusive for a<br>given implementation. <br>
<b>Special Requirements for Documentation</b> The efficiency of watchpoints is highly<br>dependent on the amount of support provided by the hardware and operating system.<br>Consequently, each implementation will provide documentation on: <br>
The number of watchpoints that can be defined efficiently at any time. <br>The frequency of checks for watchpoints that are implemented in software (e.g. every<br>instruction, every statement, every source line). <br>
<b>Examples</b><br>
For these examples, assume that the current process set at the time of the watch command<br>consists only of process 2, and that <b>p</b> is a global variable that is a pointer. <br>
watch *p <br>
Watches the address stored in the pointer <b>p</b> at the<br>time the watchpoint is defined, for changes made<br>by process 2. Only process 2 will be stopped. Note<br>that the watchpoint location does not change when<br>the value of <b>p</b> changes. <br>
watch arrayx <br>
Watches all elements in the array <b>arrayx</b> for<br>accesses by process 2. If <b>arrayx</b> is local to a<br>procedure, the watchpoint is re-installed<br>automatically every time the procedure is entered.<br>Only process 2 will be stopped. <br>
[1.0:3.8] watch arrayx -stop [all]  Watches all elements in the array <b>arrayx</b> for<br>
changes made by processes 1, 2, or 3. When the<br>watchpoint triggers, all processes will be stopped. <br>
<b>Extensions</b><br>
<b>watch <i>variable</i> [-length <i>byte-count</i>] [-stop {<i>stop-set</i> | &quot;[]&quot;} ] </b><br>
<i>stop-set</i> <br>
The threads that should be suspended once the watchpoint has triggered, expressed using<br>standard p/t set notation, or using an empty set ([]) to signify that just the triggering thread<br>should stop. Defaults to all threads in the process containing the triggering threads. <br>
[Not available for core-file debugging] <br>
140<br>
<hr>
<A name=141></a>HPD Version 1<br>
Extends the semantics so that threads can be stopped individually, rather than as a group (all<br>threads within a process). <br>
This extension requires that the debugger variable STOP_MODEL be examined. If its value is ANY,<br>only the threads specified in the -stop option are stopped when the watchpoint is triggered. If<br>its value is ALL, it is a process set (not a thread set) that is stopped, as described under the<br>required version of the command. <br>
It is expected that debuggers supporting this extension will assign the default value of ANY to the<br>debugger variable. <br>
<b>actions - Display a list of actionpoints </b><br>
<b>actions [ {<i>actionpoint-list</i> | -enabled | -disabled | -break | -watch |</b><br>
<b>-barrier} </b><br>
<i>actionpoint-list</i> <br>
A comma delimited list of actionpoint identifiers. Restricts command output to just the<br>specified actionpoints. <br>
<i>-enabled</i> <br>
Only actionpoints that are currently enabled will be shown. <br>
<i>-disabled</i> <br>
Only actionpoints that are currently disabled will be shown. <br>
<i>-barrier</i> <br>
Only barriers will be shown. <br>
<i>-break</i> <br>
Only breakpoints will be shown. <br>
<i>-watch</i> <br>
Only watchpoints will be shown. <br>
[Not available for core-file debugging] <br>
<b>Description</b><br>
The actions command displays information about actionpoints, including the actionpoint<br>identifier, actionpoint location, trigger set, stop set, and whether the actionpoint is currently<br>enabled or disabled. It is the only way to obtain the actionpoint identifier, which is necessary to<br>delete, enable, disable, or import/export actionpoints. <br>
If no argument is included, a comprehensive listing of all actionpoints will be displayed. To<br>restrict the amount of output, one of the options should be specified, or the size of the target p/t<br>set should be controlled. <br>
Specific actionpoint identifiers can be included when detailed information is required - or simply<br>
141<br>
<hr>
<A name=142></a>HPD Version 1<br>
to see which actionpoint have been in existence the longest. The -enabled and -disabled<br>options restrict output to actionpoints in a particular state, while -barrier, -break, and<br>-watch allow the user to view just the information on barriers, breakpoints, or watchpoints. <br>
Any static set or dynamic set can be used as the target set. The target set restricts the command<br>so that it applies only to the member threads. Thus, if a thread in the target set is included in<br>either the trigger set or stop set of a corresponding actionpoint, the actionpoint will be<br>displayed. <br>
The actions command has no effect on either program state or debugger state. It completes<br>when the appropriate actionpoints information has been found and displayed. <br>
Since the amount of output can be considerable if there are many actionpoints in effect, the<br>display can be stopped at any time by issuing the user interrupt key. This terminates the<br>command, but has no other effect on program or debugger state. <br>
<b>Command Output</b><br>
In response to an actions command, the debugger presents a list of actionpoints satisfying the<br>criteria imposed by any options. Actionpoints are listed in ascending order of actionpoint<br>identifiers. Normally, only the actionpoint identifier, its location, and its current state (enabled or<br>disabled) are listed, using a tabular format. <br>
If verbose output is in effect, the trigger and stop sets are also displayed. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
The actions command cannot be applied when debugging a core-file or before the<br>executable(s) has been loaded. If either of these errors occur, the debugger issues an appropriate<br>message. <br>
If an actionpoint identifier specified on the command does not exist, a warning message is<br>issued, but the debugger continues to process other identifiers in the list. <br>
If no actionpoint is found to correspond to the command specification, a diagnostic message is<br>generated. <br>
<b>Examples</b><br>
[0:4.*] action <br>
Displays information on all actionpoints defined to include<br>processes 0 through 4 in the trigger or stop set. <br>
action -barrier <br>
Displays information on all barriers defined for any processes in the<br>current p/t set. <br>
[1.*] action -enabled  Displays information on any actionpoints currently enabled for<br>
process 1. <br>
142<br>
<hr>
<A name=143></a>HPD Version 1<br>
<b>delete - Delete actionpoint(s) </b><br>
<b>delete {<i>actionpoint-list</i> | -enabled | -disabled | -break | -watch | -barrier</b><br>
<b>| -all} </b><br>
<i>actionpoint-list</i> <br>
A comma delimited list of actionpoint identifiers to be deleted. <br>
-enabled <br>
Only actionpoints that are currently enabled will be deleted. <br>
<i>-disabled</i> <br>
Only actionpoints that are currently disabled will be deleted. <br>
<i>-barrier</i> <br>
Only barriers will be deleted. <br>
<i>-break</i> <br>
Only breakpoints will be deleted. <br>
<i>-watch</i> <br>
Only watchpoints will be deleted. <br>
[Not available for core-file debugging] <br>
<b>Description</b><br>
The delete command permanently removes actionpoints. An argument or option is required.<br>This, together with the target p/t set, controls which actionpoints are deleted. <br>
The argument may list specific actionpoint identifiers to be deleted. Alternatively, the -enabled,<br>-disabled, break, watch, or barrier option may be used to restrict the command to<br>actionpoints in a particular state, or those of a particular type. The -all option specifies that all<br>actionpoints should be deleted. <br>
Any static set or dynamic set can be used as the target set. The target set restricts the command<br>so that it applies only to the member threads. Thus, if a thread in the target set is included in<br>either the trigger set or stop set of a corresponding actionpoint, the actionpoint will be<br>eliminated for that thread. If the actionpoint also applies to threads outside the target set, their<br>settings will not be affected. <br>
The delete command affects debugger state by removing all information about the deleted<br>actionpoint(s). It does not directly affect program state unless the specified actionpoint(s) is a<br>barrier; in this case, the state of any process(es) in the target set that is currently being held at<br>the barrier is changed from <b>stopped/held</b> to <b>stopped/runnable</b>. The command completes once<br>debugger state has been updated and any held processes have been released. <br>
Since it might require a considerable amount of time to delete actionpoints from many<br>
143<br>
<hr>
<A name=144></a>HPD Version 1<br>
processes, the command can be stopped at any time by issuing the user interrupt key. This<br>terminates the command; the debugger issues a message indicating the number of actionpoints<br>for which it failed. <br>
<b>Command Output</b><br>
A delete command normally generates a status message indicating how many actionpoints<br>were deleted. <br>
When verbose output is in effect, the debugger lists the identifier of each deleted actionpoint. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
The delete command cannot be applied when debugging a core-file or before the executable(s)<br>has been loaded. If either of these errors occur, the debugger issues an appropriate message. <br>
An actionpoint can only be deleted for a thread that is stopped. If an affected thread is not<br>stopped, or if a specific actionpoint identifier named in the argument does not exist, a warning<br>message is issued, but the debugger continues to process any other actionpoints satisfying the<br>specification. <br>
If no actionpoint is found to correspond to the command specification, a diagnostic message is<br>generated. <br>
<b>Examples</b><br>
[0:4.*] delete -break  Delete all breakpoints associated with processes 0 through 4.<br>
Breakpoints associated with other threads will not be affected. <br>
delete -barrier <br>
Delete all barriers defined for any processes in the current p/t set. If<br>any of the processes is currently held at the barrier, its state will be<br>changed to <b>stopped/runnable</b>. <br>
[1.*] delete -enabled  Delete any actionpoints currently enabled for process 1. <br>
delete -all <br>
Delete all actionpoints associated with processes in the target p/t<br>set. <br>
[all] delete -all <br>
Delete all actionpoints known to the debugger. <br>
<b>disable - Temporarily disable actionpoint(s) </b><br>
<b>disable {<i>actionpoint-list</i> | -break | -watch | -barrier | -all} </b><br>
<i>actionpoint-list</i> <br>
A comma delimited list of actionpoint identifiers to be disabled. <br>
144<br>
<hr>
<A name=145></a>HPD Version 1<br>
-enabled <br>
Only actionpoints that are currently enabled will be disabled. <br>
<i>-disabled</i> <br>
Only actionpoints that are currently disabled will be disabled. <br>
<i>-barrier</i> <br>
Only barriers will be disabled. <br>
<i>-break</i> <br>
Only breakpoints will be disabled. <br>
<i>-watch</i> <br>
Only watchpoints will be disabled. <br>
[Not available for core-file debugging] <br>
<b>Description</b><br>
The disable command temporarily deactivates actionpoints, but does not eliminate them. An<br>argument or option is required. This, together with the target p/t set, controls which<br>actionpoints are disabled. <br>
The argument may list specific actionpoint identifiers to be disabled. Alternatively, the break,<br>watch, or barrier option may be used to restrict the command to actionpoints of a particular<br>type. The -all option specifies that all actionpoints should be disabled. <br>
Any static set or dynamic set can be used as the target set. The target set restricts the command<br>so that it applies only to the member threads. Thus, if a thread in the target set is included in<br>either the trigger set or stop set of a corresponding actionpoint, the actionpoint will be disabled<br>for that thread. If the actionpoint also applies to threads outside the target set, their settings will<br>not be affected. <br>
The disable command affects debugger state by disabling the corresponding actionpoint(s). It<br>has no effect on program state. The command completes once debugger state has been updated. <br>
The command can be stopped at any time by issuing the user interrupt key. This terminates the<br>command; the debugger issues a message indicating the number of actionpoints for which it<br>failed. <br>
<b>Command Output</b><br>
A disable command normally produces no output other than error or warning messages. <br>
When verbose output is in effect, the debugger indicates how many actionpoints were disabled. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
The disable command cannot be applied when debugging a core-file or before the<br>executable(s) has been loaded. If either of these errors occur, the debugger issues an appropriate<br>
145<br>
<hr>
<A name=146></a>HPD Version 1<br>
message. <br>
An actionpoint can only be disabled for a thread that is stopped. If an affected thread is running,<br>or if a specific actionpoint identifier named in the argument does not exist, a warning message is<br>issued, but the debugger continues to process any other actionpoints satisfying the specification. <br>
<b>Examples</b><br>
[0:4.*] disable -break Disable all breakpoints associated with processes 0 through 4.<br>
Settings associated with other threads will not be affected. <br>
disable -barrier <br>
Disable all barriers defined for any processes in the current p/t set. <br>
disable -all <br>
Disable all actionpoints associated with processes in the target p/t<br>set. <br>
[all] disable -all <br>
Disable all actionpoints known to the debugger. <br>
<b>enable - Re-enable actionpoint(s) </b><br>
<b>enable {<i>actionpoint-list</i> | -break | -watch | -barrier | -all} </b><br>
<i>actionpoint-list</i> <br>
A comma delimited list of actionpoint identifiers to be enabled. <br>
-enabled <br>
Only actionpoints that are currently enabled will be enabled. <br>
<i>-disabled</i> <br>
Only actionpoints that are currently disabled will be enabled. <br>
<i>-barrier</i> <br>
Only barriers will be enabled. <br>
<i>-break</i> <br>
Only breakpoints will be enabled. <br>
<i>-watch</i> <br>
Only watchpoints will be enabled. <br>
[Not available for core-file debugging] <br>
<b>Description</b><br>
The enable command reactivates actionpoints that were previously disabled. An argument or<br>option is required. This, together with the target p/t set, controls which actionpoints are enabled.<br>
The argument may list specific actionpoint identifiers to be enabled. Alternatively, the break,<br>watch, or barrier option may be used to restrict the command to actionpoints of a particular<br>type. The -all option specifies that all actionpoints should be enabled. <br>
146<br>
<hr>
<A name=147></a>HPD Version 1<br>
Any static set or dynamic set can be used as the target set. The target set restricts the command<br>so that it applies only to the member threads. Thus, if a thread in the target set is included in<br>either the trigger set or stop set of a corresponding actionpoint, the actionpoint will be enabled<br>for that thread. If the actionpoint also applies to threads outside the target set, their settings will<br>not be affected. <br>
The enable command affects debugger state by enabling the corresponding actionpoint(s). It<br>has no effect on program state. The command completes once debugger state has been updated. <br>
The command can be stopped at any time by issuing the user interrupt key. This terminates the<br>command; the debugger issues a message indicating the number of actionpoints for which it<br>failed. <br>
<b>Command Output</b><br>
An enable command normally produces no output other than error or warning messages.<br>
When verbose output is in effect, the debugger indicates how many actionpoints were enabled. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
The enable command cannot be applied when debugging a core-file or before the executable(s)<br>has been loaded. If either of these errors occur, the debugger issues an appropriate message. <br>
An actionpoint can only be enabled for a thread that is stopped. If an affected thread is not<br>stopped, or if a specific actionpoint identifier named in the argument does not exist, a warning<br>message is issued, but the debugger continues to process any other actionpoints satisfying the<br>specification. <br>
<b>Examples</b><br>
[0:4.*] enable -break  Enable all breakpoints associated with processes 0 through 4.<br>
Settings associated with other threads will not be affected. <br>
enable -barrier <br>
Enable all barriers defined for any processes in the current p/t set. <br>
enable -all <br>
Enable all actionpoints associated with processes in the target p/t<br>set. <br>
[all] enable -all <br>
Enable all actionpoints known to the debugger. <br>
<b>export - Save commands to re-establish actionpoints </b><br>
<b>export <i>file</i> [ {<i>actionpoint-list</i> | -enabled | -disabled | -break | -watch |</b><br>
<b>-barrier} </b><br>
147<br>
<hr>
<A name=148></a>HPD Version 1<br>
<i>file</i> <br>
A fully or partially qualified symbol name denoting the file where the actionpoint<br>information should be stored. <br>
<i>actionpoint-list</i> <br>
A comma delimited list of actionpoint identifiers. Restricts command output to just the<br>specified actionpoints. <br>
<i>-enabled</i> <br>
Only actionpoints that are currently enabled will be exported. <br>
<i>-disabled</i> <br>
Only actionpoints that are currently disabled will be exported. <br>
<i>-barrier</i> <br>
Only barriers will be exported. <br>
<i>-break</i> <br>
Only breakpoints will be exported. <br>
<i>-watch</i> <br>
Only watchpoints will be exported. <br>
[Not available for core-file debugging] <br>
<b>Description</b><br>
The export stores information about actionpoints, so that the same settings can be used in<br>future debugging sessions. That information is stored in the form of the commands needed to<br>define the specified collection of actionpoints. To restore the actionpoint settings at a later time,<br>the file is processed using the input command. (The file can be modified, or merged with other<br>debugger commands, using a text editor.) <br>
If no argument is included, all currently defined actionpoints will be exported. To limit the<br>number of actionpoints stored, options should be specified, or the size of the target p/t set<br>should be controlled. <br>
Any static set or dynamic set can be used as the target set. The target set restricts the command<br>so that it applies only to the member threads. Thus, if a thread in the target set is included in<br>either the trigger set or stop set of a corresponding actionpoint, the actionpoint will be exported.<br>
If all or exec (<i>executable</i>) is specified, exactly that word(s) is coded in the stored<br>commands. For other debugger-defined sets or user-defined sets, the corresponding lists of<br>actionpoint identifiers are explicitly named in the commands. <br>
Specific actionpoint identifiers can be included when only particular settings will be important<br>for future use. The -enabled and -disabled options restrict the stored settings to actionpoints<br>in a particular state, while -barrier, -break, and -watch allow the user to export just<br>commands corresponding to barriers, breakpoints, or watchpoints. <br>
The export command has no effect on either program state or debugger state. It completes<br>when the appropriate actionpoints information has been found and written to the file. <br>
148<br>
<hr>
<A name=149></a>HPD Version 1<br>
Since the time to write output to a file can be considerable if there are many actionpoints in<br>effect, the command can be stopped at any time by issuing the user interrupt key. This<br>terminates the command, but has no other effect on program or debugger state. <br>
<b>Command Output</b><br>
In response to an export command, the debugger writes an output file containing the<br>commands needed to re-establish the actionpoints that satisfy the criteria imposed by any<br>options. The commands are written in ascending order of actionpoint identifiers. <br>
If any of the actionpoints are disabled, the appropriate disable commands are also written to<br>the file. <br>
If no actionpoints satisfy the restrictions imposed by the command arguments, a diagnostic<br>message is generated. <br>
<b>Command Output</b><br>
In response to an actions command, the debugger presents a list of actionpoints satisfying the<br>criteria imposed by any options. Actionpoints are listed in ascending order of actionpoint<br>identifiers. Normally, only the actionpoint identifier, its location, and its current state (enabled or<br>disabled) are listed, using a tabular format. <br>
If verbose output is in effect, the trigger and stop sets are also displayed. <br>
<b>Errors, Warnings, and Diagnostics</b><br>
An export command cannot be applied when debugging a core-file or before the executable(s)<br>has been loaded. If either of these errors occur, the debugger issues an appropriate message. <br>
If an actionpoint identifier specified on the command does not exist, a warning message is<br>issued, but the debugger continues to process other identifiers in the list. <br>
If no actionpoint is found to correspond to the command specification, a diagnostic message is<br>generated. <br>
<b>Examples</b><br>
[0:4.*] export <br>
Exports the commands needed to re-establish all actionpoints<br>defined to include processes 0 through 4 in the trigger or stop set. <br>
export -barrier <br>
Exports the commands that would re-establish all barriers defined<br>for any processes in the current p/t set. <br>
[1.*] export -enabled  Exports the corresponding commands for any actionpoints<br>
currently enabled for process 1. <br>
149<br>
<hr>
<A name=150></a>HPD Version 1<br>
<b>Reference Summaries</b><br>
<b>4.1 Syntax Summary</b><br>
Working Version 2.1 - last revised Sept. 21, 1998 <br>
<i>Comments and requests for clarification are welcome. They should be submitted to<br>hpd-comments@ptools.org.</i> <br>
A summary is presented of the syntax for HPD Version 1 commands. The first section outlines<br>the general syntax for commands, symbol names, and other language elements shared by many<br>commands. The second section lists each of the commands required for compliance with the<br>HPD Version 1 standard. A third section lists the syntax for commands that have been defined as<br>extensions to HPD Version 1. <br>
<b>4.1.1 Basic (Shared) Syntax</b><br>
simple command <br>
[<i>p/t-set/prefix</i>] <i>verb object</i> [<i>option ...</i>] [-<i>option</i> [<i>value</i>] ...] <br>(When multiple options are included, they may appear in any order.) <br>
compound command <br>
[<i>p/t-set-prefix</i>] <i>simple-command</i> [<b>;</b> <i>simple-command</i> ...] <br>(In HPD Version 1, a compound command may appear only as the <i>command-string </i>for a<br>
user-defined command.) <br>
process/thread identifier <br>
{<i>integer</i>|<b>*</b>}<b>.</b>{<i>integer</i>|<b>*</b>} <br>
Optional notation when processes-only debugging or threads-only debugging is in effect <br>
{<i>integer</i>|<b>*</b>} <br>
range of processes/threads <br>
<i>p/t-id</i>:<i>p/t-id</i> <br>
list of processes/threads <br>
{<i>p/t-id</i>|<i>p/t-range</i>} [<b>,</b> {<i>p/t-id</i>|<i>p/t-range</i>} ...] <br>
p/t set <br>
<b>[</b>[<b>!</b>]{<i>p/t-list</i>|<i>set-name</i>}<b>]</b> <br>
fully qualified symbol name <br>
<b>#</b>{<i>exec|lib</i>}<b>#</b><i>file</i><b>#</b>{<i>proc|line</i>}<b>#</b><i>symbol</i> <br>
partially qualified symbol name <br>
150<br>
<hr>
<A name=151></a>HPD Version 1<br>
[<b>#</b>{<i>exec|lib</i>}<b>#</b>][<i>file</i><b>#</b>][{<i>proc|line</i>}<b>#</b>]<i>symbol</i> <br>
contextually qualified symbol name <br>
[<i>process-id</i><b>.</b><i>thread-id</i><b>#</b><i>frame-number</i>]<i>symbol</i> <br>
source location <br>
[<b>#</b>{<i>exec|lib</i>}<b>#</b>][<i>file</i><b>#</b>]{<i>proc|line</i>} <br>
<b>4.1.2 Required Commands</b><br>
# <br>
Ignore remainder of this line (&quot;comment command&quot;) <br>
!!  Repeat execution of most recent command <br>
! {<i>command-id</i> | <i>rel-command-id</i> | <i>command-string</i>} <br>
Repeat execution of a previous command <br>
actions [ {<i>actionpoint-list</i> | -enabled | -disabled | -break | -watch |<br>
-barrier | -all} ] <br>
Display a list of actionpoints <br>
alias [<i>command-name</i>] <br>
View previously defined command(s) <br>
alias <i>command-name</i> <i>command-body</i> <br>
Create a new user-defined command <br>
assign <i>scalar-target scalar-value</i> [-force] <br>
Change the value of a scalar program variable <br>
attach <i>executable</i> <i>pid-list</i> <br>
Bring currently executing process(es) under control of the debugger <br>
barrier <i>source-loc</i> [-stop <i>stop-set</i>] <br>
Define a barrier point <br>
break <i>source-loc</i> [-stop <i>stop-set</i>] <br>
Define an unconditional breakpoint <br>
break <i>source-loc</i> -count <i>n</i> [-stop <i>stop-set</i>] <br>
Define a count-dependent breakpoint <br>
break <i>source-loc</i> -if <i>condition</i> [-stop <i>stop-set</i>] <br>
Define a conditional breakpoint <br>
cont [-waitany] <br>
151<br>
<hr>
<A name=152></a>HPD Version 1<br>
Resume execution of target process(es), blocking command input until target process(es)<br>stop <br>
core core <i>executable</i> <i>core-list</i> <br>
Load core-file image of process(es) for examination <br>
defset <i>set-name</i> <i>p/t-set</i> <br>
Assign a set name to a group of processes/threads <br>
delete {<i>actionpoint-list</i> | -enabled | -disabled | -break | -watch | -barrier<br>
| -all} <br>
Remove actionpoint(s) <br>
detach <br>
Detach debugger from target process(es), leaving it executing <br>
disable {<i>actionpoint-list</i> | -break | -watch | -barrier | -all} <br>
Temporarily disable actionpoint(s) <br>
down [<i>num-levels</i>] <br>
Move down one or more levels in the call stack <br>
enable {<i>actionpoint-list</i> | -break | -watch | -barrier | -all} <br>
Re-enable actionpoint(s) <br>
exit <br>
Terminate the debugging session (same as quit) <br>
export <i>file</i> {<i>actionpoint-list</i> | -enabled | -disabled | -break | -watch |<br>
-barrier | -all} <br>
Save commands to re-establish actionpoint(s) <br>
focus [<i>p/t-set</i>] <br>
Change the current process/thread set <br>
go  Resume execution of target process(es) <br>
halt <br>
Suspend execution of target process(es) <br>
help [<i>topic</i>] <br>
Display help information <br>
history [<i>num-commands</i>] <br>
Display command history list <br>
info <br>
Display debugger environment information <br>
152<br>
<hr>
<A name=153></a>HPD Version 1<br>
input <i>file</i> <br>
Read and execute debugger commands stored in a file <br>
kill <br>
Terminate execution of target process(es) <br>
list [-length [-] <i>num-lines</i>] <br>
Display code relative to current list location <br>
list <i>source-loc</i> [-length [-] <i>num-lines</i>] <br>
Display code relative to the start of some file or procedure, or to some specific code line <br>
list $EXEC [-length [-] <i>num-lines</i>] <br>
Display code relative to current execution location <br>
load <i>executable</i> [-copies <i>copies</i>] <br>
Load debugging information about target program and prepare for execution <br>
log <i>file</i> [-quiet] [ {-output | -input} ] <br>
Start debugger logging <br>
log [<i>file</i>] -off <br>
Stop debugger logging <br>
log View current status of debugger logging <br>
print <i>expression</i> [-name] [-index] [-format <i>format-spec</i>] <br>
Evaluate and display the value of a program variable or expression <br>
proginput <br>
Send command-line input to the target program, rather than the debugger <br>
quit <br>
Terminate the debugging session (same as exit) <br>
run [<i>arguments</i>] [<i>I/O-redirection</i>] <br>
Start or re-start execution of target process(es) <br>
set <i>debugger-var</i> = <i>value</i> <br>
Change a debugger state variable <br>
set [<i>debugger-var</i>] <br>
View current debugger state variables <br>
status [-mpi] <br>
Show current status of processes and threads <br>
step [<i>repeat-count</i>] <br>
153<br>
<hr>
<A name=154></a>HPD Version 1<br>
Execute one or more statements by a specific process/thread <br>
step [<i>repeat-count</i>] -over <br>
Execute one or more statements, stepping around procedure calls <br>
step -finish <br>
Execute to end of current procedure <br>
unalias {<i>command-name</i> | -all} <br>
Remove previously defined command <br>
undefset {<i>set-name</i>| -all} <br>
Undefine a previously defined process/thread set <br>
unset {<i>debugger-var</i> | -all} <br>
Restore default setting for a debugger state variable(s) <br>
up [<i>num-levels</i>] <br>
Move up one or more levels in the call stack <br>
viewset [<i>set-name</i>] <br>
List the members of a process/thread set <br>
what <i>symbol-name</i> [-all] <br>
Determine what a target program name refers to <br>
wait [-waitany] <br>
Block command input until target process(es) stop <br>
watch <i>variable</i> [-length <i>byte-count</i>] [-stop <i>stop-set</i>] <br>
Define an unconditional watchpoint <br>
where [ {<i>num-levels</i> | -all} ] [-args] <br>
Display the current execution location and call stack <br>
whichsets [<i>p/t-set</i>] <br>
List all sets to which a process/thread belongs <br>
<b>4.1.3 Language Extensions</b><br>
assign <i>target value</i> [-force] <br>
Change the value of a scalar variable, array, or array slice <br>
break {<i>source-loc</i> [ {-count <i>n</i> | -if <i>condition</i>} ] [-stop {<i>stop-set</i> | &quot;[]&quot;} ] <br>
Allow stop set to name individual threads <br>
cont [-waitany] <br>
154<br>
<hr>
<A name=155></a>HPD Version 1<br>
Resume execution of target thread(s), blocking command input <br>
go  Resume execution of target thread(s) <br>
halt <br>
Stop execution of target thread(s) <br>
load <i>executable</i> [-restart <i>restart-file</i> | -copies] <br>
Load debugging information and prepare to re-start from checkpoint <br>
status [-mpi] [-changed] <br>
Show processes/threads whose status has changed <br>
step [{<i>repeat-count</i> | <i>repeat-count</i> -over | -finish | -over}] <br>
Execute one or more statements by a single thread <br>
step [{<i>repeat-count</i> | <i>repeat-count</i> -over | -finish | -over}] [-waitany] <br>
Execute one or more statements by specific processes/threads (&quot;parallel step&quot;) <br>
wait [-waitany] <br>
Block command input until target thread(s) stops <br>
watch <i>variable</i> [-length <i>byte-count</i>] [-stop {<i>stop-set</i> | &quot;[]&quot;}] <br>
Allow stop set to name individual threads <br>
where [ {<i>num-levels</i> | -all} ] [-args] [-u] [-g] <br>
Restrict call stack display to certain types of procedures <br>
<b>Reference Summaries</b><br>
<b>4.1 Syntax Summary</b><br>
Working Version 2.1 - last revised Sept. 21, 1998 <br>
<i>Comments and requests for clarification are welcome. They should be submitted to<br>hpd-comments@ptools.org.</i> <br>
A summary is presented of the syntax for HPD Version 1 commands. The first section outlines<br>the general syntax for commands, symbol names, and other language elements shared by many<br>commands. The second section lists each of the commands required for compliance with the<br>HPD Version 1 standard. A third section lists the syntax for commands that have been defined as<br>extensions to HPD Version 1. <br>
155<br>
<hr>
<A name=156></a>HPD Version 1<br>
<b>4.1.1 Basic (Shared) Syntax</b><br>
simple command <br>
[<i>p/t-set/prefix</i>] <i>verb object</i> [<i>option ...</i>] [-<i>option</i> [<i>value</i>] ...] <br>(When multiple options are included, they may appear in any order.) <br>
compound command <br>
[<i>p/t-set-prefix</i>] <i>simple-command</i> [<b>;</b> <i>simple-command</i> ...] <br>(In HPD Version 1, a compound command may appear only as the <i>command-string </i>for a<br>
user-defined command.) <br>
process/thread identifier <br>
{<i>integer</i>|<b>*</b>}<b>.</b>{<i>integer</i>|<b>*</b>} <br>
Optional notation when processes-only debugging or threads-only debugging is in effect <br>
{<i>integer</i>|<b>*</b>} <br>
range of processes/threads <br>
<i>p/t-id</i>:<i>p/t-id</i> <br>
list of processes/threads <br>
{<i>p/t-id</i>|<i>p/t-range</i>} [<b>,</b> {<i>p/t-id</i>|<i>p/t-range</i>} ...] <br>
p/t set <br>
<b>[</b>[<b>!</b>]{<i>p/t-list</i>|<i>set-name</i>}<b>]</b> <br>
fully qualified symbol name <br>
<b>#</b>{<i>exec|lib</i>}<b>#</b><i>file</i><b>#</b>{<i>proc|line</i>}<b>#</b><i>symbol</i> <br>
partially qualified symbol name <br>
[<b>#</b>{<i>exec|lib</i>}<b>#</b>][<i>file</i><b>#</b>][{<i>proc|line</i>}<b>#</b>]<i>symbol</i> <br>
contextually qualified symbol name <br>
[<i>process-id</i><b>.</b><i>thread-id</i><b>#</b><i>frame-number</i>]<i>symbol</i> <br>
source location <br>
[<b>#</b>{<i>exec|lib</i>}<b>#</b>][<i>file</i><b>#</b>]{<i>proc|line</i>} <br>
<b>4.1.2 Required Commands</b><br>
# <br>
Ignore remainder of this line (&quot;comment command&quot;) <br>
!!  Repeat execution of most recent command <br>
! {<i>command-id</i> | <i>rel-command-id</i> | <i>command-string</i>} <br>
Repeat execution of a previous command <br>
156<br>
<hr>
<A name=157></a>HPD Version 1<br>
actions [ {<i>actionpoint-list</i> | -enabled | -disabled | -break | -watch |<br>
-barrier | -all} ] <br>
Display a list of actionpoints <br>
alias [<i>command-name</i>] <br>
View previously defined command(s) <br>
alias <i>command-name</i> <i>command-body</i> <br>
Create a new user-defined command <br>
assign <i>scalar-target scalar-value</i> [-force] <br>
Change the value of a scalar program variable <br>
attach <i>executable</i> <i>pid-list</i> <br>
Bring currently executing process(es) under control of the debugger <br>
barrier <i>source-loc</i> [-stop <i>stop-set</i>] <br>
Define a barrier point <br>
break <i>source-loc</i> [-stop <i>stop-set</i>] <br>
Define an unconditional breakpoint <br>
break <i>source-loc</i> -count <i>n</i> [-stop <i>stop-set</i>] <br>
Define a count-dependent breakpoint <br>
break <i>source-loc</i> -if <i>condition</i> [-stop <i>stop-set</i>] <br>
Define a conditional breakpoint <br>
cont [-waitany] <br>
Resume execution of target process(es), blocking command input until target process(es)<br>stop <br>
core core <i>executable</i> <i>core-list</i> <br>
Load core-file image of process(es) for examination <br>
defset <i>set-name</i> <i>p/t-set</i> <br>
Assign a set name to a group of processes/threads <br>
delete {<i>actionpoint-list</i> | -enabled | -disabled | -break | -watch | -barrier<br>
| -all} <br>
Remove actionpoint(s) <br>
detach <br>
Detach debugger from target process(es), leaving it executing <br>
disable {<i>actionpoint-list</i> | -break | -watch | -barrier | -all} <br>
Temporarily disable actionpoint(s) <br>
down [<i>num-levels</i>] <br>
157<br>
<hr>
<A name=158></a>HPD Version 1<br>
Move down one or more levels in the call stack <br>
enable {<i>actionpoint-list</i> | -break | -watch | -barrier | -all} <br>
Re-enable actionpoint(s) <br>
exit <br>
Terminate the debugging session (same as quit) <br>
export <i>file</i> {<i>actionpoint-list</i> | -enabled | -disabled | -break | -watch |<br>
-barrier | -all} <br>
Save commands to re-establish actionpoint(s) <br>
focus [<i>p/t-set</i>] <br>
Change the current process/thread set <br>
go  Resume execution of target process(es) <br>
halt <br>
Suspend execution of target process(es) <br>
help [<i>topic</i>] <br>
Display help information <br>
history [<i>num-commands</i>] <br>
Display command history list <br>
info <br>
Display debugger environment information <br>
input <i>file</i> <br>
Read and execute debugger commands stored in a file <br>
kill <br>
Terminate execution of target process(es) <br>
list [-length [-] <i>num-lines</i>] <br>
Display code relative to current list location <br>
list <i>source-loc</i> [-length [-] <i>num-lines</i>] <br>
Display code relative to the start of some file or procedure, or to some specific code line <br>
list $EXEC [-length [-] <i>num-lines</i>] <br>
Display code relative to current execution location <br>
load <i>executable</i> [-copies <i>copies</i>] <br>
Load debugging information about target program and prepare for execution <br>
log <i>file</i> [-quiet] [ {-output | -input} ] <br>
Start debugger logging <br>
158<br>
<hr>
<A name=159></a>HPD Version 1<br>
log [<i>file</i>] -off <br>
Stop debugger logging <br>
log View current status of debugger logging <br>
print <i>expression</i> [-name] [-index] [-format <i>format-spec</i>] <br>
Evaluate and display the value of a program variable or expression <br>
proginput <br>
Send command-line input to the target program, rather than the debugger <br>
quit <br>
Terminate the debugging session (same as exit) <br>
run [<i>arguments</i>] [<i>I/O-redirection</i>] <br>
Start or re-start execution of target process(es) <br>
set <i>debugger-var</i> = <i>value</i> <br>
Change a debugger state variable <br>
set [<i>debugger-var</i>] <br>
View current debugger state variables <br>
status [-mpi] <br>
Show current status of processes and threads <br>
step [<i>repeat-count</i>] <br>
Execute one or more statements by a specific process/thread <br>
step [<i>repeat-count</i>] -over <br>
Execute one or more statements, stepping around procedure calls <br>
step -finish <br>
Execute to end of current procedure <br>
unalias {<i>command-name</i> | -all} <br>
Remove previously defined command <br>
undefset {<i>set-name</i>| -all} <br>
Undefine a previously defined process/thread set <br>
unset {<i>debugger-var</i> | -all} <br>
Restore default setting for a debugger state variable(s) <br>
up [<i>num-levels</i>] <br>
Move up one or more levels in the call stack <br>
viewset [<i>set-name</i>] <br>
159<br>
<hr>
<A name=160></a>HPD Version 1<br>
List the members of a process/thread set <br>
what <i>symbol-name</i> [-all] <br>
Determine what a target program name refers to <br>
wait [-waitany] <br>
Block command input until target process(es) stop <br>
watch <i>variable</i> [-length <i>byte-count</i>] [-stop <i>stop-set</i>] <br>
Define an unconditional watchpoint <br>
where [ {<i>num-levels</i> | -all} ] [-args] <br>
Display the current execution location and call stack <br>
whichsets [<i>p/t-set</i>] <br>
List all sets to which a process/thread belongs <br>
<b>4.1.3 Language Extensions</b><br>
assign <i>target value</i> [-force] <br>
Change the value of a scalar variable, array, or array slice <br>
break {<i>source-loc</i> [ {-count <i>n</i> | -if <i>condition</i>} ] [-stop {<i>stop-set</i> | &quot;[]&quot;} ] <br>
Allow stop set to name individual threads <br>
cont [-waitany] <br>
Resume execution of target thread(s), blocking command input <br>
go  Resume execution of target thread(s) <br>
halt <br>
Stop execution of target thread(s) <br>
load <i>executable</i> [-restart <i>restart-file</i> | -copies] <br>
Load debugging information and prepare to re-start from checkpoint <br>
status [-mpi] [-changed] <br>
Show processes/threads whose status has changed <br>
step [{<i>repeat-count</i> | <i>repeat-count</i> -over | -finish | -over}] <br>
Execute one or more statements by a single thread <br>
step [{<i>repeat-count</i> | <i>repeat-count</i> -over | -finish | -over}] [-waitany] <br>
Execute one or more statements by specific processes/threads (&quot;parallel step&quot;) <br>
wait [-waitany] <br>
160<br>
<hr>
<A name=161></a>HPD Version 1<br>
Block command input until target thread(s) stops <br>
watch <i>variable</i> [-length <i>byte-count</i>] [-stop {<i>stop-set</i> | &quot;[]&quot;}] <br>
Allow stop set to name individual threads <br>
where [ {<i>num-levels</i> | -all} ] [-args] [-u] [-g] <br>
Restrict call stack display to certain types of procedures <br>
<i>Copyright  1998, High Performance Debugging Forum and Oregon State University </i><br>
161<br>
<hr>
</BODY>
</HTML>
