#!/usr/bin/python

# This file is part of the program FRYSK.
#
# Copyright 2007, Red Hat Inc.
#
# FRYSK is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# FRYSK is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with FRYSK; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
# 
# In addition, as a special exception, Red Hat, Inc. gives You the
# additional right to link the code of FRYSK with code not covered
# under the GNU General Public License ("Non-GPL Code") and to
# distribute linked combinations including the two, subject to the
# limitations in this paragraph. Non-GPL Code permitted under this
# exception must only link to the code of FRYSK through those well
# defined interfaces identified in the file named EXCEPTION found in
# the source code files (the "Approved Interfaces"). The files of
# Non-GPL Code may instantiate templates or use macros or inline
# functions from the Approved Interfaces without causing the
# resulting work to be covered by the GNU General Public
# License. Only Red Hat, Inc. may make changes or additions to the
# list of Approved Interfaces. You must obey the GNU General Public
# License in all respects for all of the FRYSK code and other code
# used in conjunction with FRYSK except the Non-GPL Code covered by
# this exception. If you modify this file, you may extend this
# exception to your version of the file, but you are not obligated to
# do so. If you do not wish to provide this exception without
# modification, you must delete this exception statement from your
# version and license this file solely under the GPL without
# exception.

import os,sys

########################################################################
# Manage creation of the java file
########################################################################

class j:
    def open(self,name):
#       self.j_file = open("/tmp/TestTypeEntry" + name.capitalize() + ".java", 'w')
        self.tool = name
        self.name = "TestTypeEntry" + name.capitalize()
    def write(self,str):
        print str
    def prologue(self,):
        print('''// Generated by gen-type-expect-tests.py

package frysk.debuginfo;

import java.util.logging.Logger;

import lib.dwfl.DwarfDie;
import lib.dwfl.Dwfl;
import lib.dwfl.DwflDieBias;
import frysk.dwfl.DwflCache;
import frysk.proc.Task;
import frysk.testbed.DaemonBlockedAtSignal;
import frysk.testbed.TestLib;
''')
        if (self.tool == "value"):
            print('''
import java.io.*;
import frysk.value.Value;
import frysk.value.Format;
import frysk.debuginfo.DebugInfo;
''')
        elif (self.tool == "type"):
            print('''
import frysk.value.Type;
''')
            
        print('''
public class %s extends TestLib {
    private class ExpectTest {
	DebugInfoFrame frame;
        Task task;
	DwarfDie die;
	DwarfDie[] allDies;
	TypeEntry typeEntry;

	ExpectTest(String executable) {
	    task = new DaemonBlockedAtSignal(executable).getMainTask();
            frame = DebugInfoStackFactory.createDebugInfoStackTrace(task);
	    long pc = frame.getAdjustedAddress();
	    Dwfl dwfl = DwflCache.getDwfl(frame.getTask());
	    DwflDieBias bias = dwfl.getCompilationUnit(pc);
	    die = bias.die;
	    allDies = die.getScopes(pc - bias.bias);
	    typeEntry = new TypeEntry(frame.getTask().getISA());
	}
''' % (self.name))
	
        if (self.tool == "type"):
            print('''
	void compareEqual(Expect[] expect, String myName) {
	     Type varType;
	    
	     for (int i = 0; i < expect.length; i++) {
		 DwarfDie varDie = die.getScopeVar(allDies, expect[i].symbol);
                 if (varDie == null)
                     System.out.println("Error: Cannot find " + expect[i].symbol);
		 assertNotNull(varDie);
		 varType = typeEntry.getType(varDie.getType());
		 assertNotNull(varType);
                 // System.out.println("Expect: " + expect[i].symbol + "\\n'" +
                 //    expect[i].output + "'\\nGot:\\n'" + varType.toPrint());
		 assertEquals(myName + expect[i].symbol, expect[i].output, varType.toPrint());
	     }
	}
    }
''')
        elif (self.tool == "value"):
            print('''
        void compareEqual(Expect[] expect, String myName) {
            // "Print" to a byte array
	    ByteArrayOutputStream baos = new ByteArrayOutputStream(32);
	    PrintWriter pw = new PrintWriter(baos, true);
	    for (int i = 0; i < expect.length; i++) {
                // ??? cache address of x so &x can be checked?
	        if (expect[i].output.indexOf("&") >= 0
                    || expect[i].symbol.indexOf("ptr") >= 0)
		    continue;
                DwarfDie varDie = die.getScopeVar(allDies, expect[i].symbol);
                if (varDie == null)
                    System.out.println("Error: Cannot find " + expect[i].symbol);
                assertNotNull(varDie);
		DebugInfo debugInfo = new DebugInfo(frame);
                Value value =  debugInfo.print(expect[i].symbol, frame);
                value.toPrint(pw, task.getMemory(), Format.NATURAL, 0);
                pw.flush();
                String valueString = baos.toString();
                // System.out.println("Expect: " + expect[i].symbol +
                //     "\\n'" + expect[i].output + "'\\nGot:\\n'" +
                //     valueString + "'" + " " + value.getType());
                assertEquals(myName + expect[i].symbol, expect[i].output, valueString);
                baos.reset();
            }
	}
    }
''')

        print('''
    private class Expect
    {
	String symbol;
	String output;
	Expect (String symbol, String expect)
	{
	    this.symbol = symbol;
	    this.output = expect;
	}
    }

    Logger logger = Logger.getLogger("frysk");

''')

    def start_test(self, tool, name):
        print("    public void test%s () {" % (name))
        if (False):
            print('''
        if (unresolved(5235))
            return;
''')
        print("        Expect [] expect  = {")

    def add_test(self, tool, name, type, etype, decl, value):
        name = name.rstrip()
        type = type.rstrip().replace("\n","\\n")
        etype = etype.rstrip()
        value = value.rstrip().replace("\n","\\n")

        if (tool == "type"):
            print('\t    new Expect("%s","%s"),' % (name, type))
        elif (tool == "value"):
            print('\t    new Expect("%s","%s"),' % (name, value))
        
    def end_test(self, executable, name):
        tokens = executable.split(".")
        print('''
              };

      ExpectTest expectTest = new ExpectTest("%s");
      expectTest.compareEqual(expect, "test%s ");
    }
''' % (os.path.basename(tokens[0]), name))

    def epilogue(self,debug):
        print('''
    }
''')    

########################################################################
# main
########################################################################

def usage ():
    print "Usage " + sys.argv[0] + " -value OR -type <-help> OutputFile File <File>..."
    sys.exit(1)

def open_file (arg):
    if (len (sys.argv) <= arg):
        return False
    try:
        file = open(sys.argv[arg], 'r')
    except IOError:
        print (sys.argv[arg] + " not found")
        sys.exit(1)
    return file

if (len (sys.argv) == 1):
    usage()
debug=0
tool = ""
for t in sys.argv:
    if (t == "-value" or t == "-Value"):
        tool="value"
    elif (t == "-type" or t == "-Type"):
        tool="type"
    elif (t == "-debug"):
        debug=1
    elif (t == "-help"):
        print "Builds TestTypeEntry*.java from input files, using annotations"
        print "in the input files to describe the data type to be tested."
        print "e.g. Given:"
        print "static struct {"
        print "  int int_var;"
        print "} arr_struct [2] = {{1},{2}};"
        print "One would use the annotation:"
        print "// Name: arr_struct"
        print "// Value: {{1},{2}}"
        print "// Type: struct {"
        print "// Type:   int int_var;"
        print "// Type: } [2]"
        usage()
    elif (t.startswith("-")):
        usage()

current_file = 2
if (tool == ""):
    if (sys.argv[1].find("Type") >= 0):
        tool = "type"
    elif (sys.argv[1].find("Value") >= 0):
        tool = "value"
    current_file += 1

d_file = open_file(current_file)
j_file = j()
j_file.open(tool)
j_file.prologue()


test = "Types"
name = type = etype = value = ""
while (True):
    line = d_file.readline()
    if (line == ""):
        current_file += 1
        d_file = open_file(current_file)
        if (not d_file):
            break
    # Output collected test info
    if (line[0:2] != "//"):
        if (name != ""):
            if (test == "Types"):
                j_file.start_test(tool, test)
            j_file.add_test(tool, name, type, type, type, value)
            name = type = etype = value = ""
        continue
    tokens = line.split()
    try:
        # Collect test info
        if (tokens[1] == "Test:"):
            if (test != "Types"):
                j_file.end_test(sys.argv[current_file], test)
            test = line[line.find(tokens[1]) + len(tokens[1]) + 1:].rstrip()
            j_file.start_test(tool, test)
        elif (tokens[1] == "Name:"):
            name = name + line[line.find(tokens[1]) + len(tokens[1]) + 1:]
        elif (tokens[1] == "Type:"):
            type = type + line[line.find(tokens[1]) + len(tokens[1]) + 1:]
        elif (tokens[1] == "EType:"):
            etype = etype + line[line.find(tokens[1]) + len(tokens[1]) + 1:]
        elif (tokens[1] == "Value:"):
            value = value + line[line.find(tokens[1]) + len(tokens[1]) + 1:]
    except IndexError:
        True

j_file.end_test(sys.argv[current_file-1], test)
j_file.epilogue(debug)
