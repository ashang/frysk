<?xml version='1.0'?> <!-- -*- xml -*- -->

<!--

 This file is part of the program FRYSK.

 Copyright 2006, Red Hat Inc.

 FRYSK is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by
 the Free Software Foundation; version 2 of the License.

 FRYSK is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with FRYSK; if not, write to the Free Software Foundation,
 Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
 
 In addition, as a special exception, Red Hat, Inc. gives You the
 additional right to link the code of FRYSK with code not covered
 under the GNU General Public License ("Non-GPL Code") and to
 distribute linked combinations including the two, subject to the
 limitations in this paragraph. Non-GPL Code permitted under this
 exception must only link to the code of FRYSK through those well
 defined interfaces identified in the file named EXCEPTION found in
 the source code files (the "Approved Interfaces"). The files of
 Non-GPL Code may instantiate templates or use macros or inline
 functions from the Approved Interfaces without causing the
 resulting work to be covered by the GNU General Public
 License. Only Red Hat, Inc. may make changes or additions to the
 list of Approved Interfaces. You must obey the GNU General Public
 License in all respects for all of the FRYSK code and other code
 used in conjunction with FRYSK except the Non-GPL Code covered by
 this exception. If you modify this file, you may extend this
 exception to your version of the file, but you are not obligated to
 do so. If you do not wish to provide this exception without
 modification, you must delete this exception statement from your
 version and license this file solely under the GPL without
 exception.

-->

<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
 "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">

<!-- http://docbook.sourceforge.net/snapshots/xsl/manpages/README -->

<refentry id="ftrace">

  <refentryinfo>
    <title>ftrace</title>
    <date>July 12 2006</date>
  </refentryinfo>
  
  <refmeta>
    <refentrytitle>ftrace</refentrytitle>
    <manvolnum>1</manvolnum>
  </refmeta>

  <refnamediv>
    <refname>ftrace</refname>
    <refpurpose>Runs the frysk systemcall and function call tracing utility</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
      <command>ftrace</command>
      <arg choice="opt">-s=<replaceable>SYSCALL</replaceable>[,<replaceable>SYSCALL</replaceable>...]</arg>
      <arg choice="opt">-plt=<replaceable>RULE</replaceable>[,<replaceable>RULE</replaceable>...]</arg>
      <arg choice="opt">-dyn=<replaceable>RULE</replaceable>[,<replaceable>RULE</replaceable>...]</arg>
      <arg choice="opt">-sym=<replaceable>RULE</replaceable>[,<replaceable>RULE</replaceable>...]</arg>
      <arg choice="opt">--</arg>
      <arg choice="plain"><replaceable>command</replaceable> <arg choice="opt"><replaceable>arguments</replaceable>...</arg></arg>
    </cmdsynopsis>
  </refsynopsisdiv>
  
  <refsect1>
    <title>DESCRIPTION</title>

    <para><function>ftrace</function> starts given
    <replaceable>command</replaceable> and according to tracing script
    given via command line argument, it traces its system calls,
    runtime library calls, and symbol entry points in general.  It
    uses the Frysk framework to implement tracing.</para>

    <para>Which functions and/or syscalls <function>ftrace</function>
    traces, and whether it traces given group at all, is configurable
    through command-line options <option>-s</option>,
    <option>-plt</option>, <option>-dyn</option> and
    <option>-sym</option>.  Neither option is turned on by
    default.</para>

    <variablelist>
      <varlistentry>
	<term>-s=<replaceable>SYSCALL</replaceable>[,<replaceable>SYSCALL</replaceable>...]</term>
	<listitem>
          <para>Stack trace on this set of system calls.  Each
          <replaceable>SYSCALL</replaceable> entry is name of one
          system call.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
	<term>-plt=<replaceable>RULE</replaceable>[,<replaceable>RULE</replaceable>...]</term>
	<listitem>
	  <para>Trace library calls done via PLT entries matching each
	  given <replaceable>RULE</replaceable>.  By tracing PLT
	  entry, you effectively trace calls done FROM given library
	  or executable, and generally can't say which library the
	  call leads TO.  (At least for now.  Ftrace may grow brains
	  for this in future.)  See below for description of
	  <replaceable>RULE</replaceable> syntax.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
	<term>-dyn=<replaceable>RULE</replaceable>[,<replaceable>RULE</replaceable>...]</term>
	<listitem>
	  <para>Trace calls through the symbol entry points.  By
	  tracing entry points, you catch all calls that end up at
	  this symbol, including the calls that don't go through PLT
	  and as such are not intended as inter-library calls, but
	  rather intra-library calls.  This is probably not what you
	  usually want, because you get lots of output when various
	  functions call each other in the library internals.  On the
	  other hand, it may be useful to cherry pick few entry points
	  to see when or if they are called, and with which arguments.
	  See below for description of <replaceable>RULE</replaceable>
	  syntax.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>-sym=<replaceable>RULE</replaceable>[,<replaceable>RULE</replaceable>...]</term>
	<listitem>
	  <para>Just like <option>-dyn</option>, but doesn't look for
	  symbols in dynamic symbol table, but normal symbol table.
	  (Which doesn't have to be present, e.g. when a binary is
	  stripped.)  See below for description of
	  <replaceable>RULE</replaceable> syntax.</para>
	</listitem>
      </varlistentry>

    </variablelist>
  </refsect1>

  <refsect1>
    <title>RULE SYNTAX</title>

    <para>To decide which PLT slots or entry points should be traced,
    following process takes place.  Initial working set is empty.
    Rules, if present, are then enumerated from left to right, and set
    is modified depending on the rules.  Rules are delimited by a
    colon.  Syntax of each rule is following:</para>

    <para>[-][#]<replaceable>pattern</replaceable></para>

    <para>Optional &quot;-&quot; at the beginning of the rule means
    removal from the working set.  When the sign is omitted, the
    default action is to add to the working set.  Optional
    &quot;#&quot; means that fltrace should print out stack trace when
    it hits the call.  The combination of &quot;-#&quot; then means
    that the call should still be traced, but stack trace shouldn't be
    generated.  <replaceable>pattern</replaceable> defines which PLT
    entries from which libraries should be added or removed from
    working set.  Syntax of pattern is the following:</para>

    <para><optional><replaceable>symbol</replaceable></optional><optional>@<replaceable>soname</replaceable></optional><optional>@@<replaceable>version</replaceable></optional></para>

    <para>All three components, <replaceable>symbol</replaceable>,
    <replaceable>soname</replaceable> and
    <replaceable>version</replaceable>, are written using extended
    regular expression syntax.  Any of the components can be omitted,
    missing component is then wild card matching anything.  By
    extension, empty pattern matches all symbols of all versions in
    all libraries and in the executable itself.</para>

    <para><replaceable>symbol</replaceable> component is matched
    against name of symbol associated with PLT slot under
    consideration.  Whole symbol name has to match.</para>

    <para><replaceable>soname</replaceable> component is matched
    against a soname of a library in which we wish to track the call.
    If the library has no associated soname or it is a main
    executable, the match is done against the file name (without a
    path).  Special soname is distinguished, "MAIN", which always
    matches main executable.</para>

    <para><replaceable>version</replaceable> component is matched
    against version associated with symbol.  If the symbol has no
    associated version, it is considered to be an empty string.  (It
    is possible to request symbol without a version with the pattern
    "foo@@".)</para>

    <para>Empty rule is considered to miss all components, not contain
    symbol component with empty contents, which makes little sense.
    If you need to match empty symbol, use regular expression
    "^$".</para>

    <informalexample>
      <para>Trace all plt library calls:</para>
      <cmdsynopsis><command>fltrace -plt= ls</command></cmdsynopsis>
      <para>Trace all library calls to functions that contain
      substring "write" in their names:</para>
      <cmdsynopsis><command>fltrace -plt=&quot;.*write.*&quot; ls</command></cmdsynopsis>
      <para>Trace memory functions done from libraries, i.e. not from
      main executable:</para>
      <cmdsynopsis><command>fltrace -plt=&quot;[cm]alloc|free,-@MAIN" ls</command></cmdsynopsis>
      <para>Stack trace on everything, except for memory allocation
      functions (which should still be traced):</para>
      <cmdsynopsis><command>fltrace -plt=&quot;#,-#[cm]alloc|free" ls</command></cmdsynopsis>
    </informalexample>

  </refsect1>

  <!-- refsect1>
    <title>EXIT STATUS</title>
    <para></para>
  </refsect1 -->
  
  <!-- refsect1>
    <title>RETURN VALUES</title>
    <para></para>
  </refsect1 -->
  
  <!-- refsect1>
    <title>ENVIRONMENT</title>
    <para></para>
  </refsect1 -->
  
  <!-- refsect1>
    <title>FILES</title>
    <para></para>
  </refsect1 -->

  <!-- refsect1>
    <title>DIAGNOSTICS</title>
    <para></para>
  </refsect1 -->
  
  <!-- refsect1>
    <title>ERRORS</title>
      <para></para>   
  </refsect1 -->    

  <refsect1>
    <title>SEE ALSO</title>
    <para>funit(8) fcatch(1) fcore(1) fstack(1) fstep(1)</para>
  </refsect1>
  
  <!-- refsect1>
    <title>STANDARDS</title>
    <para></para>
  </refsect1 -->
  
  <!-- refsect1>
    <title>HISTORY</title>
    <para></para>
  </refsect1 -->
  
  <!-- refsect1>
    <title>AUTHORS</title>
    <para></para>
  </refsect1 -->
  
  <refsect1>
    <title>BUGS</title>
    <para> The option parser is greedy when looking for options so running ftrace on a program that uses options can be a problem, use -- to split between ftrace and the program. So change from:</para>
    <screen>~/prefix/bin/ftrace ~/prefix/lib64/frysk/funit --arch 32 frysk.proc.TestAbandon</screen>
    <para>to</para>
    <screen>~/prefix/bin/ftrace -- ~/prefix/lib64/frysk/funit --arch 32 frysk.proc.TestAbandon</screen>
    <para>Report bugs to <ulink url="http:/sources.redhat.com/ftrace">
    http://sources.redhat.com/ftrace/ </ulink>. </para>
  </refsect1>
  
  <!-- refsect1>
    <title>SECURITY CONSIDERATIONS</title>
  </refsect1 -->

  <refsect1>
    <title>BUGS</title>
    <para>I think ltrace wouldn't handle tracing one function both through entry point and plt.</para>
    <para>Report bugs to <ulink url="http:/sources.redhat.com/frysk">http://sources.redhat.com/frysk</ulink>.</para>
  </refsect1>

</refentry>
