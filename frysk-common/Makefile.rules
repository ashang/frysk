# This file is part of FRYSK.
#
# Copyright 2005, Red Hat Inc.
#
# FRYSK is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# FRYSK is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with FRYSK; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

# Initialize everything to empty and then use += to add things in.

SUFFIXES =
BUILT_SOURCES = $(GEN_BUILT_MKJAVA) $(GEN_BUILT_SHJAVA)
CLEANFILES = $(BUILT_SOURCES) $(GEN_BUILT_CLASSES)
noinst_PROGRAMS =
bin_PROGRAMS =
noinst_LIBRARIES =
LDADD = 
check_SCRIPTS =
TESTS =
GEN_CLASSPATH =
GEN_SOURCEPATH = $(srcdir) $(top_builddir)
empty=
space=$(empty) $(empty)
GEN_BUILT_CLASSES =
GEN_CLASSDIR = classes

# Make up some javacflags

SOURCEPATH = $(subst $(space),:,$(strip $(GEN_SOURCEPATH)))
CLASSPATH = $(subst $(space),:,$(strip $(GEN_CLASSPATH)))
DBPATH = $(subst $(space),:,$(strip \
	$(patsubst %.jar,%.db,$(filter %.jar,$(GEN_CLASSPATH))) \
	$(foreach dir,$(patsubst %/$(GEN_CLASSDIR),%,$(filter-out %.jar,$(GEN_CLASSPATH))),$(dir)/$(notdir $(dir)).db) \
	))

JAVAC = javac
JAVACFLAGS = \
	-g \
	-1.4 \
	-sourcepath $(SOURCEPATH) \
	-classpath $(CLASSPATH)


# XXX: GCJ: I think there should be a -Wextraneous-throws; I think
# -Wno-deprecated is backward; I think -Wredundant-modifiers is broken
# with gcc4.  It appears to complain about abstract methods in a
# non-abstract class when the class actually is abstract.

AM_GCJFLAGS = \
	$(patsubst %,-I%,$(GEN_SOURCEPATH) $(GEN_CLASSPATH)) \
	-Werror \
	-Wall \
	-fPIC \
	$(ZZZ)


AM_CXXFLAGS = \
	-I$(srcdir) \
	-I$(srcdir)/include \
	-I$(top_buildir) \
	-Werror \
	-Wall \
	-fpic \
	$(ZZZ)


# Rule for building a .java file from an input .mkclass file.  This
# lets us specify CLASS.java directly in the BUILT_SOURCES list.

MKJAVA = $(srcdir)/common/mkjava.sh
SUFFIXES += .mkjava
.mkjava.java:
	rm -f $*.tmp
	$(SHELL) $(MKJAVA) < $(srcdir)/$*.mkjava > $*.tmp $@
	chmod a-w $*.tmp
	mv -f $*.tmp $@
$(MKJAVA_BUILT): $(MKJAVA)
BUILT_SOURCES += $(MKJAVA_BUILT)

# Rule for building a .java file from a shell|mkjava pipeline.

SUFFIXES += .shjava
.shjava.java:
	rm -f $*.tmp
	$(SHELL) $< | $(SHELL) $(MKJAVA) > $*.tmp $@
	chmod a-w $*.tmp
	mv -f $*.tmp $@
$(SHJAVA_BUILT): $(MKJAVA)
BUILT_SOURCES += $(SHJAVA_BUILT)



# Since a single .java file can result in multiple .class files (due
# to inner classes) trying to track all those would get complicated.
# Instead generate a .classes file containing the list of .class files
# that will be created and use that for all dependencies.

# jv-scan occasionally gets it wrong generating extra classes, work
# around this by checking that each class really exists.

# Need to store the .class files in a separate directory as otherwize
# GCJ will include those instead of the original .java files.

SUFFIXES += .classes
.java.classes:
	mkdir -p $(GEN_CLASSDIR)
	rm -f $(GEN_CLASSDIR)/$*.class $(GEN_CLASSDIR)/$*\$$*.class
	$(JAVAC) -d $(GEN_CLASSDIR) $(JAVACFLAGS) $<
	echo '# $<' > $*.classes.tmp
	( cd $(GEN_CLASSDIR) && ls $*.class $*\$$*.class 2>/dev/null ) \
		| sed -e 's,.class$$,,' \
		| sort -f \
		> $*.classes.tmp
	mv -f $*.classes.tmp $*.classes
#	jv-scan --list-class '$<' | tr '[ ]' '[\n]' | \
#		while read class ; do \
#			file=`echo $${class} | tr '[.]' '[/]'`.class ; \
#			if test -r $${file} ; then \
#				echo $${class} ; \
#			else \
#				echo "# $${class} -- jv-scan BUG?" ; \
#			fi \
#		done >> $*.classes.tmp

# clean up the mess
clean-local: clean-class-files
.PHONY: clean-class-files
clean-class-files:
	rm -rf $(GEN_CLASSDIR)

# Generate a .h file (using CNI) from the .classes file.

GCJH = $(GCJ)h
.classes.h:
	$(GCJH) -I$(GEN_CLASSDIR) $(GCJHFLAGS) `sed -e '/^#/d' $<`


# Shared library rule (for moment assume that .a contains PIC code).
SUFFIXES += .so
.a.so:
	$(CC) -shared -o $@.tmp \
		-Wl,--whole-archive,$<,--no-whole-archive \
		-Wl,--soname,$@,-z,-defs
	if readelf -d $@.tmp | fgrep -q TEXTREL; then exit 1; fi
	mv $@.tmp $@

# Assembler rule.

.S.o:
	$(CCASCOMPILE) -c -o $@ $<

# Hack to save us constantly editing this file.  The assumption is
# that all .java and .cxx files are always built.  Recursively call
# make to ensure that Makefile is up-to-date.

$(srcdir)/Makefile.gen: $(srcdir)/common/Makefile.gen.sh
	cd $(srcdir) && ./common/Makefile.gen.sh $(GEN_DIRS) $(GEN_JARS)
.PHONY: autogen
autogen: clean
	cd $(srcdir) && ./autogen.sh

# Given a .jar, just convert it into a .o, and a .db

SUFFIXES += .jar
.jar.o:
	$(GCJCOMPILE) -fjni -c $<

# Since automake only adds GCJCOMPILE to Makefile.in when its seen
# .java source, provide our own definition.
GCJCOMPILE ?= $(GCJ) $(AM_GCJFLAGS) $(GCJFLAGS)

SUFFIXES += .db
.jar.db:
	gcj-dbtool -n $@.tmp
	gcj-dbtool -a $@.tmp $*.jar lib$*.so
	mv $@.tmp $@


# Build the TestJUnits program.

TestRunner_SOURCES = TestRunner.java
TestRunner_LINK = ${GCJLINK}
TestRunner_LDFLAGS = --main=TestRunner
TESTS += TestRunner
noinst_PROGRAMS += TestRunner
GEN_CLASSPATH += ../frysk-imports/junit.jar
GEN_BUILT_CLASSES += TestRunner.classes
CLEANFILES += TestRunner.java
LDADD += $(LIBJUNIT)
LIBJUNIT ?= ../frysk-imports/libjunit.a

TestRunner.java: common/TestRunner.sh Makefile
	$(srcdir)/common/TestRunner.sh $(GEN_JUNIT_TESTS) > TestRunner.tmp
	mv  TestRunner.tmp  TestRunner.java


# Build a wrapper script for GIJ so that running the interpreter is
# easier.
noinst_PROGRAMS += gij.sh
gij.sh: Makefile
	rm -f gij.tmp
	echo '#!/bin/sh' >> gij.tmp
	echo 'gij --cp $(GEN_CLASSDIR):$(CLASSPATH) -Dgnu.gcj.precompiled.db.path=$(DBPATH) "$$@"' >> gij.tmp
	mv gij.tmp gij.sh
	chmod a+x gij.sh

# When it comes to clean, automake forgets to scrub the .Po files
# (which contain built dependencies).  After a file rename or similar,
# this can result in a .Po file refering to a non-existant file.  Hack
# around it by emptying all the .Po files.
clean-local: clean-local-po
.PHONY: clean-local-po
clean-local-po:
	find * -name '*.Po' -exec cp /dev/null \{\} \;
