# This file is part of the program FRYSK.
#
# Copyright 2005, Red Hat Inc.
#
# FRYSK is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# FRYSK is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with FRYSK; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
# 
# In addition, as a special exception, Red Hat, Inc. gives You the
# additional right to link the code of FRYSK with code not covered
# under the GNU General Public License ("Non-GPL Code") and to
# distribute linked combinations including the two, subject to the
# limitations in this paragraph. Non-GPL Code permitted under this
# exception must only link to the code of FRYSK through those well
# defined interfaces identified in the file named EXCEPTION found in
# the source code files (the "Approved Interfaces"). The files of
# Non-GPL Code may instantiate templates or use macros or inline
# functions from the Approved Interfaces without causing the
# resulting work to be covered by the GNU General Public
# License. Only Red Hat, Inc. may make changes or additions to the
# list of Approved Interfaces. You must obey the GNU General Public
# License in all respects for all of the FRYSK code and other code
# used in conjunction with FRYSK except the Non-GPL Code covered by
# this exception. If you modify this file, you may extend this
# exception to your version of the file, but you are not obligated to
# do so. If you do not wish to provide this exception without
# modification, you must delete this exception statement from your
# version and license this file solely under the GPL without
# exception.

# Initialize everything to empty and then use += to add things in.

SUFFIXES =
BUILT_SOURCES = $(GEN_BUILT_MKJAVA) $(GEN_BUILT_SHJAVA)
CLEANFILES = $(BUILT_SOURCES)
noinst_PROGRAMS =
bin_PROGRAMS =
sbin_PROGRAMS =
libexec_PROGRAMS =
noinst_LIBRARIES =
LDADD = 

check_SCRIPTS =
TESTS =
GEN_CLASSPATH =
GEN_SOURCEPATH = $(srcdir) $(top_builddir)
empty=
space=$(empty) $(empty)
GEN_CLASSDIR = classes
EXTRA_DIST = 

# The list of libraries for the GCJ programs is different to that of
# the standalone .c programs.  Accumulate the GCJ list in
# GEN_GCJ_LDADD, and then use that to construct the corresponding
# build-tree RPATH list (colon separated list of directories that are
# searched at runtime).

GEN_GCJ_LDADD = 
GEN_GCJ_RPATH = \
	$(patsubst -L%,%,$(filter -L%, $(GEN_GCJ_LDADD)))
GEN_GCJ_RPATHS = \
	$(patsubst %/.,%, \
		$(patsubst %,@abs_top_builddir@/%, \
			$(filter .%,$(GEN_GCJ_RPATH))) \
		$(GEN_GCJ_RPATH) \
	)
BUILD_GCJ_RPATH = $(subst $(space),:,$(sort $(GEN_GCJ_RPATHS)))
GEN_GCJ_RPATH_FLAGS = \
	-Djava.library.path=$(BUILD_GCJ_RPATH) \
	-Wl,-rpath,$(BUILD_GCJ_RPATH)

# Get some common macro definitions

ACLOCAL_AMFLAGS = -I common/m4

# Make up some javacflags

SOURCEPATH = $(subst $(space),:,$(strip $(GEN_SOURCEPATH)))
CLASSPATH = $(subst $(space),:,$(strip $(GEN_CLASSPATH)))
DBPATH = $(subst $(space),:,$(strip \
	$(patsubst %.jar,%.db,$(filter %.jar,$(GEN_CLASSPATH))) \
	$(foreach dir,$(patsubst %/$(GEN_CLASSDIR),%,$(filter-out %.jar,$(GEN_CLASSPATH))),$(dir)/$(notdir $(dir)).db) \
	))

JAVAC = @JAVAC@
JAVACFLAGS = @JAVACFLAGS@


# XXX: GCJ: I think there should be a -Wextraneous-throws; I think
# -Wno-deprecated is backward; I think -Wredundant-modifiers is broken
# with gcc4.  It appears to complain about abstract methods in a
# non-abstract class when the class actually is abstract.

AM_GCJFLAGS = \
	$(patsubst %,-I%,$(GEN_SOURCEPATH) $(GEN_CLASSPATH)) \
	-Werror \
	-Wall \
	-fPIC \
	$(ZZZ)


AM_CXXFLAGS = \
	-I$(srcdir) \
	-I$(top_builddir) \
	-Werror \
	-Wall \
	-fpic \
	$(ZZZ)


# Rule for building a .java file from an input .mkclass file.  This
# lets us specify CLASS.java directly in the BUILT_SOURCES list.

MKJAVA = $(srcdir)/common/mkjava.sh
SUFFIXES += .mkjava
.mkjava.java:
	rm -f $*.tmp
	$(SHELL) $(MKJAVA) < $(srcdir)/$*.mkjava > $*.tmp $@
	chmod a-w $*.tmp
	mv -f $*.tmp $@
$(GEN_BUILT_MKJAVA): $(MKJAVA)

# Rule for building a .java file from a shell|mkjava pipeline.

SUFFIXES += .shjava
.shjava.java:
	rm -f $*.tmp
	$(SHELL) $< | $(SHELL) $(MKJAVA) > $*.tmp $@
	chmod a-w $*.tmp
	mv -f $*.tmp $@
$(SHJAVA_BUILT): $(MKJAVA)

# Mimic autoconf's behavior, by doing it in the Makefile all the
# variables are automatically expanded.

# Don't be confused by top_builddir and top_srcdir, they are actually
# the directory corresponding to current sub-directory (frysk-gui,
# frysk-core, ...).

SUFFIXES += .javain
.javain.java:
	rm -f $*.tmp
	sed < $< \
		-e 's,[@]prefix[@],@prefix@,g' \
		-e 's,[@]bindir[@],@bindir@,g' \
		-e 's,[@]libdir[@],@libdir@,g' \
		-e 's,[@]libexecdir[@],@libexecdir@,g' \
		-e 's,[@]datadir[@],@datadir@,g' \
		-e 's,[@]builddir[@],@top_builddir@,g' \
		-e 's,[@]srcdir[@],@top_srcdir@,g' \
		-e 's,[@]abs_builddir[@],@abs_top_builddir@,g' \
		-e 's,[@]abs_srcdir[@],@abs_top_srcdir@,g' \
		-e 's,[@]gladedir[@],$(gladedir),g' \
		-e 's,[@]imagedir[@],$(imagedir),g' \
		-e 's,[@]pkgdatadir[@],$(pkgdatadir),g' \
		-e 's,[@]pkglibdir[@],$(pkglibdir),g' \
		-e 's,[@]pkgincludedir[@],$(pkgincludedir),g' \
		> $*.tmp
	mv -f $*.tmp $@


# Since a single .java file can result in multiple .class files (due
# to inner classes) trying to track all those would get complicated.
# Instead generate a .classes file containing the list of .class files
# that will be created and use that for all dependencies.

# jv-scan occasionally gets it wrong generating extra classes, work
# around this by checking that each class really exists.

# Need to store the .class files in a separate directory as otherwize
# GCJ will include those instead of the original .java files.

SUFFIXES += .classes
.java.classes:
	mkdir -p $(GEN_CLASSDIR)
	rm -f $(GEN_CLASSDIR)/$*.class $(GEN_CLASSDIR)/$*\$$*.class $*.log
	$(JAVAC) -d $(GEN_CLASSDIR) $(JAVACFLAGS) $< 2>&1 | tee $*.log
	if test -s $*.log ; \
	then rm $*.log ; false ; \
	fi
	echo '# $<' > $*.classes.tmp
	( cd $(GEN_CLASSDIR) > /dev/null && ls $*.class $*\$$*.class 2>/dev/null ) \
		| sed -e 's,.class$$,,' \
		| sort -f \
		> $*.classes.tmp
	mv -f $*.classes.tmp $*.classes
#	jv-scan --list-class '$<' | tr '[ ]' '[\n]' | \
#		while read class ; do \
#			file=`echo $${class} | tr '[.]' '[/]'`.class ; \
#			if test -r $${file} ; then \
#				echo $${class} ; \
#			else \
#				echo "# $${class} -- jv-scan BUG?" ; \
#			fi \
#		done >> $*.classes.tmp

# clean up the mess
clean-local: clean-class-files
.PHONY: clean-class-files
clean-class-files:
	rm -rf $(GEN_CLASSDIR)

# Generate a .h file (using CNI) from the corresponding .java file.

# A single .java file can result in multiple .class files (due to
# inner classes) and they in turn lead to multiple .h files.  Instead
# of trying to track all of them just generate the main .h file
# filling in the others as a side-effect.

# Need to store the intermediate .class files in a separate directory
# as otherwize GCJ will include a possibly out-dated .class file
# instead of the latest .java file leading to screwed up in
# dependencies.

# jv-scan occasionally gets it wrong generating extra classes
# (actually it is that jv-scan's output doesn't necessarially agree
# with that of JAVAC), work around this by checking that each class
# really exists.

GCJH = $(GCJ)h
.java.h:
	classes=`jv-scan --list-class '$<'` ; \
	tmpdir=`echo $$classes | ( read a b ; echo $$a )`.tmp ; \
	rm -rf $$tmpdir ; \
	mkdir -p $$tmpdir ; \
	$(GCJCOMPILE) -C -d $$tmpdir '$<' ; \
	for class in $$classes ; do \
		file=`echo $${class} | tr '[.]' '[/]'`.class ; \
		if test -r $$tmpdir/$${file} ; then \
			$(GCJH) -I $$tmpdir -d . $(GCJHFLAGS) $$class ; \
		fi ; \
	done ; \
	rm -rf $$tmpdir

# Shared library rule (for moment assume that .a contains PIC code).
SUFFIXES += .so
.a.so:
	$(CC) -shared -o $@.tmp \
		-Wl,--whole-archive,$<,--no-whole-archive \
		-Wl,--soname,$@,-z,-defs
	if readelf -d $@.tmp | fgrep -q TEXTREL; then exit 1; fi
	mv $@.tmp $@

# Clueless automake: Use a phony DATA entry to convince AUTOMAKE that
# it really should install a .so file into LIBDIR.  The obvious
# choice, lib_LIBRARIES, attracts an error because .so isn't a valid
# extention (serious!); mean while LTLIBRARIES insists that the world
# should use LIBTOOL.

solibdir = $(libdir)
solib_DATA =

# The shared java directory (typically /usr/share/java/; contains
# things like .jar files.

javadir = $(datadir)/java
java_DATA =

# Assembler rule.

.S.o:
	$(CCASCOMPILE) -c -o $@ $<

# Hack to save us constantly editing this file.  The assumption is
# that all .java and .cxx files are always built.  Recursively call
# make to ensure that Makefile is up-to-date.

$(srcdir)/Makefile.gen: $(srcdir)/common/Makefile.gen.sh
	cd $(srcdir) && ./common/Makefile.gen.sh $(GEN_ARGS)
.PHONY: autogen
autogen: clean
	cd $(srcdir) && ./autogen.sh

# Given a .jar, just convert it into a .o, and a .db

SUFFIXES += .jar
.jar.o:
	$(GCJCOMPILE) -fjni -c $<

# Since automake only adds GCJCOMPILE to Makefile.in when its seen
# .java source, provide our own definition.
GCJCOMPILE ?= $(GCJ) $(AM_GCJFLAGS) $(GCJFLAGS)

SUFFIXES += .db
.jar.db:
	gcj-dbtool -n $@.tmp
	gcj-dbtool -a $@.tmp $*.jar lib$*.so
	mv $@.tmp $@


# Build the TestJUnits program.

TestRunner_SOURCES = TestRunner.java
TestRunner_LINK = ${GCJLINK}
TestRunner_LDFLAGS = --main=TestRunner $(GEN_GCJ_RPATH_FLAGS)
TestRunner_LDADD = $(LIBJUNIT) $(GEN_GCJ_LDADD)
TESTS += TestRunner
noinst_PROGRAMS += TestRunner
CLEANFILES += TestRunner.java

TestRunner.java: common/TestRunner.sh Makefile
	$(srcdir)/common/TestRunner.sh $(GEN_JUNIT_TESTS) > TestRunner.tmp
	mv  TestRunner.tmp  TestRunner.java


# Build a wrapper script for GIJ so that running the interpreter is
# easier.
noinst_PROGRAMS += gij.sh
gij_sh_SOURCES = 
gij.sh: Makefile
	rm -f gij.tmp
	echo '#!/bin/sh' >> gij.tmp
	echo 'gij --cp $(GEN_CLASSDIR):$(CLASSPATH) -Dgnu.gcj.precompiled.db.path=$(DBPATH) "$$@"' >> gij.tmp
	mv gij.tmp gij.sh
	chmod a+x gij.sh

# When it comes to clean, automake forgets to scrub the .Po files
# (which contain built dependencies).  After a file rename or similar,
# this can result in a .Po file refering to a non-existant file.  Hack
# around it by emptying all the .Po files.
clean-local: clean-local-po
.PHONY: clean-local-po
clean-local-po:
	find . -name '*.Po' -exec cp /dev/null \{\} \;

SUFFIXES += .fig .jpg .pdf .eps .gif .txt
.fig.jpg:
	mkdir -p `dirname $@`
	$(FIG2DEV) -L jpeg $< $@
.fig.pdf:
	mkdir -p `dirname $@`
	$(FIG2DEV) -L pdf $< $@
.fig.eps:
	mkdir -p `dirname $@`
	$(FIG2DEV) -L eps $< $@
.fig.gif:
	mkdir -p `dirname $@`
	$(FIG2DEV) -L gif $< $@
.fig.txt:
	mkdir -p `dirname $@`
	echo "@center See the @sc{pdf} or @sc{html} documentation." > $@
BUILT_SOURCES += $(GEN_FIG:.fig=.jpg)


# Add some needed files to the distribution
EXTRA_DIST += 	common/Makefile.gen.sh \
				common/mkjava.sh \
				common/TestRunner.sh \
				EXCEPTION
