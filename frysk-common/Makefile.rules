# This file is part of the program FRYSK.
#
# Copyright 2005, 2006, Red Hat Inc.
#
# FRYSK is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# FRYSK is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with FRYSK; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
# 
# In addition, as a special exception, Red Hat, Inc. gives You the
# additional right to link the code of FRYSK with code not covered
# under the GNU General Public License ("Non-GPL Code") and to
# distribute linked combinations including the two, subject to the
# limitations in this paragraph. Non-GPL Code permitted under this
# exception must only link to the code of FRYSK through those well
# defined interfaces identified in the file named EXCEPTION found in
# the source code files (the "Approved Interfaces"). The files of
# Non-GPL Code may instantiate templates or use macros or inline
# functions from the Approved Interfaces without causing the
# resulting work to be covered by the GNU General Public
# License. Only Red Hat, Inc. may make changes or additions to the
# list of Approved Interfaces. You must obey the GNU General Public
# License in all respects for all of the FRYSK code and other code
# used in conjunction with FRYSK except the Non-GPL Code covered by
# this exception. If you modify this file, you may extend this
# exception to your version of the file, but you are not obligated to
# do so. If you do not wish to provide this exception without
# modification, you must delete this exception statement from your
# version and license this file solely under the GPL without
# exception.

# Initialize everything to empty and then use += to add things in.

SUFFIXES =
BUILT_SOURCES = 
CLEANFILES = $(BUILT_SOURCES)
noinst_PROGRAMS =
bin_PROGRAMS =
sbin_PROGRAMS =
libexec_PROGRAMS =
pkglibexec_PROGRAMS =
pkglibexecdir = $(libexecdir)/@PACKAGE@
noinst_LIBRARIES =
man_MANS =
LDADD = 

check_SCRIPTS =
check_PROGRAMS =
TESTS =
GEN_CLASSPATH =
GEN_SOURCEPATH = $(srcdir) $(top_builddir)
empty=
space=$(empty) $(empty)
GEN_CLASSDIR = classes
EXTRA_DIST = 

# The list of libraries for the GCJ programs is different to that of
# the standalone .c programs.  Accumulate the GCJ list in
# GEN_GCJ_LDADD.

GEN_GCJ_LDADD = 

# Take the LDADD list and transform it into a dynamic shared library
# list.  This can then, in turn be converted into an in-build-tree
# RPATH to wire into in-build-tree program that need to access those
# shared libraries.

# Convert LDADD's .a into -L<dir> -llib
GEN_GCJ_SO_FLAGS = \
	$(foreach lib, $(GEN_GCJ_LDADD), \
		$(if $(filter -L%,$(lib)), $(lib)) \
		$(if $(filter -l%,$(lib)), $(lib)) \
		$(if $(filter %.a,$(lib)), \
			$(patsubst %,-L%,$(dir $(lib))) \
			$(patsubst lib%.a,-l%,$(notdir $(lib))) \
			) \
		)
# Just the directories.
GEN_GCJ_SO_DIRS = \
	$(patsubst -L%,%,$(filter -L%, $(GEN_GCJ_SO_FLAGS)))
# Add absolute versions of each directory.
GEN_GCJ_RPATHS = \
	$(patsubst %/./,%, $(patsubst %/.,%, \
		$(foreach lib, $(GEN_GCJ_SO_DIRS), \
			$(if $(filter /%,$(lib)), $(lib)) \
			$(if $(filter .%,$(lib)), \
				$(patsubst %,@abs_top_builddir@/%, $(lib)) \
				$(lib) \
				) \
			) \
		))
GEN_GCJ_RPATH = $(subst $(space),:,$(sort $(GEN_GCJ_RPATHS)))
GEN_GCJ_RPATH_FLAGS = \
	-Djava.library.path=$(GEN_GCJ_RPATH) \
	-Wl,-rpath,$(GEN_GCJ_RPATH)

# Get some common macro definitions

ACLOCAL_AMFLAGS = -I common/m4

# Make up some javacflags

SOURCEPATH = $(subst $(space),:,$(strip $(GEN_SOURCEPATH)))
CLASSPATH = $(subst $(space),:,$(strip $(GEN_CLASSPATH)))
DBPATH = $(subst $(space),:,$(strip \
	$(patsubst %.jar,%.db,$(filter %.jar,$(GEN_CLASSPATH))) \
	$(foreach dir,$(patsubst %/$(GEN_CLASSDIR),%,$(filter-out %.jar,$(GEN_CLASSPATH))),$(dir)/$(notdir $(dir)).db) \
	))

# XXX: GCJ: I think there should be a -Wextraneous-throws; I think
# -Wno-deprecated is backward; I think -Wredundant-modifiers is broken
# with gcc4.  It appears to complain about abstract methods in a
# non-abstract class when the class actually is abstract.

AM_GCJFLAGS = \
	$(patsubst %,-I%,$(GEN_SOURCEPATH) $(GEN_CLASSPATH)) \
	-Werror \
	-Wall \
	-fPIC \
	$(ZZZ)


AM_CXXFLAGS = \
	-I$(srcdir) \
	-I$(top_builddir) \
	-Werror \
	-Wall \
	-fPIC \
	$(ZZZ)

AM_CFLAGS = \
	-I$(srcdir) \
	-I$(top_builddir) \
	-Werror \
	-Wall \
	-fPIC \
	$(ZZZ)


# Rule for building a .java file from an input .mkclass file.  This
# lets us specify CLASS.java directly in the BUILT_SOURCES list.

MKJAVA = $(srcdir)/common/mkjava.sh
SUFFIXES += .mkjava
.mkjava.java:
	rm -f $*.tmp
	$(SHELL) $(MKJAVA) < $(srcdir)/$*.mkjava > $*.tmp $@
	chmod a-w $*.tmp
	mv -f $*.tmp $@

# Rule for building a .java file from a shell|mkjava pipeline.

SUFFIXES += .shjava
.shjava.java:
	rm -f $*.tmp
	export CC=$(CC) ; \
	$(SHELL) $< | $(SHELL) $(MKJAVA) > $*.tmp $@
	chmod a-w $*.tmp
	mv -f $*.tmp $@

# Similar to autoconf's config.status --file=NEW:OLD but with all
# variables expanded.

# Don't be confused by top_builddir and top_srcdir, they are actually
# the directory corresponding to current sub-directory (frysk-gui,
# frysk-core, ...).

SUBST_SED = sed \
		-e 's,[@]prefix[@],@prefix@,g' \
		-e 's,[@]bindir[@],@bindir@,g' \
		-e 's,[@]libdir[@],@libdir@,g' \
		-e 's,[@]libexecdir[@],@libexecdir@,g' \
		-e 's,[@]datadir[@],@datadir@,g' \
		-e 's,[@]builddir[@],@top_builddir@,g' \
		-e 's,[@]srcdir[@],@top_srcdir@,g' \
		-e 's,[@]abs_builddir[@],@abs_top_builddir@,g' \
		-e 's,[@]abs_srcdir[@],@abs_top_srcdir@,g' \
		-e 's,[@]gladedir[@],$(gladedir),g' \
		-e 's,[@]imagedir[@],$(imagedir),g' \
		-e 's,[@]pkgdatadir[@],$(pkgdatadir),g' \
		-e 's,[@]pkglibdir[@],$(pkglibdir),g' \
		-e 's,[@]pkgincludedir[@],$(pkgincludedir),g' \
		-e 's,[@]pkglibexecdir[@],$(pkglibexecdir),g' \
		-e 's,[@]GEN_PACKAGENAME[@],$(GEN_PACKAGENAME),g' \
		-e 's,[@]VERSION[@],$(VERSION),g'

SUBST = \
	mkdir -p `dirname $@` ; \
	rm -f $@.tmp ; \
	touch $@.tmp ; \
	echo ''						>> $@.tmp ; \
	echo '// Generated from: $<'			>> $@.tmp ; \
	echo ''						>> $@.tmp ; \
	$(SUBST_SED) < $< 				>> $@.tmp ; \
	chmod a-w $@.tmp ; \
	mv -f $@.tmp $@

SUFFIXES += .javain
.javain.java: Makefile
	$(SUBST)
$(GEN_SOURCENAME)/Build.java: common/Build.javain Makefile
	$(SUBST)
TestRunner.java: common/TestRunner.javain Makefile
	$(SUBST)
$(GEN_SOURCENAME)/JUnitTests.java: Makefile
	mkdir -p $(GEN_SOURCENAME)
	rm -f $@.tmp
	touch $@.tmp
	echo 'package $(GEN_PACKAGENAME);'			>> $@.tmp
	echo 'import java.util.LinkedList;'			>> $@.tmp
	echo '/** JUnit tests for $(GEN_DIR) directory.  */'	>> $@.tmp
	echo 'public class JUnitTests'				>> $@.tmp
	echo '{'						>> $@.tmp
	echo '  public static LinkedList get ()'		>> $@.tmp
	echo '  {'						>> $@.tmp
	echo '    LinkedList list = new LinkedList ();'		>> $@.tmp
	( cd $(srcdir) ; \
	  find ${GEN_DIRS} \
	    -name 'TestLib.*' -prune -o \
	    -name 'JUnit*' -prune -o \
	    -name '*Test*.java' -print \
	    | sort -f | while read test ; do \
		main=`$(JV_SCAN) --print-main $${test}` ; \
		if test "$$main"x = x ; then \
			echo $${test} | sed \
				-e 's,/,.,g' \
				-e 's,.java$$,.class,' \
				-e 's,\(.*\),    list.add(\1);,' ; \
		fi ; \
	  done \
	)							>> $@.tmp
	echo '    return list;'					>> $@.tmp
	echo '  }'						>> $@.tmp
	echo '}'						>> $@.tmp
	mv -f $@.tmp $@

# Generate a .h file (using CNI) from the corresponding .java file.

# A single .java file can result in multiple .class files (due to
# inner classes) and they in turn lead to multiple .h files.  Instead
# of trying to track all of them just generate the main .h file
# filling in the others as a side-effect.

# Need to store the intermediate .class files in a separate directory
# as otherwize GCJ will include a possibly out-dated .class file
# instead of the latest .java file leading to screwed up in
# dependencies.

# jv-scan occasionally gets it wrong generating extra classes
# (actually it is that jv-scan's output doesn't necessarially agree
# with that of JAVAC), work around this by checking that each class
# really exists.

.java.h:
	classes=`$(JV_SCAN) --list-class '$<'` ; \
	tmpdir=`echo $$classes | ( read a b ; echo $$a )`.tmp ; \
	rm -rf $$tmpdir ; \
	mkdir -p $$tmpdir ; \
	$(GCJCOMPILE) -C -d $$tmpdir '$<' ; \
	for class in $$classes ; do \
		file=`echo $${class} | tr '[.]' '[/]'`.class ; \
		if test -r $$tmpdir/$${file} ; then \
			$(GCJH) -I $$tmpdir -d . $(GCJHFLAGS) $$class ; \
		fi ; \
	done ; \
	rm -rf $$tmpdir

# Shared library rule (for moment assume that .a contains PIC code).
SUFFIXES += .so
.a.so:
	soname=`basename $@` ; \
	$(CC) -shared -o $@.tmp \
		-Wl,--whole-archive,$<,--no-whole-archive \
		-Wl,--soname,$$soname,-z,-defs
	if readelf -d $@.tmp | fgrep -q TEXTREL; then exit 1; fi
	mv $@.tmp $@

# Clueless automake: Use a phony DATA entry to convince AUTOMAKE that
# it really should install a .so file into LIBDIR.  The obvious
# choice, lib_LIBRARIES, attracts an error because .so isn't a valid
# extention (serious!); mean while LTLIBRARIES insists that the world
# should use LIBTOOL.

solibdir = $(libdir)
solib_PROGRAMS =

# The shared java directory (typically /usr/share/java/; contains
# things like .jar files.

javadir = $(datadir)/java
java_DATA =

# Assembler rule.

.S.o:
	$(CCASCOMPILE) -c -o $@ $<

# Hack to save us constantly editing this file.  The assumption is
# that all .java and .cxx files are always built.  Recursively call
# make to ensure that Makefile is up-to-date.

$(srcdir)/Makefile.gen: $(srcdir)/common/Makefile.gen.sh
	cd $(srcdir) && ./common/Makefile.gen.sh $(GEN_ARGS)
.PHONY: autogen
autogen: clean
	cd $(srcdir) && ./autogen.sh

# Given a .jar, just convert it into a .o, and a .db

SUFFIXES += .jar
.jar.o:
	$(GCJCOMPILE) -fjni -c $<

# Since automake only adds GCJCOMPILE to Makefile.in when its seen
# .java source, provide our own definition.
GCJCOMPILE ?= $(GCJ) $(AM_GCJFLAGS) $(GCJFLAGS)

SUFFIXES += .db
.jar.db:
	$(GCJ_DBTOOL) -n $@.tmp
	$(GCJ_DBTOOL) -a $@.tmp $*.jar lib$*.so
	mv $@.tmp $@

# Given a .java file convert it to a .o file.

# XXX: GCJ has a bug where it totally scrambles nested classes with
# identical names.  Reject any code with duplicate class names.

# XXX: GCJ has a bug where, when given a -Werror fail, it still exits
# with success.  Hack around this by saving the message in a log file
# and then checking that it is empty.

.java.o:
	dups=`$(JV_SCAN) --list-class $< \
		| tr '[ ]' '[\n]' \
		| sed -n -e 's,^.*$$\([A-Z]\),\1,p' \
		| sort | uniq -d` ; \
	if test x"$$dups" != x ; then echo "Duplicate class names tickle a GCJ bug: $$dups" ; exit 1 ; fi
	depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`; \
	if $(GCJCOMPILE) -MT $@ -MD -MP -MF "$$depbase.Tpo" -c -o $@ $< 2>&1 | tee $*.log && test ! -s $*.log ; \
	then mv -f "$$depbase.Tpo" "$$depbase.Po"; else rm -f "$$depbase.Tpo"; exit 1; fi
	rm -f $*.log

# Build a version of frysk that behaves like the Java interpreter
# (while it is set up to be run anywhere it is not installed -- there
# is one of these per-directory).

# XXX: There is a horrible race condition here, fryski depends on all
# the .so being created but the below only (via GEN_GCJ_LDADD)
# explicitly mentions .a files.  Make will build fryski after the .a
# but before the .so.  Work around this by prepending a list of the
# local .so files to LDADD.

fryski_SOURCES =
fryski_LINK = $(GCJLINK)
noinst_PROGRAMS += fryski
fryski_LDFLAGS = \
	-lgij \
	-Wl,-rpath,$(GEN_GCJ_RPATH) \
	$(GEN_GCJ_SO_FLAGS)
fryski_LDADD = \
	$(patsubst lib%.a, lib%.so, $(filter lib%.a,$(GEN_GCJ_LDADD))) \
	$(GEN_GCJ_LDADD)

# Wrap fryski in an interpreter script.

# XXX: Do not use LD_PRELOAD here.  If frysk creates a child process
# then that child will see and execute the LD_PRELOAD.

# XXX: Do not use -Dgnu.gcj.precompiled.db.path=$(DBPATH) here.  For
# reasons not yet explained it is ignored.

noinst_PROGRAMS += gij.sh
gij_sh_SOURCES =
gij.sh: Makefile
	rm -f $@.tmp
	echo '#!/bin/sh' >> $@.tmp
	echo 'export LD_LIBRARY_PATH="$(GEN_GCJ_RPATH)"' >> $@.tmp
	echo 'export CLASSPATH="$(GEN_CLASSDIR):$(CLASSPATH):$${CLASSPATH}"' >> $@.tmp
	echo 'exec ./fryski "$$@"' >> $@.tmp
	chmod a+x $@.tmp
	mv $@.tmp $@

SUFFIXES += .fig .jpg .pdf .eps .gif .txt
.fig.jpg:
	mkdir -p `dirname $@`
	$(FIG2DEV) -L jpeg $< $@
.fig.pdf:
	mkdir -p `dirname $@`
	$(FIG2DEV) -L pdf $< $@
.fig.eps:
	mkdir -p `dirname $@`
	$(FIG2DEV) -L eps $< $@
.fig.gif:
	mkdir -p `dirname $@`
	$(FIG2DEV) -L gif $< $@
.fig.txt:
	mkdir -p `dirname $@`
	echo "@center See the @sc{pdf} or @sc{html} documentation." > $@
BUILT_SOURCES += $(GEN_FIG:.fig=.jpg)


# Add some needed files to the distribution, include $(srcdir) so that
# the reg-ex expansion occures there.

EXTRA_DIST += \
	$(srcdir)/common/ChangeLog \
	$(srcdir)/common/EXCEPTION \
	$(srcdir)/common/*.sh \
	$(srcdir)/common/*.m4 \
	$(srcdir)/common/version.in \
	$(srcdir)/common/m4/*.m4 \
	$(srcdir)/autogen.sh

# .Po files contain generated build dependencies.  Automake has no way
# to efficiently detect a file rename or remove, and consequently, the
# need to update .Po files that contain the no-longer-exists file.
# Hack this by scrubbing .Po files as part of make clean -- this
# abuses the developer's reflex to type: make - barf; make clean;
# make :-)

clean-local: clean-local-po
.PHONY: clean-local-po
clean-local-po:
	find $(GEN_DIRS) -name '*.Po' -exec cp /dev/null \{\} \;

# For distclean, which is ment to leave a 100% pristine source tree,
# remove everything listed in .cvsignore.

distclean-local: distclean-cvsignored
.PHONY: distclean-cvsignored
distclean-cvsignored:
	cd $(srcdir) ; \
	find . -type f -name .cvsignore -print \
	| while read f ; do \
		( cd `dirname $$f` && rm -rf `cat .cvsignore` ) ; \
	done

# Create a list of .java files that need to be compiled.  It turns out
# that it is faster to just feed all the files en-mass to the compiler
# (then compile each individually).  Put the list into a file to avoid
# having too-long an argument list.  Remember to filter out duplicate
# directories (as occures when building in the source tree).  An
# explict clean rule is needed as CLEANFILES can't handle directories.

CLEANFILES += files.list
files.list: lib${GEN_DIRNAME}.a
	topdirs= ; \
	for d in $(top_builddir) $(top_srcdir) ; do \
	    p=`cd $$d && pwd` ; \
	    case " $$topdirs " in \
	        *$$p* ) continue ;; \
	    esac ; \
	    topdirs="$$dirs $$p" ; \
	    for g in $(GEN_DIRS) ; do \
		find $$p/$$g \
		    -name '*#*' -prune -o \
		    -name '[A-Za-z]*.java' -print ; \
	    done \
	done > $@.tmp
	mv $@.tmp $@
${GEN_DIRNAME}.jar: files.list
	rm -rf $(GEN_CLASSDIR)
	mkdir -p $(GEN_CLASSDIR)
	$(JAVAC) -d $(GEN_CLASSDIR) $(JAVACFLAGS) \
		@$(top_builddir)/files.list \
		2>&1 | tee $*.log
	if test -s $*.log ; \
	then rm $*.log ; false ; \
	fi
	rm -f $*.log
	cd $(GEN_CLASSDIR) ; \
		find * -name '*.class' -print \
		| $(JAR) -@ -cf $@
	mv $(GEN_CLASSDIR)/$@ $@
.PHONY: clean-classes-dir
clean-local: clean-classes-dir
clean-classes-dir:
	rm -rf $(GEN_CLASSDIR)

# When ECJ is available, use it as an extra lint pass.  GCJ has the
# habit of silently compiling invalid Java code (garbage in, garbage out),
# fortunatly ECJ rejects it.

if HAVE_ECJ
all-local: ecj/checked
endif
ecj/checked: files.list
	rm -rf ecj
	mkdir -p ecj
	$(ECJ) \
		-d ecj \
		-warn:+semicolon \
		-sourcepath $(SOURCEPATH) \
		-classpath $(CLASSPATH) \
		@$(top_builddir)/files.list \
		2>&1 | tee $@.log
	if test -s $@.log ; \
	then rm $@.log ; false ; \
	fi
	rm -f $@.log
	touch $@
.PHONY: clean-ecj-dir
clean-local: clean-ecj-dir
clean-ecj-dir:
	rm -rf ecj
