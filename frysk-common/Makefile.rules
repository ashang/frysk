# This file is part of the program FRYSK.
#
# Copyright 2005, Red Hat Inc.
#
# FRYSK is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# FRYSK is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with FRYSK; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
# 
# In addition, as a special exception, Red Hat, Inc. gives You the
# additional right to link the code of FRYSK with code not covered
# under the GNU General Public License ("Non-GPL Code") and to
# distribute linked combinations including the two, subject to the
# limitations in this paragraph. Non-GPL Code permitted under this
# exception must only link to the code of FRYSK through those well
# defined interfaces identified in the file named EXCEPTION found in
# the source code files (the "Approved Interfaces"). The files of
# Non-GPL Code may instantiate templates or use macros or inline
# functions from the Approved Interfaces without causing the
# resulting work to be covered by the GNU General Public
# License. Only Red Hat, Inc. may make changes or additions to the
# list of Approved Interfaces. You must obey the GNU General Public
# License in all respects for all of the FRYSK code and other code
# used in conjunction with FRYSK except the Non-GPL Code covered by
# this exception. If you modify this file, you may extend this
# exception to your version of the file, but you are not obligated to
# do so. If you do not wish to provide this exception without
# modification, you must delete this exception statement from your
# version and license this file solely under the GPL without
# exception.

# Initialize everything to empty and then use += to add things in.

SUFFIXES =
BUILT_SOURCES = $(GEN_BUILT_MKJAVA) $(GEN_BUILT_SHJAVA)
CLEANFILES = $(BUILT_SOURCES)
noinst_PROGRAMS =
bin_PROGRAMS =
sbin_PROGRAMS =
libexec_PROGRAMS =
noinst_LIBRARIES =
LDADD = 

check_SCRIPTS =
TESTS =
GEN_CLASSPATH =
GEN_SOURCEPATH = $(srcdir) $(top_builddir)
empty=
space=$(empty) $(empty)
GEN_CLASSDIR = classes
EXTRA_DIST = 

# The list of libraries for the GCJ programs is different to that of
# the standalone .c programs.  Accumulate the GCJ list in
# GEN_GCJ_LDADD.

GEN_GCJ_LDADD = 

# Take the LDADD list and transform it into a dynamic shared library
# list.  This can then, in turn be converted into an in-build-tree
# RPATH to wire into in-build-tree program that need to access those
# shared libraries.

# Convert LDADD's .a into -L<dir> -llib
GEN_GCJ_SO_FLAGS = \
	$(foreach lib, $(GEN_GCJ_LDADD), \
		$(if $(filter -L%,$(lib)), $(lib)) \
		$(if $(filter -l%,$(lib)), $(lib)) \
		$(if $(filter %.a,$(lib)), \
			$(patsubst %,-L%,$(dir $(lib))) \
			$(patsubst lib%.a,-l%,$(notdir $(lib))) \
			) \
		)
# Just the directories.
GEN_GCJ_SO_DIRS = \
	$(patsubst -L%,%,$(filter -L%, $(GEN_GCJ_SO_FLAGS)))
# Add absolute versions of each directory.
GEN_GCJ_RPATHS = \
	$(patsubst %/./,%, $(patsubst %/.,%, \
		$(foreach lib, $(GEN_GCJ_SO_DIRS), \
			$(if $(filter /%,$(lib)), $(lib)) \
			$(if $(filter .%,$(lib)), \
				$(patsubst %,@abs_top_builddir@/%, $(lib)) \
				$(lib) \
				) \
			) \
		))
GEN_GCJ_RPATH = $(subst $(space),:,$(sort $(GEN_GCJ_RPATHS)))
GEN_GCJ_RPATH_FLAGS = \
	-Djava.library.path=$(GEN_GCJ_RPATH) \
	-Wl,-rpath,$(GEN_GCJ_RPATH)

# Get some common macro definitions

ACLOCAL_AMFLAGS = -I common/m4

# Make up some javacflags

SOURCEPATH = $(subst $(space),:,$(strip $(GEN_SOURCEPATH)))
CLASSPATH = $(subst $(space),:,$(strip $(GEN_CLASSPATH)))
DBPATH = $(subst $(space),:,$(strip \
	$(patsubst %.jar,%.db,$(filter %.jar,$(GEN_CLASSPATH))) \
	$(foreach dir,$(patsubst %/$(GEN_CLASSDIR),%,$(filter-out %.jar,$(GEN_CLASSPATH))),$(dir)/$(notdir $(dir)).db) \
	))

JAVAC = @JAVAC@
JAVACFLAGS = @JAVACFLAGS@


# XXX: GCJ: I think there should be a -Wextraneous-throws; I think
# -Wno-deprecated is backward; I think -Wredundant-modifiers is broken
# with gcc4.  It appears to complain about abstract methods in a
# non-abstract class when the class actually is abstract.

AM_GCJFLAGS = \
	$(patsubst %,-I%,$(GEN_SOURCEPATH) $(GEN_CLASSPATH)) \
	-Werror \
	-Wall \
	-fPIC \
	$(ZZZ)


AM_CXXFLAGS = \
	-I$(srcdir) \
	-I$(top_builddir) \
	-Werror \
	-Wall \
	-fpic \
	$(ZZZ)


# Rule for building a .java file from an input .mkclass file.  This
# lets us specify CLASS.java directly in the BUILT_SOURCES list.

MKJAVA = $(srcdir)/common/mkjava.sh
SUFFIXES += .mkjava
.mkjava.java:
	rm -f $*.tmp
	$(SHELL) $(MKJAVA) < $(srcdir)/$*.mkjava > $*.tmp $@
	chmod a-w $*.tmp
	mv -f $*.tmp $@
$(GEN_BUILT_MKJAVA): $(MKJAVA)

# Rule for building a .java file from a shell|mkjava pipeline.

SUFFIXES += .shjava
.shjava.java:
	rm -f $*.tmp
	$(SHELL) $< | $(SHELL) $(MKJAVA) > $*.tmp $@
	chmod a-w $*.tmp
	mv -f $*.tmp $@
$(SHJAVA_BUILT): $(MKJAVA)

# Mimic autoconf's behavior, by doing it in the Makefile all the
# variables are automatically expanded.

# Don't be confused by top_builddir and top_srcdir, they are actually
# the directory corresponding to current sub-directory (frysk-gui,
# frysk-core, ...).

SUFFIXES += .javain
.javain.java:
	rm -f $*.tmp
	sed < $< \
		-e 's,[@]prefix[@],@prefix@,g' \
		-e 's,[@]bindir[@],@bindir@,g' \
		-e 's,[@]libdir[@],@libdir@,g' \
		-e 's,[@]libexecdir[@],@libexecdir@,g' \
		-e 's,[@]datadir[@],@datadir@,g' \
		-e 's,[@]builddir[@],@top_builddir@,g' \
		-e 's,[@]srcdir[@],@top_srcdir@,g' \
		-e 's,[@]abs_builddir[@],@abs_top_builddir@,g' \
		-e 's,[@]abs_srcdir[@],@abs_top_srcdir@,g' \
		-e 's,[@]gladedir[@],$(gladedir),g' \
		-e 's,[@]imagedir[@],$(imagedir),g' \
		-e 's,[@]pkgdatadir[@],$(pkgdatadir),g' \
		-e 's,[@]pkglibdir[@],$(pkglibdir),g' \
		-e 's,[@]pkgincludedir[@],$(pkgincludedir),g' \
		> $*.tmp
	mv -f $*.tmp $@


# Generate a .h file (using CNI) from the corresponding .java file.

# A single .java file can result in multiple .class files (due to
# inner classes) and they in turn lead to multiple .h files.  Instead
# of trying to track all of them just generate the main .h file
# filling in the others as a side-effect.

# Need to store the intermediate .class files in a separate directory
# as otherwize GCJ will include a possibly out-dated .class file
# instead of the latest .java file leading to screwed up in
# dependencies.

# jv-scan occasionally gets it wrong generating extra classes
# (actually it is that jv-scan's output doesn't necessarially agree
# with that of JAVAC), work around this by checking that each class
# really exists.

GCJH = $(GCJ)h
.java.h:
	classes=`jv-scan --list-class '$<'` ; \
	tmpdir=`echo $$classes | ( read a b ; echo $$a )`.tmp ; \
	rm -rf $$tmpdir ; \
	mkdir -p $$tmpdir ; \
	$(GCJCOMPILE) -C -d $$tmpdir '$<' ; \
	for class in $$classes ; do \
		file=`echo $${class} | tr '[.]' '[/]'`.class ; \
		if test -r $$tmpdir/$${file} ; then \
			$(GCJH) -I $$tmpdir -d . $(GCJHFLAGS) $$class ; \
		fi ; \
	done ; \
	rm -rf $$tmpdir

# Shared library rule (for moment assume that .a contains PIC code).
SUFFIXES += .so
.a.so:
	$(CC) -shared -o $@.tmp \
		-Wl,--whole-archive,$<,--no-whole-archive \
		-Wl,--soname,$@,-z,-defs
	if readelf -d $@.tmp | fgrep -q TEXTREL; then exit 1; fi
	mv $@.tmp $@

# Clueless automake: Use a phony DATA entry to convince AUTOMAKE that
# it really should install a .so file into LIBDIR.  The obvious
# choice, lib_LIBRARIES, attracts an error because .so isn't a valid
# extention (serious!); mean while LTLIBRARIES insists that the world
# should use LIBTOOL.

solibdir = $(libdir)
solib_PROGRAMS =

# The shared java directory (typically /usr/share/java/; contains
# things like .jar files.

javadir = $(datadir)/java
java_DATA =

# Assembler rule.

.S.o:
	$(CCASCOMPILE) -c -o $@ $<

# Hack to save us constantly editing this file.  The assumption is
# that all .java and .cxx files are always built.  Recursively call
# make to ensure that Makefile is up-to-date.

$(srcdir)/Makefile.gen: $(srcdir)/common/Makefile.gen.sh
	cd $(srcdir) && ./common/Makefile.gen.sh $(GEN_ARGS)
.PHONY: autogen
autogen: clean
	cd $(srcdir) && ./autogen.sh

# Given a .jar, just convert it into a .o, and a .db

SUFFIXES += .jar
.jar.o:
	$(GCJCOMPILE) -fjni -c $<

# Since automake only adds GCJCOMPILE to Makefile.in when its seen
# .java source, provide our own definition.
GCJCOMPILE ?= $(GCJ) $(AM_GCJFLAGS) $(GCJFLAGS)

SUFFIXES += .db
.jar.db:
	gcj-dbtool -n $@.tmp
	gcj-dbtool -a $@.tmp $*.jar lib$*.so
	mv $@.tmp $@


# Build the TestJUnits program.

TestRunner_SOURCES = TestRunner.java
TestRunner_LINK = ${GCJLINK}
TestRunner_LDFLAGS = --main=TestRunner $(GEN_GCJ_RPATH_FLAGS)
TestRunner_LDADD = $(LIBJUNIT) $(GEN_GCJ_LDADD)
TESTS += TestRunner
noinst_PROGRAMS += TestRunner
CLEANFILES += TestRunner.java

TestRunner.java: common/TestRunner.sh Makefile
	$(srcdir)/common/TestRunner.sh $(GEN_JUNIT_TESTS) > TestRunner.tmp
	mv  TestRunner.tmp  TestRunner.java


# Build a version of frysk that behaves like the Java interpreter
# (while it is set up to be run anywhere it is not installed -- there
# is one of these per-directory).

# XXX: There is a horrible race condition here, fryski depends on all
# the .so being created but the below only (via GEN_GCJ_LDADD)
# explicitly mentions .a files.  Make will build fryski after the .a
# but before the .so.  Work around this by prepending a list of the
# local .so files to LDADD.

fryski_SOURCES =
fryski_LINK = $(GCJLINK)
noinst_PROGRAMS += fryski
fryski_LDFLAGS = \
	-lgij \
	-Wl,-rpath,$(GEN_GCJ_RPATH) \
	$(GEN_GCJ_SO_FLAGS)
fryski_LDADD = \
	$(patsubst lib%.a, lib%.so, $(filter lib%.a,$(GEN_GCJ_LDADD))) \
	$(GEN_GCJ_LDADD)

# Wrap fryski in an interpreter script.

# XXX: Do not use LD_PRELOAD here.  If frysk creates a child process
# then that child will see and execute the LD_PRELOAD.

# XXX: Do not use -Dgnu.gcj.precompiled.db.path=$(DBPATH) here.  For
# reasons not yet explained it is ignored.

noinst_PROGRAMS += gij.sh
gij_sh_SOURCES =
gij.sh: Makefile
	rm -f $@.tmp
	echo '#!/bin/sh' >> $@.tmp
	echo 'export LD_LIBRARY_PATH="$(GEN_GCJ_RPATH)"' >> $@.tmp
	echo 'export CLASSPATH="$(GEN_CLASSDIR):$(CLASSPATH):$${CLASSPATH}"' >> $@.tmp
	echo 'exec ./fryski "$$@"' >> $@.tmp
	chmod a+x $@.tmp
	mv $@.tmp $@

# When it comes to clean, automake forgets to scrub the .Po files
# (which contain built dependencies).  After a file rename or similar,
# this can result in a .Po file refering to a non-existant file.  Hack
# around it by emptying all the .Po files.
clean-local: clean-local-po
.PHONY: clean-local-po
clean-local-po:
	find . -name '*.Po' -exec cp /dev/null \{\} \;

SUFFIXES += .fig .jpg .pdf .eps .gif .txt
.fig.jpg:
	mkdir -p `dirname $@`
	$(FIG2DEV) -L jpeg $< $@
.fig.pdf:
	mkdir -p `dirname $@`
	$(FIG2DEV) -L pdf $< $@
.fig.eps:
	mkdir -p `dirname $@`
	$(FIG2DEV) -L eps $< $@
.fig.gif:
	mkdir -p `dirname $@`
	$(FIG2DEV) -L gif $< $@
.fig.txt:
	mkdir -p `dirname $@`
	echo "@center See the @sc{pdf} or @sc{html} documentation." > $@
BUILT_SOURCES += $(GEN_FIG:.fig=.jpg)


# Add some needed files to the distribution
EXTRA_DIST += 	common/Makefile.gen.sh \
				common/mkjava.sh \
				common/TestRunner.sh \
				EXCEPTION
