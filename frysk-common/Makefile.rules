# This file is part of FRYSK.
#
# Copyright 2005, Red Hat Inc.
#
# FRYSK is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# FRYSK is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with FRYSK; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

# Initialize everything to empty and then use += to add things in.

SUFFIXES =
BUILT_SOURCES = $(GEN_BUILT_MKJAVA) $(GEN_BUILT_SHJAVA)
CLEANFILES = $(BUILT_SOURCES)
noinst_PROGRAMS =
bin_PROGRAMS =
noinst_LIBRARIES =
LDADD = 
check_SCRIPTS =
TESTS =
GEN_CLASSPATH = 
GEN_SOURCEPATH = $(srcdir) $(top_builddir)
empty=
space=$(empty) $(empty)
GEN_BUILT_CLASSES =

# Make up some javacflags

JAVAC = javac
JAVACFLAGS = \
	-g \
	-1.4 \
	-sourcepath $(subst $(space),:,$(strip $(GEN_SOURCEPATH))) \
	-classpath $(subst $(space),:,$(strip $(GEN_CLASSPATH)))


# Modify the link rules so the program <dir>/<prog> is built with
# <dir>.<prog>.main() as the Java entry point.

AM_LDFLAGS = \
	--main=$$( \
		b=$$(basename $@ $(EXEEXT)) ; \
		d=$$(dirname $@ | tr '[/]' '[.]') ; \
		if test x"$$d" = x. ; then \
			main=$$b.$$b ; \
		else \
			main=$$d.$$b ; \
		fi ; \
		echo main=$$main 1>&2 ; \
		echo $$main )


# XXX: GCJ: I think there should be a -Wextraneous-throws; I think
# -Wno-deprecated is backward; I think -Wredundant-modifiers is broken
# with gcc4.  It appears to complain about abstract methods in a
# non-abstract class when the class actually is abstract.

AM_GCJFLAGS = \
	$(patsubst %,-I%,$(GEN_SOURCEPATH) $(GEN_CLASSPATH)) \
	-Werror \
	-Wall \
	-fPIC \
	$(ZZZ)


AM_CXXFLAGS = \
	-I$(srcdir) \
	-I$(srcdir)/include \
	-I$(top_buildir) \
	-Werror \
	-Wall \
	-fpic \
	$(ZZZ)


# Rule for building a .java file from an input .mkclass file.  This
# lets us specify CLASS.java directly in the BUILT_SOURCES list.

MKJAVA = $(srcdir)/common/mkjava.sh
SUFFIXES += .mkjava
.mkjava.java:
	rm -f $*.tmp
	$(SHELL) $(MKJAVA) < $(srcdir)/$*.mkjava > $*.tmp $@
	chmod a-w $*.tmp
	mv -f $*.tmp $@
$(MKJAVA_BUILT): $(MKJAVA)
BUILT_SOURCES += $(MKJAVA_BUILT)

# Rule for building a .java file from a shell|mkjava pipeline.

SUFFIXES += .shjava
.shjava.java:
	rm -f $*.tmp
	$(SHELL) $< | $(SHELL) $(MKJAVA) > $*.tmp $@
	chmod a-w $*.tmp
	mv -f $*.tmp $@
$(SHJAVA_BUILT): $(MKJAVA)
BUILT_SOURCES += $(SHJAVA_BUILT)



# Since a single .java file can result in multiple .class files (due
# to inner classes) trying to track all those would get complicated.
# Instead generate a .classes file containing the list of .class files
# that will be created and use that for all dependencies.

# jv-scan occasionally gets it wrong generating extra classes, work
# around this by checking that each class really exists.

SUFFIXES += .classes
.java.classes:
	rm -f $*.class $*\$$*.class
	$(JAVAC) -d . $(JAVACFLAGS)  $<
	echo '# $<' > $*.classes.tmp
	ls $*.class $*\$$*.class | \
		sed -e 's,.class$$,,' | \
		sort -f > $*.classes.tmp
	mv -f $*.classes.tmp $*.classes
#	jv-scan --list-class '$<' | tr '[ ]' '[\n]' | \
#		while read class ; do \
#			file=`echo $${class} | tr '[.]' '[/]'`.class ; \
#			if test -r $${file} ; then \
#				echo $${class} ; \
#			else \
#				echo "# $${class} -- jv-scan BUG?" ; \
#			fi \
#		done >> $*.classes.tmp

# Generate a .h file (using CNI) from the .classes file.

GCJH = $(GCJ)h
.classes.h:
	$(GCJH) $(GCJHFLAGS) `sed -e '/^#/d' $<`


# Shared library rule (for moment assume that .a contains PIC code).
SUFFIXES += .so
.a.so:
	$(CC) -shared -o $@.tmp \
		-Wl,--whole-archive,$<,--no-whole-archive \
		-Wl,--soname,$@,-z,-defs
	if readelf -d $@.tmp | fgrep -q TEXTREL; then exit 1; fi
	mv $@.tmp $@

# Assembler rule.

.S.o:
	$(CCASCOMPILE) -c -o $@ $<

# Hack to save us constantly editing this file.  The assumption is
# that all .java and .cxx files are always built.  Recursively call
# make to ensure that Makefile is up-to-date.

$(srcdir)/Makefile.gen: $(srcdir)/common/Makefile.gen.sh
	cd $(srcdir) && ./common/Makefile.gen.sh $(GEN_DIRS) $(GEN_JARS)
.PHONY: autogen
autogen: clean
	cd $(srcdir) && ./autogen.sh

# Given a .jar, just convert it into a .o, and a .db

SUFFIXES += .jar
.jar.o:
	$(GCJ) $(AM_GCJFLAGS) $(GCJFLAGS) -fjni -c $<

# Since automake only adds GCJCOMPILE to Makefile.in when its seen
# .java source, provide our own definition.
GCJCOMPILE ?= $(GCJ) $(AM_GCJFLAGS) $(GCJFLAGS)

SUFFIXES += .db
.jar.db:
	gcj-dbtool -n $@.tmp
	gcj-dbtool -a $@.tmp $*.jar lib$*.so
	mv $@.tmp $@
